!function(n){function e(n){var e=document.getElementsByTagName("head")[0],t=document.createElement("script");t.type="text/javascript",t.charset="utf-8",t.src=p.p+""+n+"."+y+".hot-update.js",e.appendChild(t)}function t(n){if("undefined"==typeof XMLHttpRequest)return n(new Error("No browser support"));try{var e=new XMLHttpRequest,t=p.p+""+y+".hot-update.json";e.open("GET",t,!0),e.timeout=1e4,e.send(null)}catch(a){return n(a)}e.onreadystatechange=function(){if(4===e.readyState)if(0===e.status)n(new Error("Manifest request to "+t+" timed out."));else if(404===e.status)n();else if(200!==e.status&&304!==e.status)n(new Error("Manifest request to "+t+" failed."));else{try{var a=JSON.parse(e.responseText)}catch(r){return void n(r)}n(null,a)}}}function a(n){var e=k[n];if(!e)return p;var t=function(t){return e.hot.active?k[t]?(k[t].parents.indexOf(n)<0&&k[t].parents.push(n),e.children.indexOf(t)<0&&e.children.push(t)):w=[n]:(console.warn("[HMR] unexpected require("+t+") from disposed module "+n),w=[]),p(t)};for(var a in p)Object.prototype.hasOwnProperty.call(p,a)&&(t[a]=p[a]);return t.e=function(n,e){"ready"===T&&o("prepare"),j++,p.e(n,function(){function a(){j--,"prepare"===T&&(S[n]||c(n),0===j&&0===_&&d())}try{e.call(null,t)}finally{a()}})},t}function r(n){var e={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_disposeHandlers:[],active:!0,accept:function(n,t){if("undefined"==typeof n)e._selfAccepted=!0;else if("function"==typeof n)e._selfAccepted=n;else if("object"==typeof n)for(var a=0;a<n.length;a++)e._acceptedDependencies[n[a]]=t;else e._acceptedDependencies[n]=t},decline:function(n){if("undefined"==typeof n)e._selfDeclined=!0;else if("number"==typeof n)e._declinedDependencies[n]=!0;else for(var t=0;t<n.length;t++)e._declinedDependencies[n[t]]=!0},dispose:function(n){e._disposeHandlers.push(n)},addDisposeHandler:function(n){e._disposeHandlers.push(n)},removeDisposeHandler:function(n){var t=e._disposeHandlers.indexOf(n);t>=0&&e._disposeHandlers.splice(t,1)},check:s,apply:u,status:function(n){return n?void x.push(n):T},addStatusHandler:function(n){x.push(n)},removeStatusHandler:function(n){var e=x.indexOf(n);e>=0&&x.splice(e,1)},data:v[n]};return e}function o(n){T=n;for(var e=0;e<x.length;e++)x[e].call(null,n)}function i(n){var e=+n+""===n;return e?+n:n}function s(n,e){if("idle"!==T)throw new Error("check() is only allowed in idle status");"function"==typeof n?(b=!1,e=n):(b=n,e=e||function(n){if(n)throw n}),o("check"),t(function(n,t){if(n)return e(n);if(!t)return o("idle"),void e(null,null);D={},C={},S={};for(var a=0;a<t.c.length;a++)C[t.c[a]]=!0;g=t.h,o("prepare"),f=e,m={};var r=0;c(r),"prepare"===T&&0===j&&0===_&&d()})}function l(n,e){if(C[n]&&D[n]){D[n]=!1;for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(m[t]=e[t]);0===--_&&0===j&&d()}}function c(n){C[n]?(D[n]=!0,_++,e(n)):S[n]=!0}function d(){o("ready");var n=f;if(f=null,n)if(b)u(b,n);else{var e=[];for(var t in m)Object.prototype.hasOwnProperty.call(m,t)&&e.push(i(t));n(null,e)}}function u(e,t){function a(n){for(var e=[n],t={},a=e.slice();a.length>0;){var o=a.pop(),n=k[o];if(n&&!n.hot._selfAccepted){if(n.hot._selfDeclined)return new Error("Aborted because of self decline: "+o);if(0===o)return;for(var i=0;i<n.parents.length;i++){var s=n.parents[i],l=k[s];if(l.hot._declinedDependencies[o])return new Error("Aborted because of declined dependency: "+o+" in "+s);e.indexOf(s)>=0||(l.hot._acceptedDependencies[o]?(t[s]||(t[s]=[]),r(t[s],[o])):(delete t[s],e.push(s),a.push(s)))}}}return[e,t]}function r(n,e){for(var t=0;t<e.length;t++){var a=e[t];n.indexOf(a)<0&&n.push(a)}}if("ready"!==T)throw new Error("apply() is only allowed in ready status");"function"==typeof e?(t=e,e={}):e&&"object"==typeof e?t=t||function(n){if(n)throw n}:(e={},t=t||function(n){if(n)throw n});var s={},l=[],c={};for(var d in m)if(Object.prototype.hasOwnProperty.call(m,d)){var u=i(d),h=a(u);if(!h){if(e.ignoreUnaccepted)continue;return o("abort"),t(new Error("Aborted because "+u+" is not accepted"))}if(h instanceof Error)return o("abort"),t(h);c[u]=m[u],r(l,h[0]);for(var u in h[1])Object.prototype.hasOwnProperty.call(h[1],u)&&(s[u]||(s[u]=[]),r(s[u],h[1][u]))}for(var f=[],b=0;b<l.length;b++){var u=l[b];k[u]&&k[u].hot._selfAccepted&&f.push({module:u,errorHandler:k[u].hot._selfAccepted})}o("dispose");for(var x=l.slice();x.length>0;){var u=x.pop(),_=k[u];if(_){for(var j={},S=_.hot._disposeHandlers,D=0;D<S.length;D++){var C=S[D];C(j)}v[u]=j,_.hot.active=!1,delete k[u];for(var D=0;D<_.children.length;D++){var $=k[_.children[D]];if($){var A=$.parents.indexOf(u);A>=0&&$.parents.splice(A,1)}}}}for(var u in s)if(Object.prototype.hasOwnProperty.call(s,u))for(var _=k[u],I=s[u],D=0;D<I.length;D++){var E=I[D],A=_.children.indexOf(E);A>=0&&_.children.splice(A,1)}o("apply"),y=g;for(var u in c)Object.prototype.hasOwnProperty.call(c,u)&&(n[u]=c[u]);var R=null;for(var u in s)if(Object.prototype.hasOwnProperty.call(s,u)){for(var _=k[u],I=s[u],O=[],b=0;b<I.length;b++){var E=I[b],C=_.hot._acceptedDependencies[E];O.indexOf(C)>=0||O.push(C)}for(var b=0;b<O.length;b++){var C=O[b];try{C(s)}catch(P){R||(R=P)}}}for(var b=0;b<f.length;b++){var N=f[b],u=N.module;w=[u];try{p(u)}catch(P){if("function"==typeof N.errorHandler)try{N.errorHandler(P)}catch(P){R||(R=P)}else R||(R=P)}}return R?(o("fail"),t(R)):(o("idle"),void t(null,l))}function p(e){if(k[e])return k[e].exports;var t=k[e]={exports:{},id:e,loaded:!1,hot:r(e),parents:w,children:[]};return n[e].call(t.exports,t,t.exports,a(e)),t.loaded=!0,t.exports}var h=this.webpackHotUpdate;this.webpackHotUpdate=function(n,e){l(n,e),h&&h(n,e)};var f,m,g,b=!0,y="8b9fb4039c4afa80792c",v={},w=[],x=[],T="idle",_=0,j=0,S={},D={},C={},k={};return p.m=n,p.c=k,p.p="",p.h=function(){return y},a(0)(0)}([function(module,exports,__webpack_require__){eval("__webpack_require__(22);\nmodule.exports = __webpack_require__(3);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** multi main\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///multi_main?")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v2.1.4\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-04-28T16:01Z\n */\n\n(function( global, factory ) {\n\n	if ( typeof module === "object" && typeof module.exports === "object" ) {\n		// For CommonJS and CommonJS-like environments where a proper `window`\n		// is present, execute the factory and get jQuery.\n		// For environments that do not have a `window` with a `document`\n		// (such as Node.js), expose a factory as module.exports.\n		// This accentuates the need for the creation of a real `window`.\n		// e.g. var jQuery = require("jquery")(window);\n		// See ticket #14549 for more info.\n		module.exports = global.document ?\n			factory( global, true ) :\n			function( w ) {\n				if ( !w.document ) {\n					throw new Error( "jQuery requires a window with a document" );\n				}\n				return factory( w );\n			};\n	} else {\n		factory( global );\n	}\n\n// Pass this if window is not defined yet\n}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {\n\n// Support: Firefox 18+\n// Can\'t be in strict mode, several libs including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through "use strict" call chains. (#13335)\n//\n\nvar arr = [];\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n\n\nvar\n	// Use the correct document accordingly with window argument (sandbox)\n	document = window.document,\n\n	version = "2.1.4",\n\n	// Define a local copy of jQuery\n	jQuery = function( selector, context ) {\n		// The jQuery object is actually just the init constructor \'enhanced\'\n		// Need init if jQuery is called (just allow error to be thrown if not included)\n		return new jQuery.fn.init( selector, context );\n	},\n\n	// Support: Android<4.1\n	// Make sure we trim BOM and NBSP\n	rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n	// Matches dashed string for camelizing\n	rmsPrefix = /^-ms-/,\n	rdashAlpha = /-([\\da-z])/gi,\n\n	// Used by jQuery.camelCase as callback to replace()\n	fcamelCase = function( all, letter ) {\n		return letter.toUpperCase();\n	};\n\njQuery.fn = jQuery.prototype = {\n	// The current version of jQuery being used\n	jquery: version,\n\n	constructor: jQuery,\n\n	// Start with an empty selector\n	selector: "",\n\n	// The default length of a jQuery object is 0\n	length: 0,\n\n	toArray: function() {\n		return slice.call( this );\n	},\n\n	// Get the Nth element in the matched element set OR\n	// Get the whole matched element set as a clean array\n	get: function( num ) {\n		return num != null ?\n\n			// Return just the one element from the set\n			( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n			// Return all the elements in a clean array\n			slice.call( this );\n	},\n\n	// Take an array of elements and push it onto the stack\n	// (returning the new matched element set)\n	pushStack: function( elems ) {\n\n		// Build a new jQuery matched element set\n		var ret = jQuery.merge( this.constructor(), elems );\n\n		// Add the old object onto the stack (as a reference)\n		ret.prevObject = this;\n		ret.context = this.context;\n\n		// Return the newly-formed element set\n		return ret;\n	},\n\n	// Execute a callback for every element in the matched set.\n	// (You can seed the arguments with an array of args, but this is\n	// only used internally.)\n	each: function( callback, args ) {\n		return jQuery.each( this, callback, args );\n	},\n\n	map: function( callback ) {\n		return this.pushStack( jQuery.map(this, function( elem, i ) {\n			return callback.call( elem, i, elem );\n		}));\n	},\n\n	slice: function() {\n		return this.pushStack( slice.apply( this, arguments ) );\n	},\n\n	first: function() {\n		return this.eq( 0 );\n	},\n\n	last: function() {\n		return this.eq( -1 );\n	},\n\n	eq: function( i ) {\n		var len = this.length,\n			j = +i + ( i < 0 ? len : 0 );\n		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n	},\n\n	end: function() {\n		return this.prevObject || this.constructor(null);\n	},\n\n	// For internal use only.\n	// Behaves like an Array\'s method, not like a jQuery method.\n	push: push,\n	sort: arr.sort,\n	splice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n	var options, name, src, copy, copyIsArray, clone,\n		target = arguments[0] || {},\n		i = 1,\n		length = arguments.length,\n		deep = false;\n\n	// Handle a deep copy situation\n	if ( typeof target === "boolean" ) {\n		deep = target;\n\n		// Skip the boolean and the target\n		target = arguments[ i ] || {};\n		i++;\n	}\n\n	// Handle case when target is a string or something (possible in deep copy)\n	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {\n		target = {};\n	}\n\n	// Extend jQuery itself if only one argument is passed\n	if ( i === length ) {\n		target = this;\n		i--;\n	}\n\n	for ( ; i < length; i++ ) {\n		// Only deal with non-null/undefined values\n		if ( (options = arguments[ i ]) != null ) {\n			// Extend the base object\n			for ( name in options ) {\n				src = target[ name ];\n				copy = options[ name ];\n\n				// Prevent never-ending loop\n				if ( target === copy ) {\n					continue;\n				}\n\n				// Recurse if we\'re merging plain objects or arrays\n				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n					if ( copyIsArray ) {\n						copyIsArray = false;\n						clone = src && jQuery.isArray(src) ? src : [];\n\n					} else {\n						clone = src && jQuery.isPlainObject(src) ? src : {};\n					}\n\n					// Never move original objects, clone them\n					target[ name ] = jQuery.extend( deep, clone, copy );\n\n				// Don\'t bring in undefined values\n				} else if ( copy !== undefined ) {\n					target[ name ] = copy;\n				}\n			}\n		}\n	}\n\n	// Return the modified object\n	return target;\n};\n\njQuery.extend({\n	// Unique for each copy of jQuery on the page\n	expando: "jQuery" + ( version + Math.random() ).replace( /\\D/g, "" ),\n\n	// Assume jQuery is ready without the ready module\n	isReady: true,\n\n	error: function( msg ) {\n		throw new Error( msg );\n	},\n\n	noop: function() {},\n\n	isFunction: function( obj ) {\n		return jQuery.type(obj) === "function";\n	},\n\n	isArray: Array.isArray,\n\n	isWindow: function( obj ) {\n		return obj != null && obj === obj.window;\n	},\n\n	isNumeric: function( obj ) {\n		// parseFloat NaNs numeric-cast false positives (null|true|false|"")\n		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")\n		// subtraction forces infinities to NaN\n		// adding 1 corrects loss of precision from parseFloat (#15100)\n		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;\n	},\n\n	isPlainObject: function( obj ) {\n		// Not plain objects:\n		// - Any object or value whose internal [[Class]] property is not "[object Object]"\n		// - DOM nodes\n		// - window\n		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {\n			return false;\n		}\n\n		if ( obj.constructor &&\n				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {\n			return false;\n		}\n\n		// If the function hasn\'t returned already, we\'re confident that\n		// |obj| is a plain object, created by {} or constructed with new Object\n		return true;\n	},\n\n	isEmptyObject: function( obj ) {\n		var name;\n		for ( name in obj ) {\n			return false;\n		}\n		return true;\n	},\n\n	type: function( obj ) {\n		if ( obj == null ) {\n			return obj + "";\n		}\n		// Support: Android<4.0, iOS<6 (functionish RegExp)\n		return typeof obj === "object" || typeof obj === "function" ?\n			class2type[ toString.call(obj) ] || "object" :\n			typeof obj;\n	},\n\n	// Evaluates a script in a global context\n	globalEval: function( code ) {\n		var script,\n			indirect = eval;\n\n		code = jQuery.trim( code );\n\n		if ( code ) {\n			// If the code includes a valid, prologue position\n			// strict mode pragma, execute code by injecting a\n			// script tag into the document.\n			if ( code.indexOf("use strict") === 1 ) {\n				script = document.createElement("script");\n				script.text = code;\n				document.head.appendChild( script ).parentNode.removeChild( script );\n			} else {\n			// Otherwise, avoid the DOM node creation, insertion\n			// and removal by using an indirect global eval\n				indirect( code );\n			}\n		}\n	},\n\n	// Convert dashed to camelCase; used by the css and data modules\n	// Support: IE9-11+\n	// Microsoft forgot to hump their vendor prefix (#9572)\n	camelCase: function( string ) {\n		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );\n	},\n\n	nodeName: function( elem, name ) {\n		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n	},\n\n	// args is for internal usage only\n	each: function( obj, callback, args ) {\n		var value,\n			i = 0,\n			length = obj.length,\n			isArray = isArraylike( obj );\n\n		if ( args ) {\n			if ( isArray ) {\n				for ( ; i < length; i++ ) {\n					value = callback.apply( obj[ i ], args );\n\n					if ( value === false ) {\n						break;\n					}\n				}\n			} else {\n				for ( i in obj ) {\n					value = callback.apply( obj[ i ], args );\n\n					if ( value === false ) {\n						break;\n					}\n				}\n			}\n\n		// A special, fast, case for the most common use of each\n		} else {\n			if ( isArray ) {\n				for ( ; i < length; i++ ) {\n					value = callback.call( obj[ i ], i, obj[ i ] );\n\n					if ( value === false ) {\n						break;\n					}\n				}\n			} else {\n				for ( i in obj ) {\n					value = callback.call( obj[ i ], i, obj[ i ] );\n\n					if ( value === false ) {\n						break;\n					}\n				}\n			}\n		}\n\n		return obj;\n	},\n\n	// Support: Android<4.1\n	trim: function( text ) {\n		return text == null ?\n			"" :\n			( text + "" ).replace( rtrim, "" );\n	},\n\n	// results is for internal usage only\n	makeArray: function( arr, results ) {\n		var ret = results || [];\n\n		if ( arr != null ) {\n			if ( isArraylike( Object(arr) ) ) {\n				jQuery.merge( ret,\n					typeof arr === "string" ?\n					[ arr ] : arr\n				);\n			} else {\n				push.call( ret, arr );\n			}\n		}\n\n		return ret;\n	},\n\n	inArray: function( elem, arr, i ) {\n		return arr == null ? -1 : indexOf.call( arr, elem, i );\n	},\n\n	merge: function( first, second ) {\n		var len = +second.length,\n			j = 0,\n			i = first.length;\n\n		for ( ; j < len; j++ ) {\n			first[ i++ ] = second[ j ];\n		}\n\n		first.length = i;\n\n		return first;\n	},\n\n	grep: function( elems, callback, invert ) {\n		var callbackInverse,\n			matches = [],\n			i = 0,\n			length = elems.length,\n			callbackExpect = !invert;\n\n		// Go through the array, only saving the items\n		// that pass the validator function\n		for ( ; i < length; i++ ) {\n			callbackInverse = !callback( elems[ i ], i );\n			if ( callbackInverse !== callbackExpect ) {\n				matches.push( elems[ i ] );\n			}\n		}\n\n		return matches;\n	},\n\n	// arg is for internal usage only\n	map: function( elems, callback, arg ) {\n		var value,\n			i = 0,\n			length = elems.length,\n			isArray = isArraylike( elems ),\n			ret = [];\n\n		// Go through the array, translating each of the items to their new values\n		if ( isArray ) {\n			for ( ; i < length; i++ ) {\n				value = callback( elems[ i ], i, arg );\n\n				if ( value != null ) {\n					ret.push( value );\n				}\n			}\n\n		// Go through every key on the object,\n		} else {\n			for ( i in elems ) {\n				value = callback( elems[ i ], i, arg );\n\n				if ( value != null ) {\n					ret.push( value );\n				}\n			}\n		}\n\n		// Flatten any nested arrays\n		return concat.apply( [], ret );\n	},\n\n	// A global GUID counter for objects\n	guid: 1,\n\n	// Bind a function to a context, optionally partially applying any\n	// arguments.\n	proxy: function( fn, context ) {\n		var tmp, args, proxy;\n\n		if ( typeof context === "string" ) {\n			tmp = fn[ context ];\n			context = fn;\n			fn = tmp;\n		}\n\n		// Quick check to determine if target is callable, in the spec\n		// this throws a TypeError, but we will just return undefined.\n		if ( !jQuery.isFunction( fn ) ) {\n			return undefined;\n		}\n\n		// Simulated bind\n		args = slice.call( arguments, 2 );\n		proxy = function() {\n			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n		};\n\n		// Set the guid of unique handler to the same of original handler, so it can be removed\n		proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n		return proxy;\n	},\n\n	now: Date.now,\n\n	// jQuery.support is not used in Core but other projects attach their\n	// properties to it so it needs to exist.\n	support: support\n});\n\n// Populate the class2type map\njQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {\n	class2type[ "[object " + name + "]" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\n	// Support: iOS 8.2 (not reproducible in simulator)\n	// `in` check used to prevent JIT error (gh-2145)\n	// hasOwn isn\'t used here due to false negatives\n	// regarding Nodelist length in IE\n	var length = "length" in obj && obj.length,\n		type = jQuery.type( obj );\n\n	if ( type === "function" || jQuery.isWindow( obj ) ) {\n		return false;\n	}\n\n	if ( obj.nodeType === 1 && length ) {\n		return true;\n	}\n\n	return type === "array" || length === 0 ||\n		typeof length === "number" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.0-pre\n * http://sizzlejs.com/\n *\n * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-16\n */\n(function( window ) {\n\nvar i,\n	support,\n	Expr,\n	getText,\n	isXML,\n	tokenize,\n	compile,\n	select,\n	outermostContext,\n	sortInput,\n	hasDuplicate,\n\n	// Local document vars\n	setDocument,\n	document,\n	docElem,\n	documentIsHTML,\n	rbuggyQSA,\n	rbuggyMatches,\n	matches,\n	contains,\n\n	// Instance-specific data\n	expando = "sizzle" + 1 * new Date(),\n	preferredDoc = window.document,\n	dirruns = 0,\n	done = 0,\n	classCache = createCache(),\n	tokenCache = createCache(),\n	compilerCache = createCache(),\n	sortOrder = function( a, b ) {\n		if ( a === b ) {\n			hasDuplicate = true;\n		}\n		return 0;\n	},\n\n	// General-purpose constants\n	MAX_NEGATIVE = 1 << 31,\n\n	// Instance methods\n	hasOwn = ({}).hasOwnProperty,\n	arr = [],\n	pop = arr.pop,\n	push_native = arr.push,\n	push = arr.push,\n	slice = arr.slice,\n	// Use a stripped-down indexOf as it\'s faster than native\n	// http://jsperf.com/thor-indexof-vs-for/5\n	indexOf = function( list, elem ) {\n		var i = 0,\n			len = list.length;\n		for ( ; i < len; i++ ) {\n			if ( list[i] === elem ) {\n				return i;\n			}\n		}\n		return -1;\n	},\n\n	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",\n\n	// Regular expressions\n\n	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n	whitespace = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n	// http://www.w3.org/TR/css3-syntax/#characters\n	characterEncoding = "(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+",\n\n	// Loosely modeled on CSS identifier characters\n	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n	identifier = characterEncoding.replace( "w", "w#" ),\n\n	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n	attributes = "\\\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +\n		// Operator (capture 2)\n		"*([*^$|!~]?=)" + whitespace +\n		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"\n		"*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(" + identifier + "))|)" + whitespace +\n		"*\\\\]",\n\n	pseudos = ":(" + characterEncoding + ")(?:\\\\((" +\n		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n		// 1. quoted (capture 3; capture 4 or capture 5)\n		"(\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|" +\n		// 2. simple (capture 6)\n		"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + attributes + ")*)|" +\n		// 3. anything else (capture 2)\n		".*" +\n		")\\\\)|)",\n\n	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n	rwhitespace = new RegExp( whitespace + "+", "g" ),\n	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + whitespace + "+$", "g" ),\n\n	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),\n	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),\n\n	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\\\]\'\\"]*?)" + whitespace + "*\\\\]", "g" ),\n\n	rpseudo = new RegExp( pseudos ),\n	ridentifier = new RegExp( "^" + identifier + "$" ),\n\n	matchExpr = {\n		"ID": new RegExp( "^#(" + characterEncoding + ")" ),\n		"CLASS": new RegExp( "^\\\\.(" + characterEncoding + ")" ),\n		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),\n		"ATTR": new RegExp( "^" + attributes ),\n		"PSEUDO": new RegExp( "^" + pseudos ),\n		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + whitespace +\n			"*(even|odd|(([+-]|)(\\\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +\n			"*(\\\\d+)|))" + whitespace + "*\\\\)|)", "i" ),\n		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),\n		// For use in libraries implementing .is()\n		// We use this for POS matching in `select`\n		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" +\n			whitespace + "*((?:-\\\\d)?\\\\d*)" + whitespace + "*\\\\)|)(?=[^-]|$)", "i" )\n	},\n\n	rinputs = /^(?:input|select|textarea|button)$/i,\n	rheader = /^h\\d$/i,\n\n	rnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n	// Easily-parseable/retrievable ID or TAG or CLASS selectors\n	rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n	rsibling = /[+~]/,\n	rescape = /\'|\\\\/g,\n\n	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n	runescape = new RegExp( "\\\\\\\\([\\\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),\n	funescape = function( _, escaped, escapedWhitespace ) {\n		var high = "0x" + escaped - 0x10000;\n		// NaN means non-codepoint\n		// Support: Firefox<24\n		// Workaround erroneous numeric interpretation of +"0x"\n		return high !== high || escapedWhitespace ?\n			escaped :\n			high < 0 ?\n				// BMP codepoint\n				String.fromCharCode( high + 0x10000 ) :\n				// Supplemental Plane codepoint (surrogate pair)\n				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n	},\n\n	// Used for iframes\n	// See setDocument()\n	// Removing the function wrapper causes a "Permission Denied"\n	// error in IE\n	unloadHandler = function() {\n		setDocument();\n	};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n	push.apply(\n		(arr = slice.call( preferredDoc.childNodes )),\n		preferredDoc.childNodes\n	);\n	// Support: Android<4.0\n	// Detect silently failing push.apply\n	arr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n	push = { apply: arr.length ?\n\n		// Leverage slice if possible\n		function( target, els ) {\n			push_native.apply( target, slice.call(els) );\n		} :\n\n		// Support: IE<9\n		// Otherwise append directly\n		function( target, els ) {\n			var j = target.length,\n				i = 0;\n			// Can\'t trust NodeList.length\n			while ( (target[j++] = els[i++]) ) {}\n			target.length = j - 1;\n		}\n	};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n	var match, elem, m, nodeType,\n		// QSA vars\n		i, groups, old, nid, newContext, newSelector;\n\n	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n		setDocument( context );\n	}\n\n	context = context || document;\n	results = results || [];\n	nodeType = context.nodeType;\n\n	if ( typeof selector !== "string" || !selector ||\n		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n		return results;\n	}\n\n	if ( !seed && documentIsHTML ) {\n\n		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)\n		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n			// Speed-up: Sizzle("#ID")\n			if ( (m = match[1]) ) {\n				if ( nodeType === 9 ) {\n					elem = context.getElementById( m );\n					// Check parentNode to catch when Blackberry 4.6 returns\n					// nodes that are no longer in the document (jQuery #6963)\n					if ( elem && elem.parentNode ) {\n						// Handle the case where IE, Opera, and Webkit return items\n						// by name instead of ID\n						if ( elem.id === m ) {\n							results.push( elem );\n							return results;\n						}\n					} else {\n						return results;\n					}\n				} else {\n					// Context is not a document\n					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n						contains( context, elem ) && elem.id === m ) {\n						results.push( elem );\n						return results;\n					}\n				}\n\n			// Speed-up: Sizzle("TAG")\n			} else if ( match[2] ) {\n				push.apply( results, context.getElementsByTagName( selector ) );\n				return results;\n\n			// Speed-up: Sizzle(".CLASS")\n			} else if ( (m = match[3]) && support.getElementsByClassName ) {\n				push.apply( results, context.getElementsByClassName( m ) );\n				return results;\n			}\n		}\n\n		// QSA path\n		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n			nid = old = expando;\n			newContext = context;\n			newSelector = nodeType !== 1 && selector;\n\n			// qSA works strangely on Element-rooted queries\n			// We can work around this by specifying an extra ID on the root\n			// and working up from there (Thanks to Andrew Dupont for the technique)\n			// IE 8 doesn\'t work on object elements\n			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {\n				groups = tokenize( selector );\n\n				if ( (old = context.getAttribute("id")) ) {\n					nid = old.replace( rescape, "\\\\$&" );\n				} else {\n					context.setAttribute( "id", nid );\n				}\n				nid = "[id=\'" + nid + "\'] ";\n\n				i = groups.length;\n				while ( i-- ) {\n					groups[i] = nid + toSelector( groups[i] );\n				}\n				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n				newSelector = groups.join(",");\n			}\n\n			if ( newSelector ) {\n				try {\n					push.apply( results,\n						newContext.querySelectorAll( newSelector )\n					);\n					return results;\n				} catch(qsaError) {\n				} finally {\n					if ( !old ) {\n						context.removeAttribute("id");\n					}\n				}\n			}\n		}\n	}\n\n	// All others\n	return select( selector.replace( rtrim, "$1" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *	deleting the oldest entry\n */\nfunction createCache() {\n	var keys = [];\n\n	function cache( key, value ) {\n		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)\n		if ( keys.push( key + " " ) > Expr.cacheLength ) {\n			// Only keep the most recent entries\n			delete cache[ keys.shift() ];\n		}\n		return (cache[ key + " " ] = value);\n	}\n	return cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n	fn[ expando ] = true;\n	return fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n	var div = document.createElement("div");\n\n	try {\n		return !!fn( div );\n	} catch (e) {\n		return false;\n	} finally {\n		// Remove from its parent by default\n		if ( div.parentNode ) {\n			div.parentNode.removeChild( div );\n		}\n		// release memory in IE\n		div = null;\n	}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n	var arr = attrs.split("|"),\n		i = attrs.length;\n\n	while ( i-- ) {\n		Expr.attrHandle[ arr[i] ] = handler;\n	}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n	var cur = b && a,\n		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n			( ~b.sourceIndex || MAX_NEGATIVE ) -\n			( ~a.sourceIndex || MAX_NEGATIVE );\n\n	// Use IE sourceIndex if available on both nodes\n	if ( diff ) {\n		return diff;\n	}\n\n	// Check if b follows a\n	if ( cur ) {\n		while ( (cur = cur.nextSibling) ) {\n			if ( cur === b ) {\n				return -1;\n			}\n		}\n	}\n\n	return a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n	return function( elem ) {\n		var name = elem.nodeName.toLowerCase();\n		return name === "input" && elem.type === type;\n	};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n	return function( elem ) {\n		var name = elem.nodeName.toLowerCase();\n		return (name === "input" || name === "button") && elem.type === type;\n	};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n	return markFunction(function( argument ) {\n		argument = +argument;\n		return markFunction(function( seed, matches ) {\n			var j,\n				matchIndexes = fn( [], seed.length, argument ),\n				i = matchIndexes.length;\n\n			// Match elements found at the specified indexes\n			while ( i-- ) {\n				if ( seed[ (j = matchIndexes[i]) ] ) {\n					seed[j] = !(matches[j] = seed[j]);\n				}\n			}\n		});\n	});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n	return context && typeof context.getElementsByTagName !== "undefined" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n	// documentElement is verified for cases where it doesn\'t yet exist\n	// (such as loading iframes in IE - #4833)\n	var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n	return documentElement ? documentElement.nodeName !== "HTML" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n	var hasCompare, parent,\n		doc = node ? node.ownerDocument || node : preferredDoc;\n\n	// If no document and documentElement is available, return\n	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n		return document;\n	}\n\n	// Set our document\n	document = doc;\n	docElem = doc.documentElement;\n	parent = doc.defaultView;\n\n	// Support: IE>8\n	// If iframe document is assigned to "document" variable and if iframe has been reloaded,\n	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936\n	// IE6-8 do not support the defaultView property so parent will be undefined\n	if ( parent && parent !== parent.top ) {\n		// IE11 does not have attachEvent, so all must suffer\n		if ( parent.addEventListener ) {\n			parent.addEventListener( "unload", unloadHandler, false );\n		} else if ( parent.attachEvent ) {\n			parent.attachEvent( "onunload", unloadHandler );\n		}\n	}\n\n	/* Support tests\n	---------------------------------------------------------------------- */\n	documentIsHTML = !isXML( doc );\n\n	/* Attributes\n	---------------------------------------------------------------------- */\n\n	// Support: IE<8\n	// Verify that getAttribute really returns attributes and not properties\n	// (excepting IE8 booleans)\n	support.attributes = assert(function( div ) {\n		div.className = "i";\n		return !div.getAttribute("className");\n	});\n\n	/* getElement(s)By*\n	---------------------------------------------------------------------- */\n\n	// Check if getElementsByTagName("*") returns only elements\n	support.getElementsByTagName = assert(function( div ) {\n		div.appendChild( doc.createComment("") );\n		return !div.getElementsByTagName("*").length;\n	});\n\n	// Support: IE<9\n	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );\n\n	// Support: IE<10\n	// Check if getElementById returns elements by name\n	// The broken getElementById methods don\'t pick up programatically-set names,\n	// so use a roundabout getElementsByName test\n	support.getById = assert(function( div ) {\n		docElem.appendChild( div ).id = expando;\n		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n	});\n\n	// ID find and filter\n	if ( support.getById ) {\n		Expr.find["ID"] = function( id, context ) {\n			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\n				var m = context.getElementById( id );\n				// Check parentNode to catch when Blackberry 4.6 returns\n				// nodes that are no longer in the document #6963\n				return m && m.parentNode ? [ m ] : [];\n			}\n		};\n		Expr.filter["ID"] = function( id ) {\n			var attrId = id.replace( runescape, funescape );\n			return function( elem ) {\n				return elem.getAttribute("id") === attrId;\n			};\n		};\n	} else {\n		// Support: IE6/7\n		// getElementById is not reliable as a find shortcut\n		delete Expr.find["ID"];\n\n		Expr.filter["ID"] =  function( id ) {\n			var attrId = id.replace( runescape, funescape );\n			return function( elem ) {\n				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");\n				return node && node.value === attrId;\n			};\n		};\n	}\n\n	// Tag\n	Expr.find["TAG"] = support.getElementsByTagName ?\n		function( tag, context ) {\n			if ( typeof context.getElementsByTagName !== "undefined" ) {\n				return context.getElementsByTagName( tag );\n\n			// DocumentFragment nodes don\'t have gEBTN\n			} else if ( support.qsa ) {\n				return context.querySelectorAll( tag );\n			}\n		} :\n\n		function( tag, context ) {\n			var elem,\n				tmp = [],\n				i = 0,\n				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n				results = context.getElementsByTagName( tag );\n\n			// Filter out possible comments\n			if ( tag === "*" ) {\n				while ( (elem = results[i++]) ) {\n					if ( elem.nodeType === 1 ) {\n						tmp.push( elem );\n					}\n				}\n\n				return tmp;\n			}\n			return results;\n		};\n\n	// Class\n	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {\n		if ( documentIsHTML ) {\n			return context.getElementsByClassName( className );\n		}\n	};\n\n	/* QSA/matchesSelector\n	---------------------------------------------------------------------- */\n\n	// QSA and matchesSelector support\n\n	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n	rbuggyMatches = [];\n\n	// qSa(:focus) reports false when true (Chrome 21)\n	// We allow this because of a bug in IE8/9 that throws an error\n	// whenever `document.activeElement` is accessed on an iframe\n	// So, we allow :focus to pass through QSA all the time to avoid the IE error\n	// See http://bugs.jquery.com/ticket/13378\n	rbuggyQSA = [];\n\n	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n		// Build QSA regex\n		// Regex strategy adopted from Diego Perini\n		assert(function( div ) {\n			// Select is set to empty string on purpose\n			// This is to test IE\'s treatment of not explicitly\n			// setting a boolean content attribute,\n			// since its presence should be enough\n			// http://bugs.jquery.com/ticket/12359\n			docElem.appendChild( div ).innerHTML = "<a id=\'" + expando + "\'></a>" +\n				"<select id=\'" + expando + "-\\f]\' msallowcapture=\'\'>" +\n				"<option selected=\'\'></option></select>";\n\n			// Support: IE8, Opera 11-12.16\n			// Nothing should be selected when empty strings follow ^= or $= or *=\n			// The test attribute must be unknown in Opera but "safe" for WinRT\n			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n			if ( div.querySelectorAll("[msallowcapture^=\'\']").length ) {\n				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\'\'|\\"\\")" );\n			}\n\n			// Support: IE8\n			// Boolean attributes and "value" are not treated correctly\n			if ( !div.querySelectorAll("[selected]").length ) {\n				rbuggyQSA.push( "\\\\[" + whitespace + "*(?:value|" + booleans + ")" );\n			}\n\n			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+\n			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {\n				rbuggyQSA.push("~=");\n			}\n\n			// Webkit/Opera - :checked should return selected option elements\n			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n			// IE8 throws error here and will not see later tests\n			if ( !div.querySelectorAll(":checked").length ) {\n				rbuggyQSA.push(":checked");\n			}\n\n			// Support: Safari 8+, iOS 8+\n			// https://bugs.webkit.org/show_bug.cgi?id=136851\n			// In-page `selector#id sibing-combinator selector` fails\n			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {\n				rbuggyQSA.push(".#.+[+~]");\n			}\n		});\n\n		assert(function( div ) {\n			// Support: Windows 8 Native Apps\n			// The type and name attributes are restricted during .innerHTML assignment\n			var input = doc.createElement("input");\n			input.setAttribute( "type", "hidden" );\n			div.appendChild( input ).setAttribute( "name", "D" );\n\n			// Support: IE8\n			// Enforce case-sensitivity of name attribute\n			if ( div.querySelectorAll("[name=d]").length ) {\n				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );\n			}\n\n			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n			// IE8 throws error here and will not see later tests\n			if ( !div.querySelectorAll(":enabled").length ) {\n				rbuggyQSA.push( ":enabled", ":disabled" );\n			}\n\n			// Opera 10-11 does not throw on post-comma invalid pseudos\n			div.querySelectorAll("*,:x");\n			rbuggyQSA.push(",.*:");\n		});\n	}\n\n	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n		docElem.webkitMatchesSelector ||\n		docElem.mozMatchesSelector ||\n		docElem.oMatchesSelector ||\n		docElem.msMatchesSelector) )) ) {\n\n		assert(function( div ) {\n			// Check to see if it\'s possible to do matchesSelector\n			// on a disconnected node (IE 9)\n			support.disconnectedMatch = matches.call( div, "div" );\n\n			// This should fail with an exception\n			// Gecko does not error, returns false instead\n			matches.call( div, "[s!=\'\']:x" );\n			rbuggyMatches.push( "!=", pseudos );\n		});\n	}\n\n	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );\n	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );\n\n	/* Contains\n	---------------------------------------------------------------------- */\n	hasCompare = rnative.test( docElem.compareDocumentPosition );\n\n	// Element contains another\n	// Purposefully does not implement inclusive descendent\n	// As in, an element does not contain itself\n	contains = hasCompare || rnative.test( docElem.contains ) ?\n		function( a, b ) {\n			var adown = a.nodeType === 9 ? a.documentElement : a,\n				bup = b && b.parentNode;\n			return a === bup || !!( bup && bup.nodeType === 1 && (\n				adown.contains ?\n					adown.contains( bup ) :\n					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n			));\n		} :\n		function( a, b ) {\n			if ( b ) {\n				while ( (b = b.parentNode) ) {\n					if ( b === a ) {\n						return true;\n					}\n				}\n			}\n			return false;\n		};\n\n	/* Sorting\n	---------------------------------------------------------------------- */\n\n	// Document order sorting\n	sortOrder = hasCompare ?\n	function( a, b ) {\n\n		// Flag for duplicate removal\n		if ( a === b ) {\n			hasDuplicate = true;\n			return 0;\n		}\n\n		// Sort on method existence if only one input has compareDocumentPosition\n		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n		if ( compare ) {\n			return compare;\n		}\n\n		// Calculate position if both inputs belong to the same document\n		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n			a.compareDocumentPosition( b ) :\n\n			// Otherwise we know they are disconnected\n			1;\n\n		// Disconnected nodes\n		if ( compare & 1 ||\n			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n			// Choose the first element that is related to our preferred document\n			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n				return -1;\n			}\n			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n				return 1;\n			}\n\n			// Maintain original order\n			return sortInput ?\n				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n				0;\n		}\n\n		return compare & 4 ? -1 : 1;\n	} :\n	function( a, b ) {\n		// Exit early if the nodes are identical\n		if ( a === b ) {\n			hasDuplicate = true;\n			return 0;\n		}\n\n		var cur,\n			i = 0,\n			aup = a.parentNode,\n			bup = b.parentNode,\n			ap = [ a ],\n			bp = [ b ];\n\n		// Parentless nodes are either documents or disconnected\n		if ( !aup || !bup ) {\n			return a === doc ? -1 :\n				b === doc ? 1 :\n				aup ? -1 :\n				bup ? 1 :\n				sortInput ?\n				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n				0;\n\n		// If the nodes are siblings, we can do a quick check\n		} else if ( aup === bup ) {\n			return siblingCheck( a, b );\n		}\n\n		// Otherwise we need full lists of their ancestors for comparison\n		cur = a;\n		while ( (cur = cur.parentNode) ) {\n			ap.unshift( cur );\n		}\n		cur = b;\n		while ( (cur = cur.parentNode) ) {\n			bp.unshift( cur );\n		}\n\n		// Walk down the tree looking for a discrepancy\n		while ( ap[i] === bp[i] ) {\n			i++;\n		}\n\n		return i ?\n			// Do a sibling check if the nodes have a common ancestor\n			siblingCheck( ap[i], bp[i] ) :\n\n			// Otherwise nodes in our document sort first\n			ap[i] === preferredDoc ? -1 :\n			bp[i] === preferredDoc ? 1 :\n			0;\n	};\n\n	return doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n	return Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n	// Set document vars if needed\n	if ( ( elem.ownerDocument || elem ) !== document ) {\n		setDocument( elem );\n	}\n\n	// Make sure that attribute selectors are quoted\n	expr = expr.replace( rattributeQuotes, "=\'$1\']" );\n\n	if ( support.matchesSelector && documentIsHTML &&\n		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n		try {\n			var ret = matches.call( elem, expr );\n\n			// IE 9\'s matchesSelector returns false on disconnected nodes\n			if ( ret || support.disconnectedMatch ||\n					// As well, disconnected nodes are said to be in a document\n					// fragment in IE 9\n					elem.document && elem.document.nodeType !== 11 ) {\n				return ret;\n			}\n		} catch (e) {}\n	}\n\n	return Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n	// Set document vars if needed\n	if ( ( context.ownerDocument || context ) !== document ) {\n		setDocument( context );\n	}\n	return contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n	// Set document vars if needed\n	if ( ( elem.ownerDocument || elem ) !== document ) {\n		setDocument( elem );\n	}\n\n	var fn = Expr.attrHandle[ name.toLowerCase() ],\n		// Don\'t get fooled by Object.prototype properties (jQuery #13807)\n		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n			fn( elem, name, !documentIsHTML ) :\n			undefined;\n\n	return val !== undefined ?\n		val :\n		support.attributes || !documentIsHTML ?\n			elem.getAttribute( name ) :\n			(val = elem.getAttributeNode(name)) && val.specified ?\n				val.value :\n				null;\n};\n\nSizzle.error = function( msg ) {\n	throw new Error( "Syntax error, unrecognized expression: " + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n	var elem,\n		duplicates = [],\n		j = 0,\n		i = 0;\n\n	// Unless we *know* we can detect duplicates, assume their presence\n	hasDuplicate = !support.detectDuplicates;\n	sortInput = !support.sortStable && results.slice( 0 );\n	results.sort( sortOrder );\n\n	if ( hasDuplicate ) {\n		while ( (elem = results[i++]) ) {\n			if ( elem === results[ i ] ) {\n				j = duplicates.push( i );\n			}\n		}\n		while ( j-- ) {\n			results.splice( duplicates[ j ], 1 );\n		}\n	}\n\n	// Clear input after sorting to release objects\n	// See https://github.com/jquery/sizzle/pull/225\n	sortInput = null;\n\n	return results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n	var node,\n		ret = "",\n		i = 0,\n		nodeType = elem.nodeType;\n\n	if ( !nodeType ) {\n		// If no nodeType, this is expected to be an array\n		while ( (node = elem[i++]) ) {\n			// Do not traverse comment nodes\n			ret += getText( node );\n		}\n	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n		// Use textContent for elements\n		// innerText usage removed for consistency of new lines (jQuery #11153)\n		if ( typeof elem.textContent === "string" ) {\n			return elem.textContent;\n		} else {\n			// Traverse its children\n			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n				ret += getText( elem );\n			}\n		}\n	} else if ( nodeType === 3 || nodeType === 4 ) {\n		return elem.nodeValue;\n	}\n	// Do not include comment or processing instruction nodes\n\n	return ret;\n};\n\nExpr = Sizzle.selectors = {\n\n	// Can be adjusted by the user\n	cacheLength: 50,\n\n	createPseudo: markFunction,\n\n	match: matchExpr,\n\n	attrHandle: {},\n\n	find: {},\n\n	relative: {\n		">": { dir: "parentNode", first: true },\n		" ": { dir: "parentNode" },\n		"+": { dir: "previousSibling", first: true },\n		"~": { dir: "previousSibling" }\n	},\n\n	preFilter: {\n		"ATTR": function( match ) {\n			match[1] = match[1].replace( runescape, funescape );\n\n			// Move the given value to match[3] whether quoted or unquoted\n			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );\n\n			if ( match[2] === "~=" ) {\n				match[3] = " " + match[3] + " ";\n			}\n\n			return match.slice( 0, 4 );\n		},\n\n		"CHILD": function( match ) {\n			/* matches from matchExpr["CHILD"]\n				1 type (only|nth|...)\n				2 what (child|of-type)\n				3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n				4 xn-component of xn+y argument ([+-]?\\d*n|)\n				5 sign of xn-component\n				6 x of xn-component\n				7 sign of y-component\n				8 y of y-component\n			*/\n			match[1] = match[1].toLowerCase();\n\n			if ( match[1].slice( 0, 3 ) === "nth" ) {\n				// nth-* requires argument\n				if ( !match[3] ) {\n					Sizzle.error( match[0] );\n				}\n\n				// numeric x and y parameters for Expr.filter.CHILD\n				// remember that false/true cast respectively to 0/1\n				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );\n				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );\n\n			// other types prohibit arguments\n			} else if ( match[3] ) {\n				Sizzle.error( match[0] );\n			}\n\n			return match;\n		},\n\n		"PSEUDO": function( match ) {\n			var excess,\n				unquoted = !match[6] && match[2];\n\n			if ( matchExpr["CHILD"].test( match[0] ) ) {\n				return null;\n			}\n\n			// Accept quoted arguments as-is\n			if ( match[3] ) {\n				match[2] = match[4] || match[5] || "";\n\n			// Strip excess characters from unquoted arguments\n			} else if ( unquoted && rpseudo.test( unquoted ) &&\n				// Get excess from tokenize (recursively)\n				(excess = tokenize( unquoted, true )) &&\n				// advance to the next closing parenthesis\n				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {\n\n				// excess is a negative index\n				match[0] = match[0].slice( 0, excess );\n				match[2] = unquoted.slice( 0, excess );\n			}\n\n			// Return only captures needed by the pseudo filter method (type and argument)\n			return match.slice( 0, 3 );\n		}\n	},\n\n	filter: {\n\n		"TAG": function( nodeNameSelector ) {\n			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n			return nodeNameSelector === "*" ?\n				function() { return true; } :\n				function( elem ) {\n					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n				};\n		},\n\n		"CLASS": function( className ) {\n			var pattern = classCache[ className + " " ];\n\n			return pattern ||\n				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&\n				classCache( className, function( elem ) {\n					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );\n				});\n		},\n\n		"ATTR": function( name, operator, check ) {\n			return function( elem ) {\n				var result = Sizzle.attr( elem, name );\n\n				if ( result == null ) {\n					return operator === "!=";\n				}\n				if ( !operator ) {\n					return true;\n				}\n\n				result += "";\n\n				return operator === "=" ? result === check :\n					operator === "!=" ? result !== check :\n					operator === "^=" ? check && result.indexOf( check ) === 0 :\n					operator === "*=" ? check && result.indexOf( check ) > -1 :\n					operator === "$=" ? check && result.slice( -check.length ) === check :\n					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :\n					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :\n					false;\n			};\n		},\n\n		"CHILD": function( type, what, argument, first, last ) {\n			var simple = type.slice( 0, 3 ) !== "nth",\n				forward = type.slice( -4 ) !== "last",\n				ofType = what === "of-type";\n\n			return first === 1 && last === 0 ?\n\n				// Shortcut for :nth-*(n)\n				function( elem ) {\n					return !!elem.parentNode;\n				} :\n\n				function( elem, context, xml ) {\n					var cache, outerCache, node, diff, nodeIndex, start,\n						dir = simple !== forward ? "nextSibling" : "previousSibling",\n						parent = elem.parentNode,\n						name = ofType && elem.nodeName.toLowerCase(),\n						useCache = !xml && !ofType;\n\n					if ( parent ) {\n\n						// :(first|last|only)-(child|of-type)\n						if ( simple ) {\n							while ( dir ) {\n								node = elem;\n								while ( (node = node[ dir ]) ) {\n									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n										return false;\n									}\n								}\n								// Reverse direction for :only-* (if we haven\'t yet done so)\n								start = dir = type === "only" && !start && "nextSibling";\n							}\n							return true;\n						}\n\n						start = [ forward ? parent.firstChild : parent.lastChild ];\n\n						// non-xml :nth-child(...) stores cache data on `parent`\n						if ( forward && useCache ) {\n							// Seek `elem` from a previously-cached index\n							outerCache = parent[ expando ] || (parent[ expando ] = {});\n							cache = outerCache[ type ] || [];\n							nodeIndex = cache[0] === dirruns && cache[1];\n							diff = cache[0] === dirruns && cache[2];\n							node = nodeIndex && parent.childNodes[ nodeIndex ];\n\n							while ( (node = ++nodeIndex && node && node[ dir ] ||\n\n								// Fallback to seeking `elem` from the start\n								(diff = nodeIndex = 0) || start.pop()) ) {\n\n								// When found, cache indexes on `parent` and break\n								if ( node.nodeType === 1 && ++diff && node === elem ) {\n									outerCache[ type ] = [ dirruns, nodeIndex, diff ];\n									break;\n								}\n							}\n\n						// Use previously-cached element index if available\n						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n							diff = cache[1];\n\n						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n						} else {\n							// Use the same loop as above to seek `elem` from the start\n							while ( (node = ++nodeIndex && node && node[ dir ] ||\n								(diff = nodeIndex = 0) || start.pop()) ) {\n\n								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n									// Cache the index of each encountered element\n									if ( useCache ) {\n										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n									}\n\n									if ( node === elem ) {\n										break;\n									}\n								}\n							}\n						}\n\n						// Incorporate the offset, then check against cycle size\n						diff -= last;\n						return diff === first || ( diff % first === 0 && diff / first >= 0 );\n					}\n				};\n		},\n\n		"PSEUDO": function( pseudo, argument ) {\n			// pseudo-class names are case-insensitive\n			// http://www.w3.org/TR/selectors/#pseudo-classes\n			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n			// Remember that setFilters inherits from pseudos\n			var args,\n				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n					Sizzle.error( "unsupported pseudo: " + pseudo );\n\n			// The user may use createPseudo to indicate that\n			// arguments are needed to create the filter function\n			// just as Sizzle does\n			if ( fn[ expando ] ) {\n				return fn( argument );\n			}\n\n			// But maintain support for old signatures\n			if ( fn.length > 1 ) {\n				args = [ pseudo, pseudo, "", argument ];\n				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n					markFunction(function( seed, matches ) {\n						var idx,\n							matched = fn( seed, argument ),\n							i = matched.length;\n						while ( i-- ) {\n							idx = indexOf( seed, matched[i] );\n							seed[ idx ] = !( matches[ idx ] = matched[i] );\n						}\n					}) :\n					function( elem ) {\n						return fn( elem, 0, args );\n					};\n			}\n\n			return fn;\n		}\n	},\n\n	pseudos: {\n		// Potentially complex pseudos\n		"not": markFunction(function( selector ) {\n			// Trim the selector passed to compile\n			// to avoid treating leading and trailing\n			// spaces as combinators\n			var input = [],\n				results = [],\n				matcher = compile( selector.replace( rtrim, "$1" ) );\n\n			return matcher[ expando ] ?\n				markFunction(function( seed, matches, context, xml ) {\n					var elem,\n						unmatched = matcher( seed, null, xml, [] ),\n						i = seed.length;\n\n					// Match elements unmatched by `matcher`\n					while ( i-- ) {\n						if ( (elem = unmatched[i]) ) {\n							seed[i] = !(matches[i] = elem);\n						}\n					}\n				}) :\n				function( elem, context, xml ) {\n					input[0] = elem;\n					matcher( input, null, xml, results );\n					// Don\'t keep the element (issue #299)\n					input[0] = null;\n					return !results.pop();\n				};\n		}),\n\n		"has": markFunction(function( selector ) {\n			return function( elem ) {\n				return Sizzle( selector, elem ).length > 0;\n			};\n		}),\n\n		"contains": markFunction(function( text ) {\n			text = text.replace( runescape, funescape );\n			return function( elem ) {\n				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n			};\n		}),\n\n		// "Whether an element is represented by a :lang() selector\n		// is based solely on the element\'s language value\n		// being equal to the identifier C,\n		// or beginning with the identifier C immediately followed by "-".\n		// The matching of C against the element\'s language value is performed case-insensitively.\n		// The identifier C does not have to be a valid language name."\n		// http://www.w3.org/TR/selectors/#lang-pseudo\n		"lang": markFunction( function( lang ) {\n			// lang value must be a valid identifier\n			if ( !ridentifier.test(lang || "") ) {\n				Sizzle.error( "unsupported lang: " + lang );\n			}\n			lang = lang.replace( runescape, funescape ).toLowerCase();\n			return function( elem ) {\n				var elemLang;\n				do {\n					if ( (elemLang = documentIsHTML ?\n						elem.lang :\n						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {\n\n						elemLang = elemLang.toLowerCase();\n						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;\n					}\n				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n				return false;\n			};\n		}),\n\n		// Miscellaneous\n		"target": function( elem ) {\n			var hash = window.location && window.location.hash;\n			return hash && hash.slice( 1 ) === elem.id;\n		},\n\n		"root": function( elem ) {\n			return elem === docElem;\n		},\n\n		"focus": function( elem ) {\n			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n		},\n\n		// Boolean properties\n		"enabled": function( elem ) {\n			return elem.disabled === false;\n		},\n\n		"disabled": function( elem ) {\n			return elem.disabled === true;\n		},\n\n		"checked": function( elem ) {\n			// In CSS3, :checked should return both checked and selected elements\n			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n			var nodeName = elem.nodeName.toLowerCase();\n			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);\n		},\n\n		"selected": function( elem ) {\n			// Accessing this property makes selected-by-default\n			// options in Safari work properly\n			if ( elem.parentNode ) {\n				elem.parentNode.selectedIndex;\n			}\n\n			return elem.selected === true;\n		},\n\n		// Contents\n		"empty": function( elem ) {\n			// http://www.w3.org/TR/selectors/#empty-pseudo\n			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n			//   but not by others (comment: 8; processing instruction: 7; etc.)\n			// nodeType < 6 works because attributes (2) do not appear as children\n			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n				if ( elem.nodeType < 6 ) {\n					return false;\n				}\n			}\n			return true;\n		},\n\n		"parent": function( elem ) {\n			return !Expr.pseudos["empty"]( elem );\n		},\n\n		// Element/input types\n		"header": function( elem ) {\n			return rheader.test( elem.nodeName );\n		},\n\n		"input": function( elem ) {\n			return rinputs.test( elem.nodeName );\n		},\n\n		"button": function( elem ) {\n			var name = elem.nodeName.toLowerCase();\n			return name === "input" && elem.type === "button" || name === "button";\n		},\n\n		"text": function( elem ) {\n			var attr;\n			return elem.nodeName.toLowerCase() === "input" &&\n				elem.type === "text" &&\n\n				// Support: IE<8\n				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"\n				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );\n		},\n\n		// Position-in-collection\n		"first": createPositionalPseudo(function() {\n			return [ 0 ];\n		}),\n\n		"last": createPositionalPseudo(function( matchIndexes, length ) {\n			return [ length - 1 ];\n		}),\n\n		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {\n			return [ argument < 0 ? argument + length : argument ];\n		}),\n\n		"even": createPositionalPseudo(function( matchIndexes, length ) {\n			var i = 0;\n			for ( ; i < length; i += 2 ) {\n				matchIndexes.push( i );\n			}\n			return matchIndexes;\n		}),\n\n		"odd": createPositionalPseudo(function( matchIndexes, length ) {\n			var i = 1;\n			for ( ; i < length; i += 2 ) {\n				matchIndexes.push( i );\n			}\n			return matchIndexes;\n		}),\n\n		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n			var i = argument < 0 ? argument + length : argument;\n			for ( ; --i >= 0; ) {\n				matchIndexes.push( i );\n			}\n			return matchIndexes;\n		}),\n\n		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n			var i = argument < 0 ? argument + length : argument;\n			for ( ; ++i < length; ) {\n				matchIndexes.push( i );\n			}\n			return matchIndexes;\n		})\n	}\n};\n\nExpr.pseudos["nth"] = Expr.pseudos["eq"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n	Expr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n	Expr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n	var matched, match, tokens, type,\n		soFar, groups, preFilters,\n		cached = tokenCache[ selector + " " ];\n\n	if ( cached ) {\n		return parseOnly ? 0 : cached.slice( 0 );\n	}\n\n	soFar = selector;\n	groups = [];\n	preFilters = Expr.preFilter;\n\n	while ( soFar ) {\n\n		// Comma and first run\n		if ( !matched || (match = rcomma.exec( soFar )) ) {\n			if ( match ) {\n				// Don\'t consume trailing commas as valid\n				soFar = soFar.slice( match[0].length ) || soFar;\n			}\n			groups.push( (tokens = []) );\n		}\n\n		matched = false;\n\n		// Combinators\n		if ( (match = rcombinators.exec( soFar )) ) {\n			matched = match.shift();\n			tokens.push({\n				value: matched,\n				// Cast descendant combinators to space\n				type: match[0].replace( rtrim, " " )\n			});\n			soFar = soFar.slice( matched.length );\n		}\n\n		// Filters\n		for ( type in Expr.filter ) {\n			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n				(match = preFilters[ type ]( match ))) ) {\n				matched = match.shift();\n				tokens.push({\n					value: matched,\n					type: type,\n					matches: match\n				});\n				soFar = soFar.slice( matched.length );\n			}\n		}\n\n		if ( !matched ) {\n			break;\n		}\n	}\n\n	// Return the length of the invalid excess\n	// if we\'re just parsing\n	// Otherwise, throw an error or return tokens\n	return parseOnly ?\n		soFar.length :\n		soFar ?\n			Sizzle.error( selector ) :\n			// Cache the tokens\n			tokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n	var i = 0,\n		len = tokens.length,\n		selector = "";\n	for ( ; i < len; i++ ) {\n		selector += tokens[i].value;\n	}\n	return selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n	var dir = combinator.dir,\n		checkNonElements = base && dir === "parentNode",\n		doneName = done++;\n\n	return combinator.first ?\n		// Check against closest ancestor/preceding element\n		function( elem, context, xml ) {\n			while ( (elem = elem[ dir ]) ) {\n				if ( elem.nodeType === 1 || checkNonElements ) {\n					return matcher( elem, context, xml );\n				}\n			}\n		} :\n\n		// Check against all ancestor/preceding elements\n		function( elem, context, xml ) {\n			var oldCache, outerCache,\n				newCache = [ dirruns, doneName ];\n\n			// We can\'t set arbitrary data on XML nodes, so they don\'t benefit from dir caching\n			if ( xml ) {\n				while ( (elem = elem[ dir ]) ) {\n					if ( elem.nodeType === 1 || checkNonElements ) {\n						if ( matcher( elem, context, xml ) ) {\n							return true;\n						}\n					}\n				}\n			} else {\n				while ( (elem = elem[ dir ]) ) {\n					if ( elem.nodeType === 1 || checkNonElements ) {\n						outerCache = elem[ expando ] || (elem[ expando ] = {});\n						if ( (oldCache = outerCache[ dir ]) &&\n							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n							// Assign to newCache so results back-propagate to previous elements\n							return (newCache[ 2 ] = oldCache[ 2 ]);\n						} else {\n							// Reuse newcache so results back-propagate to previous elements\n							outerCache[ dir ] = newCache;\n\n							// A match means we\'re done; a fail means we have to keep checking\n							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n								return true;\n							}\n						}\n					}\n				}\n			}\n		};\n}\n\nfunction elementMatcher( matchers ) {\n	return matchers.length > 1 ?\n		function( elem, context, xml ) {\n			var i = matchers.length;\n			while ( i-- ) {\n				if ( !matchers[i]( elem, context, xml ) ) {\n					return false;\n				}\n			}\n			return true;\n		} :\n		matchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n	var i = 0,\n		len = contexts.length;\n	for ( ; i < len; i++ ) {\n		Sizzle( selector, contexts[i], results );\n	}\n	return results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n	var elem,\n		newUnmatched = [],\n		i = 0,\n		len = unmatched.length,\n		mapped = map != null;\n\n	for ( ; i < len; i++ ) {\n		if ( (elem = unmatched[i]) ) {\n			if ( !filter || filter( elem, context, xml ) ) {\n				newUnmatched.push( elem );\n				if ( mapped ) {\n					map.push( i );\n				}\n			}\n		}\n	}\n\n	return newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n	if ( postFilter && !postFilter[ expando ] ) {\n		postFilter = setMatcher( postFilter );\n	}\n	if ( postFinder && !postFinder[ expando ] ) {\n		postFinder = setMatcher( postFinder, postSelector );\n	}\n	return markFunction(function( seed, results, context, xml ) {\n		var temp, i, elem,\n			preMap = [],\n			postMap = [],\n			preexisting = results.length,\n\n			// Get initial elements from seed or context\n			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),\n\n			// Prefilter to get matcher input, preserving a map for seed-results synchronization\n			matcherIn = preFilter && ( seed || !selector ) ?\n				condense( elems, preMap, preFilter, context, xml ) :\n				elems,\n\n			matcherOut = matcher ?\n				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n					// ...intermediate processing is necessary\n					[] :\n\n					// ...otherwise use results directly\n					results :\n				matcherIn;\n\n		// Find primary matches\n		if ( matcher ) {\n			matcher( matcherIn, matcherOut, context, xml );\n		}\n\n		// Apply postFilter\n		if ( postFilter ) {\n			temp = condense( matcherOut, postMap );\n			postFilter( temp, [], context, xml );\n\n			// Un-match failing elements by moving them back to matcherIn\n			i = temp.length;\n			while ( i-- ) {\n				if ( (elem = temp[i]) ) {\n					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n				}\n			}\n		}\n\n		if ( seed ) {\n			if ( postFinder || preFilter ) {\n				if ( postFinder ) {\n					// Get the final matcherOut by condensing this intermediate into postFinder contexts\n					temp = [];\n					i = matcherOut.length;\n					while ( i-- ) {\n						if ( (elem = matcherOut[i]) ) {\n							// Restore matcherIn since elem is not yet a final match\n							temp.push( (matcherIn[i] = elem) );\n						}\n					}\n					postFinder( null, (matcherOut = []), temp, xml );\n				}\n\n				// Move matched elements from seed to results to keep them synchronized\n				i = matcherOut.length;\n				while ( i-- ) {\n					if ( (elem = matcherOut[i]) &&\n						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n						seed[temp] = !(results[temp] = elem);\n					}\n				}\n			}\n\n		// Add elements to results, through postFinder if defined\n		} else {\n			matcherOut = condense(\n				matcherOut === results ?\n					matcherOut.splice( preexisting, matcherOut.length ) :\n					matcherOut\n			);\n			if ( postFinder ) {\n				postFinder( null, results, matcherOut, xml );\n			} else {\n				push.apply( results, matcherOut );\n			}\n		}\n	});\n}\n\nfunction matcherFromTokens( tokens ) {\n	var checkContext, matcher, j,\n		len = tokens.length,\n		leadingRelative = Expr.relative[ tokens[0].type ],\n		implicitRelative = leadingRelative || Expr.relative[" "],\n		i = leadingRelative ? 1 : 0,\n\n		// The foundational matcher ensures that elements are reachable from top-level context(s)\n		matchContext = addCombinator( function( elem ) {\n			return elem === checkContext;\n		}, implicitRelative, true ),\n		matchAnyContext = addCombinator( function( elem ) {\n			return indexOf( checkContext, elem ) > -1;\n		}, implicitRelative, true ),\n		matchers = [ function( elem, context, xml ) {\n			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n				(checkContext = context).nodeType ?\n					matchContext( elem, context, xml ) :\n					matchAnyContext( elem, context, xml ) );\n			// Avoid hanging onto element (issue #299)\n			checkContext = null;\n			return ret;\n		} ];\n\n	for ( ; i < len; i++ ) {\n		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n		} else {\n			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n			// Return special upon seeing a positional matcher\n			if ( matcher[ expando ] ) {\n				// Find the next relative operator (if any) for proper handling\n				j = ++i;\n				for ( ; j < len; j++ ) {\n					if ( Expr.relative[ tokens[j].type ] ) {\n						break;\n					}\n				}\n				return setMatcher(\n					i > 1 && elementMatcher( matchers ),\n					i > 1 && toSelector(\n						// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })\n					).replace( rtrim, "$1" ),\n					matcher,\n					i < j && matcherFromTokens( tokens.slice( i, j ) ),\n					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n					j < len && toSelector( tokens )\n				);\n			}\n			matchers.push( matcher );\n		}\n	}\n\n	return elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n	var bySet = setMatchers.length > 0,\n		byElement = elementMatchers.length > 0,\n		superMatcher = function( seed, context, xml, results, outermost ) {\n			var elem, j, matcher,\n				matchedCount = 0,\n				i = "0",\n				unmatched = seed && [],\n				setMatched = [],\n				contextBackup = outermostContext,\n				// We must always have either seed elements or outermost context\n				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),\n				// Use integer dirruns iff this is the outermost matcher\n				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n				len = elems.length;\n\n			if ( outermost ) {\n				outermostContext = context !== document && context;\n			}\n\n			// Add elements passing elementMatchers directly to results\n			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below\n			// Support: IE<9, Safari\n			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id\n			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n				if ( byElement && elem ) {\n					j = 0;\n					while ( (matcher = elementMatchers[j++]) ) {\n						if ( matcher( elem, context, xml ) ) {\n							results.push( elem );\n							break;\n						}\n					}\n					if ( outermost ) {\n						dirruns = dirrunsUnique;\n					}\n				}\n\n				// Track unmatched elements for set filters\n				if ( bySet ) {\n					// They will have gone through all possible matchers\n					if ( (elem = !matcher && elem) ) {\n						matchedCount--;\n					}\n\n					// Lengthen the array for every element, matched or not\n					if ( seed ) {\n						unmatched.push( elem );\n					}\n				}\n			}\n\n			// Apply set filters to unmatched elements\n			matchedCount += i;\n			if ( bySet && i !== matchedCount ) {\n				j = 0;\n				while ( (matcher = setMatchers[j++]) ) {\n					matcher( unmatched, setMatched, context, xml );\n				}\n\n				if ( seed ) {\n					// Reintegrate element matches to eliminate the need for sorting\n					if ( matchedCount > 0 ) {\n						while ( i-- ) {\n							if ( !(unmatched[i] || setMatched[i]) ) {\n								setMatched[i] = pop.call( results );\n							}\n						}\n					}\n\n					// Discard index placeholder values to get only actual matches\n					setMatched = condense( setMatched );\n				}\n\n				// Add matches to results\n				push.apply( results, setMatched );\n\n				// Seedless set matches succeeding multiple successful matchers stipulate sorting\n				if ( outermost && !seed && setMatched.length > 0 &&\n					( matchedCount + setMatchers.length ) > 1 ) {\n\n					Sizzle.uniqueSort( results );\n				}\n			}\n\n			// Override manipulation of globals by nested matchers\n			if ( outermost ) {\n				dirruns = dirrunsUnique;\n				outermostContext = contextBackup;\n			}\n\n			return unmatched;\n		};\n\n	return bySet ?\n		markFunction( superMatcher ) :\n		superMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n	var i,\n		setMatchers = [],\n		elementMatchers = [],\n		cached = compilerCache[ selector + " " ];\n\n	if ( !cached ) {\n		// Generate a function of recursive functions that can be used to check each element\n		if ( !match ) {\n			match = tokenize( selector );\n		}\n		i = match.length;\n		while ( i-- ) {\n			cached = matcherFromTokens( match[i] );\n			if ( cached[ expando ] ) {\n				setMatchers.push( cached );\n			} else {\n				elementMatchers.push( cached );\n			}\n		}\n\n		// Cache the compiled function\n		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n		// Save selector and tokenization\n		cached.selector = selector;\n	}\n	return cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle\'s compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n	var i, tokens, token, type, find,\n		compiled = typeof selector === "function" && selector,\n		match = !seed && tokenize( (selector = compiled.selector || selector) );\n\n	results = results || [];\n\n	// Try to minimize operations if there is no seed and only one group\n	if ( match.length === 1 ) {\n\n		// Take a shortcut and set the context if the root selector is an ID\n		tokens = match[0] = match[0].slice( 0 );\n		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&\n				support.getById && context.nodeType === 9 && documentIsHTML &&\n				Expr.relative[ tokens[1].type ] ) {\n\n			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n			if ( !context ) {\n				return results;\n\n			// Precompiled matchers will still verify ancestry, so step up a level\n			} else if ( compiled ) {\n				context = context.parentNode;\n			}\n\n			selector = selector.slice( tokens.shift().value.length );\n		}\n\n		// Fetch a seed set for right-to-left matching\n		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;\n		while ( i-- ) {\n			token = tokens[i];\n\n			// Abort if we hit a combinator\n			if ( Expr.relative[ (type = token.type) ] ) {\n				break;\n			}\n			if ( (find = Expr.find[ type ]) ) {\n				// Search, expanding context for leading sibling combinators\n				if ( (seed = find(\n					token.matches[0].replace( runescape, funescape ),\n					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n				)) ) {\n\n					// If seed is empty or no tokens remain, we can return early\n					tokens.splice( i, 1 );\n					selector = seed.length && toSelector( tokens );\n					if ( !selector ) {\n						push.apply( results, seed );\n						return results;\n					}\n\n					break;\n				}\n			}\n		}\n	}\n\n	// Compile and execute a filtering function if one is not provided\n	// Provide `match` to avoid retokenization if we modified the selector above\n	( compiled || compile( selector, match ) )(\n		seed,\n		context,\n		!documentIsHTML,\n		results,\n		rsibling.test( selector ) && testContext( context.parentNode ) || context\n	);\n	return results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split("").sort( sortOrder ).join("") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren\'t passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n	// Should return 1, but returns 4 (following)\n	return div1.compareDocumentPosition( document.createElement("div") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property "interpolation"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n	div.innerHTML = "<a href=\'#\'></a>";\n	return div.firstChild.getAttribute("href") === "#" ;\n}) ) {\n	addHandle( "type|href|height|width", function( elem, name, isXML ) {\n		if ( !isXML ) {\n			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );\n		}\n	});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute("value")\nif ( !support.attributes || !assert(function( div ) {\n	div.innerHTML = "<input/>";\n	div.firstChild.setAttribute( "value", "" );\n	return div.firstChild.getAttribute( "value" ) === "";\n}) ) {\n	addHandle( "value", function( elem, name, isXML ) {\n		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {\n			return elem.defaultValue;\n		}\n	});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n	return div.getAttribute("disabled") == null;\n}) ) {\n	addHandle( booleans, function( elem, name, isXML ) {\n		var val;\n		if ( !isXML ) {\n			return elem[ name ] === true ? name.toLowerCase() :\n					(val = elem.getAttributeNode( name )) && val.specified ?\n					val.value :\n				null;\n		}\n	});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[":"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n	if ( jQuery.isFunction( qualifier ) ) {\n		return jQuery.grep( elements, function( elem, i ) {\n			/* jshint -W018 */\n			return !!qualifier.call( elem, i, elem ) !== not;\n		});\n\n	}\n\n	if ( qualifier.nodeType ) {\n		return jQuery.grep( elements, function( elem ) {\n			return ( elem === qualifier ) !== not;\n		});\n\n	}\n\n	if ( typeof qualifier === "string" ) {\n		if ( risSimple.test( qualifier ) ) {\n			return jQuery.filter( qualifier, elements, not );\n		}\n\n		qualifier = jQuery.filter( qualifier, elements );\n	}\n\n	return jQuery.grep( elements, function( elem ) {\n		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;\n	});\n}\n\njQuery.filter = function( expr, elems, not ) {\n	var elem = elems[ 0 ];\n\n	if ( not ) {\n		expr = ":not(" + expr + ")";\n	}\n\n	return elems.length === 1 && elem.nodeType === 1 ?\n		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n			return elem.nodeType === 1;\n		}));\n};\n\njQuery.fn.extend({\n	find: function( selector ) {\n		var i,\n			len = this.length,\n			ret = [],\n			self = this;\n\n		if ( typeof selector !== "string" ) {\n			return this.pushStack( jQuery( selector ).filter(function() {\n				for ( i = 0; i < len; i++ ) {\n					if ( jQuery.contains( self[ i ], this ) ) {\n						return true;\n					}\n				}\n			}) );\n		}\n\n		for ( i = 0; i < len; i++ ) {\n			jQuery.find( selector, self[ i ], ret );\n		}\n\n		// Needed because $( selector, context ) becomes $( context ).find( selector )\n		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n		ret.selector = this.selector ? this.selector + " " + selector : selector;\n		return ret;\n	},\n	filter: function( selector ) {\n		return this.pushStack( winnow(this, selector || [], false) );\n	},\n	not: function( selector ) {\n		return this.pushStack( winnow(this, selector || [], true) );\n	},\n	is: function( selector ) {\n		return !!winnow(\n			this,\n\n			// If this is a positional/relative selector, check membership in the returned set\n			// so $("p:first").is("p:last") won\'t return true for a doc with two "p".\n			typeof selector === "string" && rneedsContext.test( selector ) ?\n				jQuery( selector ) :\n				selector || [],\n			false\n		).length;\n	}\n});\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n	// A simple way to check for HTML strings\n	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n	// Strict HTML recognition (#11290: must start with <)\n	rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n	init = jQuery.fn.init = function( selector, context ) {\n		var match, elem;\n\n		// HANDLE: $(""), $(null), $(undefined), $(false)\n		if ( !selector ) {\n			return this;\n		}\n\n		// Handle HTML strings\n		if ( typeof selector === "string" ) {\n			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {\n				// Assume that strings that start and end with <> are HTML and skip the regex check\n				match = [ null, selector, null ];\n\n			} else {\n				match = rquickExpr.exec( selector );\n			}\n\n			// Match html or make sure no context is specified for #id\n			if ( match && (match[1] || !context) ) {\n\n				// HANDLE: $(html) -> $(array)\n				if ( match[1] ) {\n					context = context instanceof jQuery ? context[0] : context;\n\n					// Option to run scripts is true for back-compat\n					// Intentionally let the error be thrown if parseHTML is not present\n					jQuery.merge( this, jQuery.parseHTML(\n						match[1],\n						context && context.nodeType ? context.ownerDocument || context : document,\n						true\n					) );\n\n					// HANDLE: $(html, props)\n					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n						for ( match in context ) {\n							// Properties of context are called as methods if possible\n							if ( jQuery.isFunction( this[ match ] ) ) {\n								this[ match ]( context[ match ] );\n\n							// ...and otherwise set as attributes\n							} else {\n								this.attr( match, context[ match ] );\n							}\n						}\n					}\n\n					return this;\n\n				// HANDLE: $(#id)\n				} else {\n					elem = document.getElementById( match[2] );\n\n					// Support: Blackberry 4.6\n					// gEBID returns nodes no longer in the document (#6963)\n					if ( elem && elem.parentNode ) {\n						// Inject the element directly into the jQuery object\n						this.length = 1;\n						this[0] = elem;\n					}\n\n					this.context = document;\n					this.selector = selector;\n					return this;\n				}\n\n			// HANDLE: $(expr, $(...))\n			} else if ( !context || context.jquery ) {\n				return ( context || rootjQuery ).find( selector );\n\n			// HANDLE: $(expr, context)\n			// (which is just equivalent to: $(context).find(expr)\n			} else {\n				return this.constructor( context ).find( selector );\n			}\n\n		// HANDLE: $(DOMElement)\n		} else if ( selector.nodeType ) {\n			this.context = this[0] = selector;\n			this.length = 1;\n			return this;\n\n		// HANDLE: $(function)\n		// Shortcut for document ready\n		} else if ( jQuery.isFunction( selector ) ) {\n			return typeof rootjQuery.ready !== "undefined" ?\n				rootjQuery.ready( selector ) :\n				// Execute immediately if ready is not present\n				selector( jQuery );\n		}\n\n		if ( selector.selector !== undefined ) {\n			this.selector = selector.selector;\n			this.context = selector.context;\n		}\n\n		return jQuery.makeArray( selector, this );\n	};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n	// Methods guaranteed to produce a unique set when starting from a unique set\n	guaranteedUnique = {\n		children: true,\n		contents: true,\n		next: true,\n		prev: true\n	};\n\njQuery.extend({\n	dir: function( elem, dir, until ) {\n		var matched = [],\n			truncate = until !== undefined;\n\n		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n			if ( elem.nodeType === 1 ) {\n				if ( truncate && jQuery( elem ).is( until ) ) {\n					break;\n				}\n				matched.push( elem );\n			}\n		}\n		return matched;\n	},\n\n	sibling: function( n, elem ) {\n		var matched = [];\n\n		for ( ; n; n = n.nextSibling ) {\n			if ( n.nodeType === 1 && n !== elem ) {\n				matched.push( n );\n			}\n		}\n\n		return matched;\n	}\n});\n\njQuery.fn.extend({\n	has: function( target ) {\n		var targets = jQuery( target, this ),\n			l = targets.length;\n\n		return this.filter(function() {\n			var i = 0;\n			for ( ; i < l; i++ ) {\n				if ( jQuery.contains( this, targets[i] ) ) {\n					return true;\n				}\n			}\n		});\n	},\n\n	closest: function( selectors, context ) {\n		var cur,\n			i = 0,\n			l = this.length,\n			matched = [],\n			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?\n				jQuery( selectors, context || this.context ) :\n				0;\n\n		for ( ; i < l; i++ ) {\n			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n				// Always skip document fragments\n				if ( cur.nodeType < 11 && (pos ?\n					pos.index(cur) > -1 :\n\n					// Don\'t pass non-elements to Sizzle\n					cur.nodeType === 1 &&\n						jQuery.find.matchesSelector(cur, selectors)) ) {\n\n					matched.push( cur );\n					break;\n				}\n			}\n		}\n\n		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n	},\n\n	// Determine the position of an element within the set\n	index: function( elem ) {\n\n		// No argument, return index in parent\n		if ( !elem ) {\n			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n		}\n\n		// Index in selector\n		if ( typeof elem === "string" ) {\n			return indexOf.call( jQuery( elem ), this[ 0 ] );\n		}\n\n		// Locate the position of the desired element\n		return indexOf.call( this,\n\n			// If it receives a jQuery object, the first element is used\n			elem.jquery ? elem[ 0 ] : elem\n		);\n	},\n\n	add: function( selector, context ) {\n		return this.pushStack(\n			jQuery.unique(\n				jQuery.merge( this.get(), jQuery( selector, context ) )\n			)\n		);\n	},\n\n	addBack: function( selector ) {\n		return this.add( selector == null ?\n			this.prevObject : this.prevObject.filter(selector)\n		);\n	}\n});\n\nfunction sibling( cur, dir ) {\n	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n	return cur;\n}\n\njQuery.each({\n	parent: function( elem ) {\n		var parent = elem.parentNode;\n		return parent && parent.nodeType !== 11 ? parent : null;\n	},\n	parents: function( elem ) {\n		return jQuery.dir( elem, "parentNode" );\n	},\n	parentsUntil: function( elem, i, until ) {\n		return jQuery.dir( elem, "parentNode", until );\n	},\n	next: function( elem ) {\n		return sibling( elem, "nextSibling" );\n	},\n	prev: function( elem ) {\n		return sibling( elem, "previousSibling" );\n	},\n	nextAll: function( elem ) {\n		return jQuery.dir( elem, "nextSibling" );\n	},\n	prevAll: function( elem ) {\n		return jQuery.dir( elem, "previousSibling" );\n	},\n	nextUntil: function( elem, i, until ) {\n		return jQuery.dir( elem, "nextSibling", until );\n	},\n	prevUntil: function( elem, i, until ) {\n		return jQuery.dir( elem, "previousSibling", until );\n	},\n	siblings: function( elem ) {\n		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n	},\n	children: function( elem ) {\n		return jQuery.sibling( elem.firstChild );\n	},\n	contents: function( elem ) {\n		return elem.contentDocument || jQuery.merge( [], elem.childNodes );\n	}\n}, function( name, fn ) {\n	jQuery.fn[ name ] = function( until, selector ) {\n		var matched = jQuery.map( this, fn, until );\n\n		if ( name.slice( -5 ) !== "Until" ) {\n			selector = until;\n		}\n\n		if ( selector && typeof selector === "string" ) {\n			matched = jQuery.filter( selector, matched );\n		}\n\n		if ( this.length > 1 ) {\n			// Remove duplicates\n			if ( !guaranteedUnique[ name ] ) {\n				jQuery.unique( matched );\n			}\n\n			// Reverse order for parents* and prev-derivatives\n			if ( rparentsprev.test( name ) ) {\n				matched.reverse();\n			}\n		}\n\n		return this.pushStack( matched );\n	};\n});\nvar rnotwhite = (/\\S+/g);\n\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n	var object = optionsCache[ options ] = {};\n	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n		object[ flag ] = true;\n	});\n	return object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *	options: an optional list of space-separated options that will change how\n *			the callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * "fired" multiple times.\n *\n * Possible options:\n *\n *	once:			will ensure the callback list can only be fired once (like a Deferred)\n *\n *	memory:			will keep track of previous values and will call any callback added\n *					after the list has been fired right away with the latest "memorized"\n *					values (like a Deferred)\n *\n *	unique:			will ensure a callback can only be added once (no duplicate in the list)\n *\n *	stopOnFalse:	interrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n	// Convert options from String-formatted to Object-formatted if needed\n	// (we check in cache first)\n	options = typeof options === "string" ?\n		( optionsCache[ options ] || createOptions( options ) ) :\n		jQuery.extend( {}, options );\n\n	var // Last fire value (for non-forgettable lists)\n		memory,\n		// Flag to know if list was already fired\n		fired,\n		// Flag to know if list is currently firing\n		firing,\n		// First callback to fire (used internally by add and fireWith)\n		firingStart,\n		// End of the loop when firing\n		firingLength,\n		// Index of currently firing callback (modified by remove if needed)\n		firingIndex,\n		// Actual callback list\n		list = [],\n		// Stack of fire calls for repeatable lists\n		stack = !options.once && [],\n		// Fire callbacks\n		fire = function( data ) {\n			memory = options.memory && data;\n			fired = true;\n			firingIndex = firingStart || 0;\n			firingStart = 0;\n			firingLength = list.length;\n			firing = true;\n			for ( ; list && firingIndex < firingLength; firingIndex++ ) {\n				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n					memory = false; // To prevent further calls using add\n					break;\n				}\n			}\n			firing = false;\n			if ( list ) {\n				if ( stack ) {\n					if ( stack.length ) {\n						fire( stack.shift() );\n					}\n				} else if ( memory ) {\n					list = [];\n				} else {\n					self.disable();\n				}\n			}\n		},\n		// Actual Callbacks object\n		self = {\n			// Add a callback or a collection of callbacks to the list\n			add: function() {\n				if ( list ) {\n					// First, we save the current length\n					var start = list.length;\n					(function add( args ) {\n						jQuery.each( args, function( _, arg ) {\n							var type = jQuery.type( arg );\n							if ( type === "function" ) {\n								if ( !options.unique || !self.has( arg ) ) {\n									list.push( arg );\n								}\n							} else if ( arg && arg.length && type !== "string" ) {\n								// Inspect recursively\n								add( arg );\n							}\n						});\n					})( arguments );\n					// Do we need to add the callbacks to the\n					// current firing batch?\n					if ( firing ) {\n						firingLength = list.length;\n					// With memory, if we\'re not firing then\n					// we should call right away\n					} else if ( memory ) {\n						firingStart = start;\n						fire( memory );\n					}\n				}\n				return this;\n			},\n			// Remove a callback from the list\n			remove: function() {\n				if ( list ) {\n					jQuery.each( arguments, function( _, arg ) {\n						var index;\n						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n							list.splice( index, 1 );\n							// Handle firing indexes\n							if ( firing ) {\n								if ( index <= firingLength ) {\n									firingLength--;\n								}\n								if ( index <= firingIndex ) {\n									firingIndex--;\n								}\n							}\n						}\n					});\n				}\n				return this;\n			},\n			// Check if a given callback is in the list.\n			// If no argument is given, return whether or not list has callbacks attached.\n			has: function( fn ) {\n				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n			},\n			// Remove all callbacks from the list\n			empty: function() {\n				list = [];\n				firingLength = 0;\n				return this;\n			},\n			// Have the list do nothing anymore\n			disable: function() {\n				list = stack = memory = undefined;\n				return this;\n			},\n			// Is it disabled?\n			disabled: function() {\n				return !list;\n			},\n			// Lock the list in its current state\n			lock: function() {\n				stack = undefined;\n				if ( !memory ) {\n					self.disable();\n				}\n				return this;\n			},\n			// Is it locked?\n			locked: function() {\n				return !stack;\n			},\n			// Call all callbacks with the given context and arguments\n			fireWith: function( context, args ) {\n				if ( list && ( !fired || stack ) ) {\n					args = args || [];\n					args = [ context, args.slice ? args.slice() : args ];\n					if ( firing ) {\n						stack.push( args );\n					} else {\n						fire( args );\n					}\n				}\n				return this;\n			},\n			// Call all the callbacks with the given arguments\n			fire: function() {\n				self.fireWith( this, arguments );\n				return this;\n			},\n			// To know if the callbacks have already been called at least once\n			fired: function() {\n				return !!fired;\n			}\n		};\n\n	return self;\n};\n\n\njQuery.extend({\n\n	Deferred: function( func ) {\n		var tuples = [\n				// action, add listener, listener list, final state\n				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],\n				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],\n				[ "notify", "progress", jQuery.Callbacks("memory") ]\n			],\n			state = "pending",\n			promise = {\n				state: function() {\n					return state;\n				},\n				always: function() {\n					deferred.done( arguments ).fail( arguments );\n					return this;\n				},\n				then: function( /* fnDone, fnFail, fnProgress */ ) {\n					var fns = arguments;\n					return jQuery.Deferred(function( newDefer ) {\n						jQuery.each( tuples, function( i, tuple ) {\n							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n							// deferred[ done | fail | progress ] for forwarding actions to newDefer\n							deferred[ tuple[1] ](function() {\n								var returned = fn && fn.apply( this, arguments );\n								if ( returned && jQuery.isFunction( returned.promise ) ) {\n									returned.promise()\n										.done( newDefer.resolve )\n										.fail( newDefer.reject )\n										.progress( newDefer.notify );\n								} else {\n									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n								}\n							});\n						});\n						fns = null;\n					}).promise();\n				},\n				// Get a promise for this deferred\n				// If obj is provided, the promise aspect is added to the object\n				promise: function( obj ) {\n					return obj != null ? jQuery.extend( obj, promise ) : promise;\n				}\n			},\n			deferred = {};\n\n		// Keep pipe for back-compat\n		promise.pipe = promise.then;\n\n		// Add list-specific methods\n		jQuery.each( tuples, function( i, tuple ) {\n			var list = tuple[ 2 ],\n				stateString = tuple[ 3 ];\n\n			// promise[ done | fail | progress ] = list.add\n			promise[ tuple[1] ] = list.add;\n\n			// Handle state\n			if ( stateString ) {\n				list.add(function() {\n					// state = [ resolved | rejected ]\n					state = stateString;\n\n				// [ reject_list | resolve_list ].disable; progress_list.lock\n				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n			}\n\n			// deferred[ resolve | reject | notify ]\n			deferred[ tuple[0] ] = function() {\n				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );\n				return this;\n			};\n			deferred[ tuple[0] + "With" ] = list.fireWith;\n		});\n\n		// Make the deferred a promise\n		promise.promise( deferred );\n\n		// Call given func if any\n		if ( func ) {\n			func.call( deferred, deferred );\n		}\n\n		// All done!\n		return deferred;\n	},\n\n	// Deferred helper\n	when: function( subordinate /* , ..., subordinateN */ ) {\n		var i = 0,\n			resolveValues = slice.call( arguments ),\n			length = resolveValues.length,\n\n			// the count of uncompleted subordinates\n			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n			// Update function for both resolve and progress values\n			updateFunc = function( i, contexts, values ) {\n				return function( value ) {\n					contexts[ i ] = this;\n					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n					if ( values === progressValues ) {\n						deferred.notifyWith( contexts, values );\n					} else if ( !( --remaining ) ) {\n						deferred.resolveWith( contexts, values );\n					}\n				};\n			},\n\n			progressValues, progressContexts, resolveContexts;\n\n		// Add listeners to Deferred subordinates; treat others as resolved\n		if ( length > 1 ) {\n			progressValues = new Array( length );\n			progressContexts = new Array( length );\n			resolveContexts = new Array( length );\n			for ( ; i < length; i++ ) {\n				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n					resolveValues[ i ].promise()\n						.done( updateFunc( i, resolveContexts, resolveValues ) )\n						.fail( deferred.reject )\n						.progress( updateFunc( i, progressContexts, progressValues ) );\n				} else {\n					--remaining;\n				}\n			}\n		}\n\n		// If we\'re not waiting on anything, resolve the master\n		if ( !remaining ) {\n			deferred.resolveWith( resolveContexts, resolveValues );\n		}\n\n		return deferred.promise();\n	}\n});\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n	// Add the callback\n	jQuery.ready.promise().done( fn );\n\n	return this;\n};\n\njQuery.extend({\n	// Is the DOM ready to be used? Set to true once it occurs.\n	isReady: false,\n\n	// A counter to track how many items to wait for before\n	// the ready event fires. See #6781\n	readyWait: 1,\n\n	// Hold (or release) the ready event\n	holdReady: function( hold ) {\n		if ( hold ) {\n			jQuery.readyWait++;\n		} else {\n			jQuery.ready( true );\n		}\n	},\n\n	// Handle when the DOM is ready\n	ready: function( wait ) {\n\n		// Abort if there are pending holds or we\'re already ready\n		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n			return;\n		}\n\n		// Remember that the DOM is ready\n		jQuery.isReady = true;\n\n		// If a normal DOM Ready event fired, decrement, and wait if need be\n		if ( wait !== true && --jQuery.readyWait > 0 ) {\n			return;\n		}\n\n		// If there are functions bound, to execute\n		readyList.resolveWith( document, [ jQuery ] );\n\n		// Trigger any bound ready events\n		if ( jQuery.fn.triggerHandler ) {\n			jQuery( document ).triggerHandler( "ready" );\n			jQuery( document ).off( "ready" );\n		}\n	}\n});\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n	document.removeEventListener( "DOMContentLoaded", completed, false );\n	window.removeEventListener( "load", completed, false );\n	jQuery.ready();\n}\n\njQuery.ready.promise = function( obj ) {\n	if ( !readyList ) {\n\n		readyList = jQuery.Deferred();\n\n		// Catch cases where $(document).ready() is called after the browser event has already occurred.\n		// We once tried to use readyState "interactive" here, but it caused issues like the one\n		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n		if ( document.readyState === "complete" ) {\n			// Handle it asynchronously to allow scripts the opportunity to delay ready\n			setTimeout( jQuery.ready );\n\n		} else {\n\n			// Use the handy event callback\n			document.addEventListener( "DOMContentLoaded", completed, false );\n\n			// A fallback to window.onload, that will always work\n			window.addEventListener( "load", completed, false );\n		}\n	}\n	return readyList.promise( obj );\n};\n\n// Kick off the DOM ready check even if the user does not\njQuery.ready.promise();\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it\'s a function\nvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n	var i = 0,\n		len = elems.length,\n		bulk = key == null;\n\n	// Sets many values\n	if ( jQuery.type( key ) === "object" ) {\n		chainable = true;\n		for ( i in key ) {\n			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n		}\n\n	// Sets one value\n	} else if ( value !== undefined ) {\n		chainable = true;\n\n		if ( !jQuery.isFunction( value ) ) {\n			raw = true;\n		}\n\n		if ( bulk ) {\n			// Bulk operations run against the entire set\n			if ( raw ) {\n				fn.call( elems, value );\n				fn = null;\n\n			// ...except when executing function values\n			} else {\n				bulk = fn;\n				fn = function( elem, key, value ) {\n					return bulk.call( jQuery( elem ), value );\n				};\n			}\n		}\n\n		if ( fn ) {\n			for ( ; i < len; i++ ) {\n				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n			}\n		}\n	}\n\n	return chainable ?\n		elems :\n\n		// Gets\n		bulk ?\n			fn.call( elems ) :\n			len ? fn( elems[0], key ) : emptyGet;\n};\n\n\n/**\n * Determines whether an object can have data\n */\njQuery.acceptData = function( owner ) {\n	// Accepts only:\n	//  - Node\n	//    - Node.ELEMENT_NODE\n	//    - Node.DOCUMENT_NODE\n	//  - Object\n	//    - Any\n	/* jshint -W018 */\n	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\nfunction Data() {\n	// Support: Android<4,\n	// Old WebKit does not have Object.preventExtensions/freeze method,\n	// return new empty object instead with no [[set]] accessor\n	Object.defineProperty( this.cache = {}, 0, {\n		get: function() {\n			return {};\n		}\n	});\n\n	this.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\nData.accepts = jQuery.acceptData;\n\nData.prototype = {\n	key: function( owner ) {\n		// We can accept data for non-element nodes in modern browsers,\n		// but we should not, see #8335.\n		// Always return the key for a frozen object.\n		if ( !Data.accepts( owner ) ) {\n			return 0;\n		}\n\n		var descriptor = {},\n			// Check if the owner object already has a cache key\n			unlock = owner[ this.expando ];\n\n		// If not, create one\n		if ( !unlock ) {\n			unlock = Data.uid++;\n\n			// Secure it in a non-enumerable, non-writable property\n			try {\n				descriptor[ this.expando ] = { value: unlock };\n				Object.defineProperties( owner, descriptor );\n\n			// Support: Android<4\n			// Fallback to a less secure definition\n			} catch ( e ) {\n				descriptor[ this.expando ] = unlock;\n				jQuery.extend( owner, descriptor );\n			}\n		}\n\n		// Ensure the cache object\n		if ( !this.cache[ unlock ] ) {\n			this.cache[ unlock ] = {};\n		}\n\n		return unlock;\n	},\n	set: function( owner, data, value ) {\n		var prop,\n			// There may be an unlock assigned to this node,\n			// if there is no entry for this "owner", create one inline\n			// and set the unlock as though an owner entry had always existed\n			unlock = this.key( owner ),\n			cache = this.cache[ unlock ];\n\n		// Handle: [ owner, key, value ] args\n		if ( typeof data === "string" ) {\n			cache[ data ] = value;\n\n		// Handle: [ owner, { properties } ] args\n		} else {\n			// Fresh assignments by object are shallow copied\n			if ( jQuery.isEmptyObject( cache ) ) {\n				jQuery.extend( this.cache[ unlock ], data );\n			// Otherwise, copy the properties one-by-one to the cache object\n			} else {\n				for ( prop in data ) {\n					cache[ prop ] = data[ prop ];\n				}\n			}\n		}\n		return cache;\n	},\n	get: function( owner, key ) {\n		// Either a valid cache is found, or will be created.\n		// New caches will be created and the unlock returned,\n		// allowing direct access to the newly created\n		// empty data object. A valid owner object must be provided.\n		var cache = this.cache[ this.key( owner ) ];\n\n		return key === undefined ?\n			cache : cache[ key ];\n	},\n	access: function( owner, key, value ) {\n		var stored;\n		// In cases where either:\n		//\n		//   1. No key was specified\n		//   2. A string key was specified, but no value provided\n		//\n		// Take the "read" path and allow the get method to determine\n		// which value to return, respectively either:\n		//\n		//   1. The entire cache object\n		//   2. The data stored at the key\n		//\n		if ( key === undefined ||\n				((key && typeof key === "string") && value === undefined) ) {\n\n			stored = this.get( owner, key );\n\n			return stored !== undefined ?\n				stored : this.get( owner, jQuery.camelCase(key) );\n		}\n\n		// [*]When the key is not a string, or both a key and value\n		// are specified, set or extend (existing objects) with either:\n		//\n		//   1. An object of properties\n		//   2. A key and value\n		//\n		this.set( owner, key, value );\n\n		// Since the "set" path can have two possible entry points\n		// return the expected data based on which path was taken[*]\n		return value !== undefined ? value : key;\n	},\n	remove: function( owner, key ) {\n		var i, name, camel,\n			unlock = this.key( owner ),\n			cache = this.cache[ unlock ];\n\n		if ( key === undefined ) {\n			this.cache[ unlock ] = {};\n\n		} else {\n			// Support array or space separated string of keys\n			if ( jQuery.isArray( key ) ) {\n				// If "name" is an array of keys...\n				// When data is initially created, via ("key", "val") signature,\n				// keys will be converted to camelCase.\n				// Since there is no way to tell _how_ a key was added, remove\n				// both plain key and camelCase key. #12786\n				// This will only penalize the array argument path.\n				name = key.concat( key.map( jQuery.camelCase ) );\n			} else {\n				camel = jQuery.camelCase( key );\n				// Try the string as a key before any manipulation\n				if ( key in cache ) {\n					name = [ key, camel ];\n				} else {\n					// If a key with the spaces exists, use it.\n					// Otherwise, create an array by matching non-whitespace\n					name = camel;\n					name = name in cache ?\n						[ name ] : ( name.match( rnotwhite ) || [] );\n				}\n			}\n\n			i = name.length;\n			while ( i-- ) {\n				delete cache[ name[ i ] ];\n			}\n		}\n	},\n	hasData: function( owner ) {\n		return !jQuery.isEmptyObject(\n			this.cache[ owner[ this.expando ] ] || {}\n		);\n	},\n	discard: function( owner ) {\n		if ( owner[ this.expando ] ) {\n			delete this.cache[ owner[ this.expando ] ];\n		}\n	}\n};\nvar data_priv = new Data();\n\nvar data_user = new Data();\n\n\n\n//	Implementation Summary\n//\n//	1. Enforce API surface and semantic compatibility with 1.9.x branch\n//	2. Improve the module\'s maintainability by reducing the storage\n//		paths to a single mechanism.\n//	3. Use the same single mechanism to support "private" and "user" data.\n//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)\n//	5. Avoid exposing implementation details on user objects (eg. expando properties)\n//	6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n	rmultiDash = /([A-Z])/g;\n\nfunction dataAttr( elem, key, data ) {\n	var name;\n\n	// If nothing was found internally, try to fetch any\n	// data from the HTML5 data-* attribute\n	if ( data === undefined && elem.nodeType === 1 ) {\n		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();\n		data = elem.getAttribute( name );\n\n		if ( typeof data === "string" ) {\n			try {\n				data = data === "true" ? true :\n					data === "false" ? false :\n					data === "null" ? null :\n					// Only convert to a number if it doesn\'t change the string\n					+data + "" === data ? +data :\n					rbrace.test( data ) ? jQuery.parseJSON( data ) :\n					data;\n			} catch( e ) {}\n\n			// Make sure we set the data so it isn\'t changed later\n			data_user.set( elem, key, data );\n		} else {\n			data = undefined;\n		}\n	}\n	return data;\n}\n\njQuery.extend({\n	hasData: function( elem ) {\n		return data_user.hasData( elem ) || data_priv.hasData( elem );\n	},\n\n	data: function( elem, name, data ) {\n		return data_user.access( elem, name, data );\n	},\n\n	removeData: function( elem, name ) {\n		data_user.remove( elem, name );\n	},\n\n	// TODO: Now that all calls to _data and _removeData have been replaced\n	// with direct calls to data_priv methods, these can be deprecated.\n	_data: function( elem, name, data ) {\n		return data_priv.access( elem, name, data );\n	},\n\n	_removeData: function( elem, name ) {\n		data_priv.remove( elem, name );\n	}\n});\n\njQuery.fn.extend({\n	data: function( key, value ) {\n		var i, name, data,\n			elem = this[ 0 ],\n			attrs = elem && elem.attributes;\n\n		// Gets all values\n		if ( key === undefined ) {\n			if ( this.length ) {\n				data = data_user.get( elem );\n\n				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {\n					i = attrs.length;\n					while ( i-- ) {\n\n						// Support: IE11+\n						// The attrs elements can be null (#14894)\n						if ( attrs[ i ] ) {\n							name = attrs[ i ].name;\n							if ( name.indexOf( "data-" ) === 0 ) {\n								name = jQuery.camelCase( name.slice(5) );\n								dataAttr( elem, name, data[ name ] );\n							}\n						}\n					}\n					data_priv.set( elem, "hasDataAttrs", true );\n				}\n			}\n\n			return data;\n		}\n\n		// Sets multiple values\n		if ( typeof key === "object" ) {\n			return this.each(function() {\n				data_user.set( this, key );\n			});\n		}\n\n		return access( this, function( value ) {\n			var data,\n				camelKey = jQuery.camelCase( key );\n\n			// The calling jQuery object (element matches) is not empty\n			// (and therefore has an element appears at this[ 0 ]) and the\n			// `value` parameter was not undefined. An empty jQuery object\n			// will result in `undefined` for elem = this[ 0 ] which will\n			// throw an exception if an attempt to read a data cache is made.\n			if ( elem && value === undefined ) {\n				// Attempt to get data from the cache\n				// with the key as-is\n				data = data_user.get( elem, key );\n				if ( data !== undefined ) {\n					return data;\n				}\n\n				// Attempt to get data from the cache\n				// with the key camelized\n				data = data_user.get( elem, camelKey );\n				if ( data !== undefined ) {\n					return data;\n				}\n\n				// Attempt to "discover" the data in\n				// HTML5 custom data-* attrs\n				data = dataAttr( elem, camelKey, undefined );\n				if ( data !== undefined ) {\n					return data;\n				}\n\n				// We tried really hard, but the data doesn\'t exist.\n				return;\n			}\n\n			// Set the data...\n			this.each(function() {\n				// First, attempt to store a copy or reference of any\n				// data that might\'ve been store with a camelCased key.\n				var data = data_user.get( this, camelKey );\n\n				// For HTML5 data-* attribute interop, we have to\n				// store property names with dashes in a camelCase form.\n				// This might not apply to all properties...*\n				data_user.set( this, camelKey, value );\n\n				// *... In the case of properties that might _actually_\n				// have dashes, we need to also store a copy of that\n				// unchanged property.\n				if ( key.indexOf("-") !== -1 && data !== undefined ) {\n					data_user.set( this, key, value );\n				}\n			});\n		}, null, value, arguments.length > 1, null, true );\n	},\n\n	removeData: function( key ) {\n		return this.each(function() {\n			data_user.remove( this, key );\n		});\n	}\n});\n\n\njQuery.extend({\n	queue: function( elem, type, data ) {\n		var queue;\n\n		if ( elem ) {\n			type = ( type || "fx" ) + "queue";\n			queue = data_priv.get( elem, type );\n\n			// Speed up dequeue by getting out quickly if this is just a lookup\n			if ( data ) {\n				if ( !queue || jQuery.isArray( data ) ) {\n					queue = data_priv.access( elem, type, jQuery.makeArray(data) );\n				} else {\n					queue.push( data );\n				}\n			}\n			return queue || [];\n		}\n	},\n\n	dequeue: function( elem, type ) {\n		type = type || "fx";\n\n		var queue = jQuery.queue( elem, type ),\n			startLength = queue.length,\n			fn = queue.shift(),\n			hooks = jQuery._queueHooks( elem, type ),\n			next = function() {\n				jQuery.dequeue( elem, type );\n			};\n\n		// If the fx queue is dequeued, always remove the progress sentinel\n		if ( fn === "inprogress" ) {\n			fn = queue.shift();\n			startLength--;\n		}\n\n		if ( fn ) {\n\n			// Add a progress sentinel to prevent the fx queue from being\n			// automatically dequeued\n			if ( type === "fx" ) {\n				queue.unshift( "inprogress" );\n			}\n\n			// Clear up the last queue stop function\n			delete hooks.stop;\n			fn.call( elem, next, hooks );\n		}\n\n		if ( !startLength && hooks ) {\n			hooks.empty.fire();\n		}\n	},\n\n	// Not public - generate a queueHooks object, or return the current one\n	_queueHooks: function( elem, type ) {\n		var key = type + "queueHooks";\n		return data_priv.get( elem, key ) || data_priv.access( elem, key, {\n			empty: jQuery.Callbacks("once memory").add(function() {\n				data_priv.remove( elem, [ type + "queue", key ] );\n			})\n		});\n	}\n});\n\njQuery.fn.extend({\n	queue: function( type, data ) {\n		var setter = 2;\n\n		if ( typeof type !== "string" ) {\n			data = type;\n			type = "fx";\n			setter--;\n		}\n\n		if ( arguments.length < setter ) {\n			return jQuery.queue( this[0], type );\n		}\n\n		return data === undefined ?\n			this :\n			this.each(function() {\n				var queue = jQuery.queue( this, type, data );\n\n				// Ensure a hooks for this queue\n				jQuery._queueHooks( this, type );\n\n				if ( type === "fx" && queue[0] !== "inprogress" ) {\n					jQuery.dequeue( this, type );\n				}\n			});\n	},\n	dequeue: function( type ) {\n		return this.each(function() {\n			jQuery.dequeue( this, type );\n		});\n	},\n	clearQueue: function( type ) {\n		return this.queue( type || "fx", [] );\n	},\n	// Get a promise resolved when queues of a certain type\n	// are emptied (fx is the type by default)\n	promise: function( type, obj ) {\n		var tmp,\n			count = 1,\n			defer = jQuery.Deferred(),\n			elements = this,\n			i = this.length,\n			resolve = function() {\n				if ( !( --count ) ) {\n					defer.resolveWith( elements, [ elements ] );\n				}\n			};\n\n		if ( typeof type !== "string" ) {\n			obj = type;\n			type = undefined;\n		}\n		type = type || "fx";\n\n		while ( i-- ) {\n			tmp = data_priv.get( elements[ i ], type + "queueHooks" );\n			if ( tmp && tmp.empty ) {\n				count++;\n				tmp.empty.add( resolve );\n			}\n		}\n		resolve();\n		return defer.promise( obj );\n	}\n});\nvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\nvar cssExpand = [ "Top", "Right", "Bottom", "Left" ];\n\nvar isHidden = function( elem, el ) {\n		// isHidden might be called from jQuery#filter function;\n		// in that case, element will be second argument\n		elem = el || elem;\n		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );\n	};\n\nvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\n\n\n(function() {\n	var fragment = document.createDocumentFragment(),\n		div = fragment.appendChild( document.createElement( "div" ) ),\n		input = document.createElement( "input" );\n\n	// Support: Safari<=5.1\n	// Check state lost if the name is set (#11217)\n	// Support: Windows Web Apps (WWA)\n	// `name` and `type` must use .setAttribute for WWA (#14901)\n	input.setAttribute( "type", "radio" );\n	input.setAttribute( "checked", "checked" );\n	input.setAttribute( "name", "t" );\n\n	div.appendChild( input );\n\n	// Support: Safari<=5.1, Android<4.2\n	// Older WebKit doesn\'t clone checked state correctly in fragments\n	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n	// Support: IE<=11+\n	// Make sure textarea (and checkbox) defaultValue is properly cloned\n	div.innerHTML = "<textarea>x</textarea>";\n	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n})();\nvar strundefined = typeof undefined;\n\n\n\nsupport.focusinBubbles = "onfocusin" in window;\n\n\nvar\n	rkeyEvent = /^key/,\n	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n	rtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n	return true;\n}\n\nfunction returnFalse() {\n	return false;\n}\n\nfunction safeActiveElement() {\n	try {\n		return document.activeElement;\n	} catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards\' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n	global: {},\n\n	add: function( elem, types, handler, data, selector ) {\n\n		var handleObjIn, eventHandle, tmp,\n			events, t, handleObj,\n			special, handlers, type, namespaces, origType,\n			elemData = data_priv.get( elem );\n\n		// Don\'t attach events to noData or text/comment nodes (but allow plain objects)\n		if ( !elemData ) {\n			return;\n		}\n\n		// Caller can pass in an object of custom data in lieu of the handler\n		if ( handler.handler ) {\n			handleObjIn = handler;\n			handler = handleObjIn.handler;\n			selector = handleObjIn.selector;\n		}\n\n		// Make sure that the handler has a unique ID, used to find/remove it later\n		if ( !handler.guid ) {\n			handler.guid = jQuery.guid++;\n		}\n\n		// Init the element\'s event structure and main handler, if this is the first\n		if ( !(events = elemData.events) ) {\n			events = elemData.events = {};\n		}\n		if ( !(eventHandle = elemData.handle) ) {\n			eventHandle = elemData.handle = function( e ) {\n				// Discard the second event of a jQuery.event.trigger() and\n				// when an event is called after a page has unloaded\n				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?\n					jQuery.event.dispatch.apply( elem, arguments ) : undefined;\n			};\n		}\n\n		// Handle multiple events separated by a space\n		types = ( types || "" ).match( rnotwhite ) || [ "" ];\n		t = types.length;\n		while ( t-- ) {\n			tmp = rtypenamespace.exec( types[t] ) || [];\n			type = origType = tmp[1];\n			namespaces = ( tmp[2] || "" ).split( "." ).sort();\n\n			// There *must* be a type, no attaching namespace-only handlers\n			if ( !type ) {\n				continue;\n			}\n\n			// If event changes its type, use the special event handlers for the changed type\n			special = jQuery.event.special[ type ] || {};\n\n			// If selector defined, determine special event api type, otherwise given type\n			type = ( selector ? special.delegateType : special.bindType ) || type;\n\n			// Update special based on newly reset type\n			special = jQuery.event.special[ type ] || {};\n\n			// handleObj is passed to all event handlers\n			handleObj = jQuery.extend({\n				type: type,\n				origType: origType,\n				data: data,\n				handler: handler,\n				guid: handler.guid,\n				selector: selector,\n				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n				namespace: namespaces.join(".")\n			}, handleObjIn );\n\n			// Init the event handler queue if we\'re the first\n			if ( !(handlers = events[ type ]) ) {\n				handlers = events[ type ] = [];\n				handlers.delegateCount = 0;\n\n				// Only use addEventListener if the special events handler returns false\n				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n					if ( elem.addEventListener ) {\n						elem.addEventListener( type, eventHandle, false );\n					}\n				}\n			}\n\n			if ( special.add ) {\n				special.add.call( elem, handleObj );\n\n				if ( !handleObj.handler.guid ) {\n					handleObj.handler.guid = handler.guid;\n				}\n			}\n\n			// Add to the element\'s handler list, delegates in front\n			if ( selector ) {\n				handlers.splice( handlers.delegateCount++, 0, handleObj );\n			} else {\n				handlers.push( handleObj );\n			}\n\n			// Keep track of which events have ever been used, for event optimization\n			jQuery.event.global[ type ] = true;\n		}\n\n	},\n\n	// Detach an event or set of events from an element\n	remove: function( elem, types, handler, selector, mappedTypes ) {\n\n		var j, origCount, tmp,\n			events, t, handleObj,\n			special, handlers, type, namespaces, origType,\n			elemData = data_priv.hasData( elem ) && data_priv.get( elem );\n\n		if ( !elemData || !(events = elemData.events) ) {\n			return;\n		}\n\n		// Once for each type.namespace in types; type may be omitted\n		types = ( types || "" ).match( rnotwhite ) || [ "" ];\n		t = types.length;\n		while ( t-- ) {\n			tmp = rtypenamespace.exec( types[t] ) || [];\n			type = origType = tmp[1];\n			namespaces = ( tmp[2] || "" ).split( "." ).sort();\n\n			// Unbind all events (on this namespace, if provided) for the element\n			if ( !type ) {\n				for ( type in events ) {\n					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n				}\n				continue;\n			}\n\n			special = jQuery.event.special[ type ] || {};\n			type = ( selector ? special.delegateType : special.bindType ) || type;\n			handlers = events[ type ] || [];\n			tmp = tmp[2] && new RegExp( "(^|\\\\.)" + namespaces.join("\\\\.(?:.*\\\\.|)") + "(\\\\.|$)" );\n\n			// Remove matching events\n			origCount = j = handlers.length;\n			while ( j-- ) {\n				handleObj = handlers[ j ];\n\n				if ( ( mappedTypes || origType === handleObj.origType ) &&\n					( !handler || handler.guid === handleObj.guid ) &&\n					( !tmp || tmp.test( handleObj.namespace ) ) &&\n					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {\n					handlers.splice( j, 1 );\n\n					if ( handleObj.selector ) {\n						handlers.delegateCount--;\n					}\n					if ( special.remove ) {\n						special.remove.call( elem, handleObj );\n					}\n				}\n			}\n\n			// Remove generic event handler if we removed something and no more handlers exist\n			// (avoids potential for endless recursion during removal of special event handlers)\n			if ( origCount && !handlers.length ) {\n				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n					jQuery.removeEvent( elem, type, elemData.handle );\n				}\n\n				delete events[ type ];\n			}\n		}\n\n		// Remove the expando if it\'s no longer used\n		if ( jQuery.isEmptyObject( events ) ) {\n			delete elemData.handle;\n			data_priv.remove( elem, "events" );\n		}\n	},\n\n	trigger: function( event, data, elem, onlyHandlers ) {\n\n		var i, cur, tmp, bubbleType, ontype, handle, special,\n			eventPath = [ elem || document ],\n			type = hasOwn.call( event, "type" ) ? event.type : event,\n			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];\n\n		cur = tmp = elem = elem || document;\n\n		// Don\'t do events on text and comment nodes\n		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n			return;\n		}\n\n		// focus/blur morphs to focusin/out; ensure we\'re not firing them right now\n		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n			return;\n		}\n\n		if ( type.indexOf(".") >= 0 ) {\n			// Namespaced trigger; create a regexp to match event type in handle()\n			namespaces = type.split(".");\n			type = namespaces.shift();\n			namespaces.sort();\n		}\n		ontype = type.indexOf(":") < 0 && "on" + type;\n\n		// Caller can pass in a jQuery.Event object, Object, or just an event type string\n		event = event[ jQuery.expando ] ?\n			event :\n			new jQuery.Event( type, typeof event === "object" && event );\n\n		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n		event.isTrigger = onlyHandlers ? 2 : 3;\n		event.namespace = namespaces.join(".");\n		event.namespace_re = event.namespace ?\n			new RegExp( "(^|\\\\.)" + namespaces.join("\\\\.(?:.*\\\\.|)") + "(\\\\.|$)" ) :\n			null;\n\n		// Clean up the event in case it is being reused\n		event.result = undefined;\n		if ( !event.target ) {\n			event.target = elem;\n		}\n\n		// Clone any incoming data and prepend the event, creating the handler arg list\n		data = data == null ?\n			[ event ] :\n			jQuery.makeArray( data, [ event ] );\n\n		// Allow special events to draw outside the lines\n		special = jQuery.event.special[ type ] || {};\n		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n			return;\n		}\n\n		// Determine event propagation path in advance, per W3C events spec (#9951)\n		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n			bubbleType = special.delegateType || type;\n			if ( !rfocusMorph.test( bubbleType + type ) ) {\n				cur = cur.parentNode;\n			}\n			for ( ; cur; cur = cur.parentNode ) {\n				eventPath.push( cur );\n				tmp = cur;\n			}\n\n			// Only add window if we got to document (e.g., not plain obj or detached DOM)\n			if ( tmp === (elem.ownerDocument || document) ) {\n				eventPath.push( tmp.defaultView || tmp.parentWindow || window );\n			}\n		}\n\n		// Fire handlers on the event path\n		i = 0;\n		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n			event.type = i > 1 ?\n				bubbleType :\n				special.bindType || type;\n\n			// jQuery handler\n			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );\n			if ( handle ) {\n				handle.apply( cur, data );\n			}\n\n			// Native handler\n			handle = ontype && cur[ ontype ];\n			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n				event.result = handle.apply( cur, data );\n				if ( event.result === false ) {\n					event.preventDefault();\n				}\n			}\n		}\n		event.type = type;\n\n		// If nobody prevented the default action, do it now\n		if ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n				jQuery.acceptData( elem ) ) {\n\n				// Call a native DOM method on the target with the same name name as the event.\n				// Don\'t do default actions on window, that\'s where global variables be (#6170)\n				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n					// Don\'t re-trigger an onFOO event when we call its FOO() method\n					tmp = elem[ ontype ];\n\n					if ( tmp ) {\n						elem[ ontype ] = null;\n					}\n\n					// Prevent re-triggering of the same event, since we already bubbled it above\n					jQuery.event.triggered = type;\n					elem[ type ]();\n					jQuery.event.triggered = undefined;\n\n					if ( tmp ) {\n						elem[ ontype ] = tmp;\n					}\n				}\n			}\n		}\n\n		return event.result;\n	},\n\n	dispatch: function( event ) {\n\n		// Make a writable jQuery.Event from the native event object\n		event = jQuery.event.fix( event );\n\n		var i, j, ret, matched, handleObj,\n			handlerQueue = [],\n			args = slice.call( arguments ),\n			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],\n			special = jQuery.event.special[ event.type ] || {};\n\n		// Use the fix-ed jQuery.Event rather than the (read-only) native event\n		args[0] = event;\n		event.delegateTarget = this;\n\n		// Call the preDispatch hook for the mapped type, and let it bail if desired\n		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n			return;\n		}\n\n		// Determine handlers\n		handlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n		// Run delegates first; they may want to stop propagation beneath us\n		i = 0;\n		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n			event.currentTarget = matched.elem;\n\n			j = 0;\n			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n				// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n				// a subset or equal to those in the bound event (both can have no namespace).\n				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n					event.handleObj = handleObj;\n					event.data = handleObj.data;\n\n					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n							.apply( matched.elem, args );\n\n					if ( ret !== undefined ) {\n						if ( (event.result = ret) === false ) {\n							event.preventDefault();\n							event.stopPropagation();\n						}\n					}\n				}\n			}\n		}\n\n		// Call the postDispatch hook for the mapped type\n		if ( special.postDispatch ) {\n			special.postDispatch.call( this, event );\n		}\n\n		return event.result;\n	},\n\n	handlers: function( event, handlers ) {\n		var i, matches, sel, handleObj,\n			handlerQueue = [],\n			delegateCount = handlers.delegateCount,\n			cur = event.target;\n\n		// Find delegate handlers\n		// Black-hole SVG <use> instance trees (#13180)\n		// Avoid non-left-click bubbling in Firefox (#3861)\n		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {\n\n			for ( ; cur !== this; cur = cur.parentNode || this ) {\n\n				// Don\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\n				if ( cur.disabled !== true || event.type !== "click" ) {\n					matches = [];\n					for ( i = 0; i < delegateCount; i++ ) {\n						handleObj = handlers[ i ];\n\n						// Don\'t conflict with Object.prototype properties (#13203)\n						sel = handleObj.selector + " ";\n\n						if ( matches[ sel ] === undefined ) {\n							matches[ sel ] = handleObj.needsContext ?\n								jQuery( sel, this ).index( cur ) >= 0 :\n								jQuery.find( sel, this, null, [ cur ] ).length;\n						}\n						if ( matches[ sel ] ) {\n							matches.push( handleObj );\n						}\n					}\n					if ( matches.length ) {\n						handlerQueue.push({ elem: cur, handlers: matches });\n					}\n				}\n			}\n		}\n\n		// Add the remaining (directly-bound) handlers\n		if ( delegateCount < handlers.length ) {\n			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n		}\n\n		return handlerQueue;\n	},\n\n	// Includes some event props shared by KeyEvent and MouseEvent\n	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),\n\n	fixHooks: {},\n\n	keyHooks: {\n		props: "char charCode key keyCode".split(" "),\n		filter: function( event, original ) {\n\n			// Add which for key events\n			if ( event.which == null ) {\n				event.which = original.charCode != null ? original.charCode : original.keyCode;\n			}\n\n			return event;\n		}\n	},\n\n	mouseHooks: {\n		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),\n		filter: function( event, original ) {\n			var eventDoc, doc, body,\n				button = original.button;\n\n			// Calculate pageX/Y if missing and clientX/Y available\n			if ( event.pageX == null && original.clientX != null ) {\n				eventDoc = event.target.ownerDocument || document;\n				doc = eventDoc.documentElement;\n				body = eventDoc.body;\n\n				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n			}\n\n			// Add which for click: 1 === left; 2 === middle; 3 === right\n			// Note: button is not normalized, so don\'t use it\n			if ( !event.which && button !== undefined ) {\n				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n			}\n\n			return event;\n		}\n	},\n\n	fix: function( event ) {\n		if ( event[ jQuery.expando ] ) {\n			return event;\n		}\n\n		// Create a writable copy of the event object and normalize some properties\n		var i, prop, copy,\n			type = event.type,\n			originalEvent = event,\n			fixHook = this.fixHooks[ type ];\n\n		if ( !fixHook ) {\n			this.fixHooks[ type ] = fixHook =\n				rmouseEvent.test( type ) ? this.mouseHooks :\n				rkeyEvent.test( type ) ? this.keyHooks :\n				{};\n		}\n		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n		event = new jQuery.Event( originalEvent );\n\n		i = copy.length;\n		while ( i-- ) {\n			prop = copy[ i ];\n			event[ prop ] = originalEvent[ prop ];\n		}\n\n		// Support: Cordova 2.5 (WebKit) (#13255)\n		// All events should have a target; Cordova deviceready doesn\'t\n		if ( !event.target ) {\n			event.target = document;\n		}\n\n		// Support: Safari 6.0+, Chrome<28\n		// Target should not be a text node (#504, #13143)\n		if ( event.target.nodeType === 3 ) {\n			event.target = event.target.parentNode;\n		}\n\n		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n	},\n\n	special: {\n		load: {\n			// Prevent triggered image.load events from bubbling to window.load\n			noBubble: true\n		},\n		focus: {\n			// Fire native event if possible so blur/focus sequence is correct\n			trigger: function() {\n				if ( this !== safeActiveElement() && this.focus ) {\n					this.focus();\n					return false;\n				}\n			},\n			delegateType: "focusin"\n		},\n		blur: {\n			trigger: function() {\n				if ( this === safeActiveElement() && this.blur ) {\n					this.blur();\n					return false;\n				}\n			},\n			delegateType: "focusout"\n		},\n		click: {\n			// For checkbox, fire native event so checked state will be right\n			trigger: function() {\n				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {\n					this.click();\n					return false;\n				}\n			},\n\n			// For cross-browser consistency, don\'t fire native .click() on links\n			_default: function( event ) {\n				return jQuery.nodeName( event.target, "a" );\n			}\n		},\n\n		beforeunload: {\n			postDispatch: function( event ) {\n\n				// Support: Firefox 20+\n				// Firefox doesn\'t alert if the returnValue field is not set.\n				if ( event.result !== undefined && event.originalEvent ) {\n					event.originalEvent.returnValue = event.result;\n				}\n			}\n		}\n	},\n\n	simulate: function( type, elem, event, bubble ) {\n		// Piggyback on a donor event to simulate a different one.\n		// Fake originalEvent to avoid donor\'s stopPropagation, but if the\n		// simulated event prevents default then we do the same on the donor.\n		var e = jQuery.extend(\n			new jQuery.Event(),\n			event,\n			{\n				type: type,\n				isSimulated: true,\n				originalEvent: {}\n			}\n		);\n		if ( bubble ) {\n			jQuery.event.trigger( e, null, elem );\n		} else {\n			jQuery.event.dispatch.call( elem, e );\n		}\n		if ( e.isDefaultPrevented() ) {\n			event.preventDefault();\n		}\n	}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n	if ( elem.removeEventListener ) {\n		elem.removeEventListener( type, handle, false );\n	}\n};\n\njQuery.Event = function( src, props ) {\n	// Allow instantiation without the \'new\' keyword\n	if ( !(this instanceof jQuery.Event) ) {\n		return new jQuery.Event( src, props );\n	}\n\n	// Event object\n	if ( src && src.type ) {\n		this.originalEvent = src;\n		this.type = src.type;\n\n		// Events bubbling up the document may have been marked as prevented\n		// by a handler lower down the tree; reflect the correct value.\n		this.isDefaultPrevented = src.defaultPrevented ||\n				src.defaultPrevented === undefined &&\n				// Support: Android<4.0\n				src.returnValue === false ?\n			returnTrue :\n			returnFalse;\n\n	// Event type\n	} else {\n		this.type = src;\n	}\n\n	// Put explicitly provided properties onto the event object\n	if ( props ) {\n		jQuery.extend( this, props );\n	}\n\n	// Create a timestamp if incoming event doesn\'t have one\n	this.timeStamp = src && src.timeStamp || jQuery.now();\n\n	// Mark it as fixed\n	this[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n	isDefaultPrevented: returnFalse,\n	isPropagationStopped: returnFalse,\n	isImmediatePropagationStopped: returnFalse,\n\n	preventDefault: function() {\n		var e = this.originalEvent;\n\n		this.isDefaultPrevented = returnTrue;\n\n		if ( e && e.preventDefault ) {\n			e.preventDefault();\n		}\n	},\n	stopPropagation: function() {\n		var e = this.originalEvent;\n\n		this.isPropagationStopped = returnTrue;\n\n		if ( e && e.stopPropagation ) {\n			e.stopPropagation();\n		}\n	},\n	stopImmediatePropagation: function() {\n		var e = this.originalEvent;\n\n		this.isImmediatePropagationStopped = returnTrue;\n\n		if ( e && e.stopImmediatePropagation ) {\n			e.stopImmediatePropagation();\n		}\n\n		this.stopPropagation();\n	}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// Support: Chrome 15+\njQuery.each({\n	mouseenter: "mouseover",\n	mouseleave: "mouseout",\n	pointerenter: "pointerover",\n	pointerleave: "pointerout"\n}, function( orig, fix ) {\n	jQuery.event.special[ orig ] = {\n		delegateType: fix,\n		bindType: fix,\n\n		handle: function( event ) {\n			var ret,\n				target = this,\n				related = event.relatedTarget,\n				handleObj = event.handleObj;\n\n			// For mousenter/leave call the handler if related is outside the target.\n			// NB: No relatedTarget if the mouse left/entered the browser window\n			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n				event.type = handleObj.origType;\n				ret = handleObj.handler.apply( this, arguments );\n				event.type = fix;\n			}\n			return ret;\n		}\n	};\n});\n\n// Support: Firefox, Chrome, Safari\n// Create "bubbling" focus and blur events\nif ( !support.focusinBubbles ) {\n	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {\n\n		// Attach a single capturing handler on the document while someone wants focusin/focusout\n		var handler = function( event ) {\n				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n			};\n\n		jQuery.event.special[ fix ] = {\n			setup: function() {\n				var doc = this.ownerDocument || this,\n					attaches = data_priv.access( doc, fix );\n\n				if ( !attaches ) {\n					doc.addEventListener( orig, handler, true );\n				}\n				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );\n			},\n			teardown: function() {\n				var doc = this.ownerDocument || this,\n					attaches = data_priv.access( doc, fix ) - 1;\n\n				if ( !attaches ) {\n					doc.removeEventListener( orig, handler, true );\n					data_priv.remove( doc, fix );\n\n				} else {\n					data_priv.access( doc, fix, attaches );\n				}\n			}\n		};\n	});\n}\n\njQuery.fn.extend({\n\n	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n		var origFn, type;\n\n		// Types can be a map of types/handlers\n		if ( typeof types === "object" ) {\n			// ( types-Object, selector, data )\n			if ( typeof selector !== "string" ) {\n				// ( types-Object, data )\n				data = data || selector;\n				selector = undefined;\n			}\n			for ( type in types ) {\n				this.on( type, selector, data, types[ type ], one );\n			}\n			return this;\n		}\n\n		if ( data == null && fn == null ) {\n			// ( types, fn )\n			fn = selector;\n			data = selector = undefined;\n		} else if ( fn == null ) {\n			if ( typeof selector === "string" ) {\n				// ( types, selector, fn )\n				fn = data;\n				data = undefined;\n			} else {\n				// ( types, data, fn )\n				fn = data;\n				data = selector;\n				selector = undefined;\n			}\n		}\n		if ( fn === false ) {\n			fn = returnFalse;\n		} else if ( !fn ) {\n			return this;\n		}\n\n		if ( one === 1 ) {\n			origFn = fn;\n			fn = function( event ) {\n				// Can use an empty set, since event contains the info\n				jQuery().off( event );\n				return origFn.apply( this, arguments );\n			};\n			// Use same guid so caller can remove using origFn\n			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n		}\n		return this.each( function() {\n			jQuery.event.add( this, types, fn, data, selector );\n		});\n	},\n	one: function( types, selector, data, fn ) {\n		return this.on( types, selector, data, fn, 1 );\n	},\n	off: function( types, selector, fn ) {\n		var handleObj, type;\n		if ( types && types.preventDefault && types.handleObj ) {\n			// ( event )  dispatched jQuery.Event\n			handleObj = types.handleObj;\n			jQuery( types.delegateTarget ).off(\n				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,\n				handleObj.selector,\n				handleObj.handler\n			);\n			return this;\n		}\n		if ( typeof types === "object" ) {\n			// ( types-object [, selector] )\n			for ( type in types ) {\n				this.off( type, selector, types[ type ] );\n			}\n			return this;\n		}\n		if ( selector === false || typeof selector === "function" ) {\n			// ( types [, fn] )\n			fn = selector;\n			selector = undefined;\n		}\n		if ( fn === false ) {\n			fn = returnFalse;\n		}\n		return this.each(function() {\n			jQuery.event.remove( this, types, fn, selector );\n		});\n	},\n\n	trigger: function( type, data ) {\n		return this.each(function() {\n			jQuery.event.trigger( type, data, this );\n		});\n	},\n	triggerHandler: function( type, data ) {\n		var elem = this[0];\n		if ( elem ) {\n			return jQuery.event.trigger( type, data, elem, true );\n		}\n	}\n});\n\n\nvar\n	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n	rtagName = /<([\\w:]+)/,\n	rhtml = /<|&#?\\w+;/,\n	rnoInnerhtml = /<(?:script|style|link)/i,\n	// checked="checked" or checked\n	rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n	rscriptType = /^$|\\/(?:java|ecma)script/i,\n	rscriptTypeMasked = /^true\\/(.*)/,\n	rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n	// We have to close these tags to support XHTML (#13200)\n	wrapMap = {\n\n		// Support: IE9\n		option: [ 1, "<select multiple=\'multiple\'>", "</select>" ],\n\n		thead: [ 1, "<table>", "</table>" ],\n		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],\n		tr: [ 2, "<table><tbody>", "</tbody></table>" ],\n		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],\n\n		_default: [ 0, "", "" ]\n	};\n\n// Support: IE9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support: 1.x compatibility\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n	return jQuery.nodeName( elem, "table" ) &&\n		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?\n\n		elem.getElementsByTagName("tbody")[0] ||\n			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :\n		elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;\n	return elem;\n}\nfunction restoreScript( elem ) {\n	var match = rscriptTypeMasked.exec( elem.type );\n\n	if ( match ) {\n		elem.type = match[ 1 ];\n	} else {\n		elem.removeAttribute("type");\n	}\n\n	return elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n	var i = 0,\n		l = elems.length;\n\n	for ( ; i < l; i++ ) {\n		data_priv.set(\n			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )\n		);\n	}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n	if ( dest.nodeType !== 1 ) {\n		return;\n	}\n\n	// 1. Copy private data: events, handlers, etc.\n	if ( data_priv.hasData( src ) ) {\n		pdataOld = data_priv.access( src );\n		pdataCur = data_priv.set( dest, pdataOld );\n		events = pdataOld.events;\n\n		if ( events ) {\n			delete pdataCur.handle;\n			pdataCur.events = {};\n\n			for ( type in events ) {\n				for ( i = 0, l = events[ type ].length; i < l; i++ ) {\n					jQuery.event.add( dest, type, events[ type ][ i ] );\n				}\n			}\n		}\n	}\n\n	// 2. Copy user data\n	if ( data_user.hasData( src ) ) {\n		udataOld = data_user.access( src );\n		udataCur = jQuery.extend( {}, udataOld );\n\n		data_user.set( dest, udataCur );\n	}\n}\n\nfunction getAll( context, tag ) {\n	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :\n			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :\n			[];\n\n	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n		jQuery.merge( [ context ], ret ) :\n		ret;\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n	var nodeName = dest.nodeName.toLowerCase();\n\n	// Fails to persist the checked state of a cloned checkbox or radio button.\n	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {\n		dest.checked = src.checked;\n\n	// Fails to return the selected option to the default selected state when cloning options\n	} else if ( nodeName === "input" || nodeName === "textarea" ) {\n		dest.defaultValue = src.defaultValue;\n	}\n}\n\njQuery.extend({\n	clone: function( elem, dataAndEvents, deepDataAndEvents ) {\n		var i, l, srcElements, destElements,\n			clone = elem.cloneNode( true ),\n			inPage = jQuery.contains( elem.ownerDocument, elem );\n\n		// Fix IE cloning issues\n		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n				!jQuery.isXMLDoc( elem ) ) {\n\n			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n			destElements = getAll( clone );\n			srcElements = getAll( elem );\n\n			for ( i = 0, l = srcElements.length; i < l; i++ ) {\n				fixInput( srcElements[ i ], destElements[ i ] );\n			}\n		}\n\n		// Copy the events from the original to the clone\n		if ( dataAndEvents ) {\n			if ( deepDataAndEvents ) {\n				srcElements = srcElements || getAll( elem );\n				destElements = destElements || getAll( clone );\n\n				for ( i = 0, l = srcElements.length; i < l; i++ ) {\n					cloneCopyEvent( srcElements[ i ], destElements[ i ] );\n				}\n			} else {\n				cloneCopyEvent( elem, clone );\n			}\n		}\n\n		// Preserve script evaluation history\n		destElements = getAll( clone, "script" );\n		if ( destElements.length > 0 ) {\n			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );\n		}\n\n		// Return the cloned set\n		return clone;\n	},\n\n	buildFragment: function( elems, context, scripts, selection ) {\n		var elem, tmp, tag, wrap, contains, j,\n			fragment = context.createDocumentFragment(),\n			nodes = [],\n			i = 0,\n			l = elems.length;\n\n		for ( ; i < l; i++ ) {\n			elem = elems[ i ];\n\n			if ( elem || elem === 0 ) {\n\n				// Add nodes directly\n				if ( jQuery.type( elem ) === "object" ) {\n					// Support: QtWebKit, PhantomJS\n					// push.apply(_, arraylike) throws on ancient WebKit\n					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n				// Convert non-html into a text node\n				} else if ( !rhtml.test( elem ) ) {\n					nodes.push( context.createTextNode( elem ) );\n\n				// Convert html into DOM nodes\n				} else {\n					tmp = tmp || fragment.appendChild( context.createElement("div") );\n\n					// Deserialize a standard representation\n					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();\n					wrap = wrapMap[ tag ] || wrapMap._default;\n					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];\n\n					// Descend through wrappers to the right content\n					j = wrap[ 0 ];\n					while ( j-- ) {\n						tmp = tmp.lastChild;\n					}\n\n					// Support: QtWebKit, PhantomJS\n					// push.apply(_, arraylike) throws on ancient WebKit\n					jQuery.merge( nodes, tmp.childNodes );\n\n					// Remember the top-level container\n					tmp = fragment.firstChild;\n\n					// Ensure the created nodes are orphaned (#12392)\n					tmp.textContent = "";\n				}\n			}\n		}\n\n		// Remove wrapper from fragment\n		fragment.textContent = "";\n\n		i = 0;\n		while ( (elem = nodes[ i++ ]) ) {\n\n			// #4087 - If origin and destination elements are the same, and this is\n			// that element, do not do anything\n			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n				continue;\n			}\n\n			contains = jQuery.contains( elem.ownerDocument, elem );\n\n			// Append to fragment\n			tmp = getAll( fragment.appendChild( elem ), "script" );\n\n			// Preserve script evaluation history\n			if ( contains ) {\n				setGlobalEval( tmp );\n			}\n\n			// Capture executables\n			if ( scripts ) {\n				j = 0;\n				while ( (elem = tmp[ j++ ]) ) {\n					if ( rscriptType.test( elem.type || "" ) ) {\n						scripts.push( elem );\n					}\n				}\n			}\n		}\n\n		return fragment;\n	},\n\n	cleanData: function( elems ) {\n		var data, elem, type, key,\n			special = jQuery.event.special,\n			i = 0;\n\n		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n			if ( jQuery.acceptData( elem ) ) {\n				key = elem[ data_priv.expando ];\n\n				if ( key && (data = data_priv.cache[ key ]) ) {\n					if ( data.events ) {\n						for ( type in data.events ) {\n							if ( special[ type ] ) {\n								jQuery.event.remove( elem, type );\n\n							// This is a shortcut to avoid jQuery.event.remove\'s overhead\n							} else {\n								jQuery.removeEvent( elem, type, data.handle );\n							}\n						}\n					}\n					if ( data_priv.cache[ key ] ) {\n						// Discard any remaining `private` data\n						delete data_priv.cache[ key ];\n					}\n				}\n			}\n			// Discard any remaining `user` data\n			delete data_user.cache[ elem[ data_user.expando ] ];\n		}\n	}\n});\n\njQuery.fn.extend({\n	text: function( value ) {\n		return access( this, function( value ) {\n			return value === undefined ?\n				jQuery.text( this ) :\n				this.empty().each(function() {\n					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n						this.textContent = value;\n					}\n				});\n		}, null, value, arguments.length );\n	},\n\n	append: function() {\n		return this.domManip( arguments, function( elem ) {\n			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n				var target = manipulationTarget( this, elem );\n				target.appendChild( elem );\n			}\n		});\n	},\n\n	prepend: function() {\n		return this.domManip( arguments, function( elem ) {\n			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n				var target = manipulationTarget( this, elem );\n				target.insertBefore( elem, target.firstChild );\n			}\n		});\n	},\n\n	before: function() {\n		return this.domManip( arguments, function( elem ) {\n			if ( this.parentNode ) {\n				this.parentNode.insertBefore( elem, this );\n			}\n		});\n	},\n\n	after: function() {\n		return this.domManip( arguments, function( elem ) {\n			if ( this.parentNode ) {\n				this.parentNode.insertBefore( elem, this.nextSibling );\n			}\n		});\n	},\n\n	remove: function( selector, keepData /* Internal Use Only */ ) {\n		var elem,\n			elems = selector ? jQuery.filter( selector, this ) : this,\n			i = 0;\n\n		for ( ; (elem = elems[i]) != null; i++ ) {\n			if ( !keepData && elem.nodeType === 1 ) {\n				jQuery.cleanData( getAll( elem ) );\n			}\n\n			if ( elem.parentNode ) {\n				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n					setGlobalEval( getAll( elem, "script" ) );\n				}\n				elem.parentNode.removeChild( elem );\n			}\n		}\n\n		return this;\n	},\n\n	empty: function() {\n		var elem,\n			i = 0;\n\n		for ( ; (elem = this[i]) != null; i++ ) {\n			if ( elem.nodeType === 1 ) {\n\n				// Prevent memory leaks\n				jQuery.cleanData( getAll( elem, false ) );\n\n				// Remove any remaining nodes\n				elem.textContent = "";\n			}\n		}\n\n		return this;\n	},\n\n	clone: function( dataAndEvents, deepDataAndEvents ) {\n		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n		return this.map(function() {\n			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n		});\n	},\n\n	html: function( value ) {\n		return access( this, function( value ) {\n			var elem = this[ 0 ] || {},\n				i = 0,\n				l = this.length;\n\n			if ( value === undefined && elem.nodeType === 1 ) {\n				return elem.innerHTML;\n			}\n\n			// See if we can take a shortcut and just use innerHTML\n			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&\n				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {\n\n				value = value.replace( rxhtmlTag, "<$1></$2>" );\n\n				try {\n					for ( ; i < l; i++ ) {\n						elem = this[ i ] || {};\n\n						// Remove element nodes and prevent memory leaks\n						if ( elem.nodeType === 1 ) {\n							jQuery.cleanData( getAll( elem, false ) );\n							elem.innerHTML = value;\n						}\n					}\n\n					elem = 0;\n\n				// If using innerHTML throws an exception, use the fallback method\n				} catch( e ) {}\n			}\n\n			if ( elem ) {\n				this.empty().append( value );\n			}\n		}, null, value, arguments.length );\n	},\n\n	replaceWith: function() {\n		var arg = arguments[ 0 ];\n\n		// Make the changes, replacing each context element with the new content\n		this.domManip( arguments, function( elem ) {\n			arg = this.parentNode;\n\n			jQuery.cleanData( getAll( this ) );\n\n			if ( arg ) {\n				arg.replaceChild( elem, this );\n			}\n		});\n\n		// Force removal if there was no new content (e.g., from empty arguments)\n		return arg && (arg.length || arg.nodeType) ? this : this.remove();\n	},\n\n	detach: function( selector ) {\n		return this.remove( selector, true );\n	},\n\n	domManip: function( args, callback ) {\n\n		// Flatten any nested arrays\n		args = concat.apply( [], args );\n\n		var fragment, first, scripts, hasScripts, node, doc,\n			i = 0,\n			l = this.length,\n			set = this,\n			iNoClone = l - 1,\n			value = args[ 0 ],\n			isFunction = jQuery.isFunction( value );\n\n		// We can\'t cloneNode fragments that contain checked, in WebKit\n		if ( isFunction ||\n				( l > 1 && typeof value === "string" &&\n					!support.checkClone && rchecked.test( value ) ) ) {\n			return this.each(function( index ) {\n				var self = set.eq( index );\n				if ( isFunction ) {\n					args[ 0 ] = value.call( this, index, self.html() );\n				}\n				self.domManip( args, callback );\n			});\n		}\n\n		if ( l ) {\n			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n			first = fragment.firstChild;\n\n			if ( fragment.childNodes.length === 1 ) {\n				fragment = first;\n			}\n\n			if ( first ) {\n				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );\n				hasScripts = scripts.length;\n\n				// Use the original fragment for the last item instead of the first because it can end up\n				// being emptied incorrectly in certain situations (#8070).\n				for ( ; i < l; i++ ) {\n					node = fragment;\n\n					if ( i !== iNoClone ) {\n						node = jQuery.clone( node, true, true );\n\n						// Keep references to cloned scripts for later restoration\n						if ( hasScripts ) {\n							// Support: QtWebKit\n							// jQuery.merge because push.apply(_, arraylike) throws\n							jQuery.merge( scripts, getAll( node, "script" ) );\n						}\n					}\n\n					callback.call( this[ i ], node, i );\n				}\n\n				if ( hasScripts ) {\n					doc = scripts[ scripts.length - 1 ].ownerDocument;\n\n					// Reenable scripts\n					jQuery.map( scripts, restoreScript );\n\n					// Evaluate executable scripts on first document insertion\n					for ( i = 0; i < hasScripts; i++ ) {\n						node = scripts[ i ];\n						if ( rscriptType.test( node.type || "" ) &&\n							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {\n\n							if ( node.src ) {\n								// Optional AJAX dependency, but won\'t run scripts if not present\n								if ( jQuery._evalUrl ) {\n									jQuery._evalUrl( node.src );\n								}\n							} else {\n								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );\n							}\n						}\n					}\n				}\n			}\n		}\n\n		return this;\n	}\n});\n\njQuery.each({\n	appendTo: "append",\n	prependTo: "prepend",\n	insertBefore: "before",\n	insertAfter: "after",\n	replaceAll: "replaceWith"\n}, function( name, original ) {\n	jQuery.fn[ name ] = function( selector ) {\n		var elems,\n			ret = [],\n			insert = jQuery( selector ),\n			last = insert.length - 1,\n			i = 0;\n\n		for ( ; i <= last; i++ ) {\n			elems = i === last ? this : this.clone( true );\n			jQuery( insert[ i ] )[ original ]( elems );\n\n			// Support: QtWebKit\n			// .get() because push.apply(_, arraylike) throws\n			push.apply( ret, elems.get() );\n		}\n\n		return this.pushStack( ret );\n	};\n});\n\n\nvar iframe,\n	elemdisplay = {};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n	var style,\n		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n		// getDefaultComputedStyle might be reliably used only on attached element\n		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?\n\n			// Use of this method is a temporary fix (more like optimization) until something better comes along,\n			// since it was removed from specification and supported only in FF\n			style.display : jQuery.css( elem[ 0 ], "display" );\n\n	// We don\'t have any data stored on the element,\n	// so use "detach" method as fast way to get rid of the element\n	elem.detach();\n\n	return display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n	var doc = document,\n		display = elemdisplay[ nodeName ];\n\n	if ( !display ) {\n		display = actualDisplay( nodeName, doc );\n\n		// If the simple way fails, read from inside an iframe\n		if ( display === "none" || !display ) {\n\n			// Use the already-created iframe if possible\n			iframe = (iframe || jQuery( "<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>" )).appendTo( doc.documentElement );\n\n			// Always write a new HTML skeleton so Webkit and Firefox don\'t choke on reuse\n			doc = iframe[ 0 ].contentDocument;\n\n			// Support: IE\n			doc.write();\n			doc.close();\n\n			display = actualDisplay( nodeName, doc );\n			iframe.detach();\n		}\n\n		// Store the correct default display\n		elemdisplay[ nodeName ] = display;\n	}\n\n	return display;\n}\nvar rmargin = (/^margin/);\n\nvar rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );\n\nvar getStyles = function( elem ) {\n		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n		// IE throws on elements created in popups\n		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"\n		if ( elem.ownerDocument.defaultView.opener ) {\n			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n		}\n\n		return window.getComputedStyle( elem, null );\n	};\n\n\n\nfunction curCSS( elem, name, computed ) {\n	var width, minWidth, maxWidth, ret,\n		style = elem.style;\n\n	computed = computed || getStyles( elem );\n\n	// Support: IE9\n	// getPropertyValue is only needed for .css(\'filter\') (#12537)\n	if ( computed ) {\n		ret = computed.getPropertyValue( name ) || computed[ name ];\n	}\n\n	if ( computed ) {\n\n		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n			ret = jQuery.style( elem, name );\n		}\n\n		// Support: iOS < 6\n		// A tribute to the "awesome hack by Dean Edwards"\n		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n			// Remember the original values\n			width = style.width;\n			minWidth = style.minWidth;\n			maxWidth = style.maxWidth;\n\n			// Put in the new values to get a computed value out\n			style.minWidth = style.maxWidth = style.width = ret;\n			ret = computed.width;\n\n			// Revert the changed values\n			style.width = width;\n			style.minWidth = minWidth;\n			style.maxWidth = maxWidth;\n		}\n	}\n\n	return ret !== undefined ?\n		// Support: IE\n		// IE returns zIndex value as an integer.\n		ret + "" :\n		ret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n	// Define the hook, we\'ll check on the first run if it\'s really needed.\n	return {\n		get: function() {\n			if ( conditionFn() ) {\n				// Hook not needed (or it\'s not possible to use it due\n				// to missing dependency), remove it.\n				delete this.get;\n				return;\n			}\n\n			// Hook needed; redefine it so that the support test is not executed again.\n			return (this.get = hookFn).apply( this, arguments );\n		}\n	};\n}\n\n\n(function() {\n	var pixelPositionVal, boxSizingReliableVal,\n		docElem = document.documentElement,\n		container = document.createElement( "div" ),\n		div = document.createElement( "div" );\n\n	if ( !div.style ) {\n		return;\n	}\n\n	// Support: IE9-11+\n	// Style of cloned element affects source element cloned (#8908)\n	div.style.backgroundClip = "content-box";\n	div.cloneNode( true ).style.backgroundClip = "";\n	support.clearCloneStyle = div.style.backgroundClip === "content-box";\n\n	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +\n		"position:absolute";\n	container.appendChild( div );\n\n	// Executing both pixelPosition & boxSizingReliable tests require only one layout\n	// so they\'re executed at the same time to save the second computation.\n	function computePixelPositionAndBoxSizingReliable() {\n		div.style.cssText =\n			// Support: Firefox<29, Android 2.3\n			// Vendor-prefix box-sizing\n			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +\n			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +\n			"border:1px;padding:1px;width:4px;position:absolute";\n		div.innerHTML = "";\n		docElem.appendChild( container );\n\n		var divStyle = window.getComputedStyle( div, null );\n		pixelPositionVal = divStyle.top !== "1%";\n		boxSizingReliableVal = divStyle.width === "4px";\n\n		docElem.removeChild( container );\n	}\n\n	// Support: node.js jsdom\n	// Don\'t assume that getComputedStyle is a property of the global object\n	if ( window.getComputedStyle ) {\n		jQuery.extend( support, {\n			pixelPosition: function() {\n\n				// This test is executed only once but we still do memoizing\n				// since we can use the boxSizingReliable pre-computing.\n				// No need to check if the test was already performed, though.\n				computePixelPositionAndBoxSizingReliable();\n				return pixelPositionVal;\n			},\n			boxSizingReliable: function() {\n				if ( boxSizingReliableVal == null ) {\n					computePixelPositionAndBoxSizingReliable();\n				}\n				return boxSizingReliableVal;\n			},\n			reliableMarginRight: function() {\n\n				// Support: Android 2.3\n				// Check if div with explicit width and no margin-right incorrectly\n				// gets computed margin-right based on width of container. (#3333)\n				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n				// This support function is only executed once so no memoizing is needed.\n				var ret,\n					marginDiv = div.appendChild( document.createElement( "div" ) );\n\n				// Reset CSS: box-sizing; display; margin; border; padding\n				marginDiv.style.cssText = div.style.cssText =\n					// Support: Firefox<29, Android 2.3\n					// Vendor-prefix box-sizing\n					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +\n					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";\n				marginDiv.style.marginRight = marginDiv.style.width = "0";\n				div.style.width = "1px";\n				docElem.appendChild( container );\n\n				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );\n\n				docElem.removeChild( container );\n				div.removeChild( marginDiv );\n\n				return ret;\n			}\n		});\n	}\n})();\n\n\n// A method for quickly swapping in/out CSS properties to get correct calculations.\njQuery.swap = function( elem, options, callback, args ) {\n	var ret, name,\n		old = {};\n\n	// Remember the old values, and insert the new ones\n	for ( name in options ) {\n		old[ name ] = elem.style[ name ];\n		elem.style[ name ] = options[ name ];\n	}\n\n	ret = callback.apply( elem, args || [] );\n\n	// Revert the old values\n	for ( name in options ) {\n		elem.style[ name ] = old[ name ];\n	}\n\n	return ret;\n};\n\n\nvar\n	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"\n	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n	rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),\n	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),\n\n	cssShow = { position: "absolute", visibility: "hidden", display: "block" },\n	cssNormalTransform = {\n		letterSpacing: "0",\n		fontWeight: "400"\n	},\n\n	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n	// Shortcut for names that are not vendor prefixed\n	if ( name in style ) {\n		return name;\n	}\n\n	// Check for vendor prefixed names\n	var capName = name[0].toUpperCase() + name.slice(1),\n		origName = name,\n		i = cssPrefixes.length;\n\n	while ( i-- ) {\n		name = cssPrefixes[ i ] + capName;\n		if ( name in style ) {\n			return name;\n		}\n	}\n\n	return origName;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n	var matches = rnumsplit.exec( value );\n	return matches ?\n		// Guard against undefined "subtract", e.g., when used as in cssHooks\n		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :\n		value;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n	var i = extra === ( isBorderBox ? "border" : "content" ) ?\n		// If we already have the right measurement, avoid augmentation\n		4 :\n		// Otherwise initialize for horizontal or vertical properties\n		name === "width" ? 1 : 0,\n\n		val = 0;\n\n	for ( ; i < 4; i += 2 ) {\n		// Both box models exclude margin, so add it if we want it\n		if ( extra === "margin" ) {\n			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n		}\n\n		if ( isBorderBox ) {\n			// border-box includes padding, so remove it if we want content\n			if ( extra === "content" ) {\n				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n			}\n\n			// At this point, extra isn\'t border nor margin, so remove border\n			if ( extra !== "margin" ) {\n				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n			}\n		} else {\n			// At this point, extra isn\'t content, so add padding\n			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\n			// At this point, extra isn\'t content nor padding, so add border\n			if ( extra !== "padding" ) {\n				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n			}\n		}\n	}\n\n	return val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n	// Start with offset property, which is equivalent to the border-box value\n	var valueIsBorderBox = true,\n		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,\n		styles = getStyles( elem ),\n		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";\n\n	// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n	if ( val <= 0 || val == null ) {\n		// Fall back to computed then uncomputed css if necessary\n		val = curCSS( elem, name, styles );\n		if ( val < 0 || val == null ) {\n			val = elem.style[ name ];\n		}\n\n		// Computed unit is not pixels. Stop here and return.\n		if ( rnumnonpx.test(val) ) {\n			return val;\n		}\n\n		// Check for style in case a browser which returns unreliable values\n		// for getComputedStyle silently falls back to the reliable elem.style\n		valueIsBorderBox = isBorderBox &&\n			( support.boxSizingReliable() || val === elem.style[ name ] );\n\n		// Normalize "", auto, and prepare for extra\n		val = parseFloat( val ) || 0;\n	}\n\n	// Use the active box-sizing model to add/subtract irrelevant styles\n	return ( val +\n		augmentWidthOrHeight(\n			elem,\n			name,\n			extra || ( isBorderBox ? "border" : "content" ),\n			valueIsBorderBox,\n			styles\n		)\n	) + "px";\n}\n\nfunction showHide( elements, show ) {\n	var display, elem, hidden,\n		values = [],\n		index = 0,\n		length = elements.length;\n\n	for ( ; index < length; index++ ) {\n		elem = elements[ index ];\n		if ( !elem.style ) {\n			continue;\n		}\n\n		values[ index ] = data_priv.get( elem, "olddisplay" );\n		display = elem.style.display;\n		if ( show ) {\n			// Reset the inline display of this element to learn if it is\n			// being hidden by cascaded rules or not\n			if ( !values[ index ] && display === "none" ) {\n				elem.style.display = "";\n			}\n\n			// Set elements which have been overridden with display: none\n			// in a stylesheet to whatever the default browser style is\n			// for such an element\n			if ( elem.style.display === "" && isHidden( elem ) ) {\n				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );\n			}\n		} else {\n			hidden = isHidden( elem );\n\n			if ( display !== "none" || !hidden ) {\n				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );\n			}\n		}\n	}\n\n	// Set the display of most of the elements in a second loop\n	// to avoid the constant reflow\n	for ( index = 0; index < length; index++ ) {\n		elem = elements[ index ];\n		if ( !elem.style ) {\n			continue;\n		}\n		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {\n			elem.style.display = show ? values[ index ] || "" : "none";\n		}\n	}\n\n	return elements;\n}\n\njQuery.extend({\n\n	// Add in style property hooks for overriding the default\n	// behavior of getting and setting a style property\n	cssHooks: {\n		opacity: {\n			get: function( elem, computed ) {\n				if ( computed ) {\n\n					// We should always get a number back from opacity\n					var ret = curCSS( elem, "opacity" );\n					return ret === "" ? "1" : ret;\n				}\n			}\n		}\n	},\n\n	// Don\'t automatically add "px" to these possibly-unitless properties\n	cssNumber: {\n		"columnCount": true,\n		"fillOpacity": true,\n		"flexGrow": true,\n		"flexShrink": true,\n		"fontWeight": true,\n		"lineHeight": true,\n		"opacity": true,\n		"order": true,\n		"orphans": true,\n		"widows": true,\n		"zIndex": true,\n		"zoom": true\n	},\n\n	// Add in properties whose names you wish to fix before\n	// setting or getting the value\n	cssProps: {\n		"float": "cssFloat"\n	},\n\n	// Get and set the style property on a DOM Node\n	style: function( elem, name, value, extra ) {\n\n		// Don\'t set styles on text and comment nodes\n		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n			return;\n		}\n\n		// Make sure that we\'re working with the right name\n		var ret, type, hooks,\n			origName = jQuery.camelCase( name ),\n			style = elem.style;\n\n		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n		// Gets hook for the prefixed version, then unprefixed version\n		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n		// Check if we\'re setting a value\n		if ( value !== undefined ) {\n			type = typeof value;\n\n			// Convert "+=" or "-=" to relative numbers (#7345)\n			if ( type === "string" && (ret = rrelNum.exec( value )) ) {\n				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n				// Fixes bug #9237\n				type = "number";\n			}\n\n			// Make sure that null and NaN values aren\'t set (#7116)\n			if ( value == null || value !== value ) {\n				return;\n			}\n\n			// If a number, add \'px\' to the (except for certain CSS properties)\n			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {\n				value += "px";\n			}\n\n			// Support: IE9-11+\n			// background-* props affect original clone\'s values\n			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {\n				style[ name ] = "inherit";\n			}\n\n			// If a hook was provided, use that value, otherwise just set the specified value\n			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n				style[ name ] = value;\n			}\n\n		} else {\n			// If a hook was provided get the non-computed value from there\n			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n				return ret;\n			}\n\n			// Otherwise just get the value from the style object\n			return style[ name ];\n		}\n	},\n\n	css: function( elem, name, extra, styles ) {\n		var val, num, hooks,\n			origName = jQuery.camelCase( name );\n\n		// Make sure that we\'re working with the right name\n		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n		// Try prefixed name followed by the unprefixed name\n		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n		// If a hook was provided get the computed value from there\n		if ( hooks && "get" in hooks ) {\n			val = hooks.get( elem, true, extra );\n		}\n\n		// Otherwise, if a way to get the computed value exists, use that\n		if ( val === undefined ) {\n			val = curCSS( elem, name, styles );\n		}\n\n		// Convert "normal" to computed value\n		if ( val === "normal" && name in cssNormalTransform ) {\n			val = cssNormalTransform[ name ];\n		}\n\n		// Make numeric if forced or a qualifier was provided and val looks numeric\n		if ( extra === "" || extra ) {\n			num = parseFloat( val );\n			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n		}\n		return val;\n	}\n});\n\njQuery.each([ "height", "width" ], function( i, name ) {\n	jQuery.cssHooks[ name ] = {\n		get: function( elem, computed, extra ) {\n			if ( computed ) {\n\n				// Certain elements can have dimension info if we invisibly show them\n				// but it must have a current display style that would benefit\n				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?\n					jQuery.swap( elem, cssShow, function() {\n						return getWidthOrHeight( elem, name, extra );\n					}) :\n					getWidthOrHeight( elem, name, extra );\n			}\n		},\n\n		set: function( elem, value, extra ) {\n			var styles = extra && getStyles( elem );\n			return setPositiveNumber( elem, value, extra ?\n				augmentWidthOrHeight(\n					elem,\n					name,\n					extra,\n					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",\n					styles\n				) : 0\n			);\n		}\n	};\n});\n\n// Support: Android 2.3\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n	function( elem, computed ) {\n		if ( computed ) {\n			return jQuery.swap( elem, { "display": "inline-block" },\n				curCSS, [ elem, "marginRight" ] );\n		}\n	}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each({\n	margin: "",\n	padding: "",\n	border: "Width"\n}, function( prefix, suffix ) {\n	jQuery.cssHooks[ prefix + suffix ] = {\n		expand: function( value ) {\n			var i = 0,\n				expanded = {},\n\n				// Assumes a single number if not a string\n				parts = typeof value === "string" ? value.split(" ") : [ value ];\n\n			for ( ; i < 4; i++ ) {\n				expanded[ prefix + cssExpand[ i ] + suffix ] =\n					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n			}\n\n			return expanded;\n		}\n	};\n\n	if ( !rmargin.test( prefix ) ) {\n		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n	}\n});\n\njQuery.fn.extend({\n	css: function( name, value ) {\n		return access( this, function( elem, name, value ) {\n			var styles, len,\n				map = {},\n				i = 0;\n\n			if ( jQuery.isArray( name ) ) {\n				styles = getStyles( elem );\n				len = name.length;\n\n				for ( ; i < len; i++ ) {\n					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n				}\n\n				return map;\n			}\n\n			return value !== undefined ?\n				jQuery.style( elem, name, value ) :\n				jQuery.css( elem, name );\n		}, name, value, arguments.length > 1 );\n	},\n	show: function() {\n		return showHide( this, true );\n	},\n	hide: function() {\n		return showHide( this );\n	},\n	toggle: function( state ) {\n		if ( typeof state === "boolean" ) {\n			return state ? this.show() : this.hide();\n		}\n\n		return this.each(function() {\n			if ( isHidden( this ) ) {\n				jQuery( this ).show();\n			} else {\n				jQuery( this ).hide();\n			}\n		});\n	}\n});\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n	return new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n	constructor: Tween,\n	init: function( elem, options, prop, end, easing, unit ) {\n		this.elem = elem;\n		this.prop = prop;\n		this.easing = easing || "swing";\n		this.options = options;\n		this.start = this.now = this.cur();\n		this.end = end;\n		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );\n	},\n	cur: function() {\n		var hooks = Tween.propHooks[ this.prop ];\n\n		return hooks && hooks.get ?\n			hooks.get( this ) :\n			Tween.propHooks._default.get( this );\n	},\n	run: function( percent ) {\n		var eased,\n			hooks = Tween.propHooks[ this.prop ];\n\n		if ( this.options.duration ) {\n			this.pos = eased = jQuery.easing[ this.easing ](\n				percent, this.options.duration * percent, 0, 1, this.options.duration\n			);\n		} else {\n			this.pos = eased = percent;\n		}\n		this.now = ( this.end - this.start ) * eased + this.start;\n\n		if ( this.options.step ) {\n			this.options.step.call( this.elem, this.now, this );\n		}\n\n		if ( hooks && hooks.set ) {\n			hooks.set( this );\n		} else {\n			Tween.propHooks._default.set( this );\n		}\n		return this;\n	}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n	_default: {\n		get: function( tween ) {\n			var result;\n\n			if ( tween.elem[ tween.prop ] != null &&\n				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n				return tween.elem[ tween.prop ];\n			}\n\n			// Passing an empty string as a 3rd parameter to .css will automatically\n			// attempt a parseFloat and fallback to a string if the parse fails.\n			// Simple values such as "10px" are parsed to Float;\n			// complex values such as "rotate(1rad)" are returned as-is.\n			result = jQuery.css( tween.elem, tween.prop, "" );\n			// Empty strings, null, undefined and "auto" are converted to 0.\n			return !result || result === "auto" ? 0 : result;\n		},\n		set: function( tween ) {\n			// Use step hook for back compat.\n			// Use cssHook if its there.\n			// Use .style if available and use plain properties where available.\n			if ( jQuery.fx.step[ tween.prop ] ) {\n				jQuery.fx.step[ tween.prop ]( tween );\n			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n			} else {\n				tween.elem[ tween.prop ] = tween.now;\n			}\n		}\n	}\n};\n\n// Support: IE9\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n	set: function( tween ) {\n		if ( tween.elem.nodeType && tween.elem.parentNode ) {\n			tween.elem[ tween.prop ] = tween.now;\n		}\n	}\n};\n\njQuery.easing = {\n	linear: function( p ) {\n		return p;\n	},\n	swing: function( p ) {\n		return 0.5 - Math.cos( p * Math.PI ) / 2;\n	}\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n	fxNow, timerId,\n	rfxtypes = /^(?:toggle|show|hide)$/,\n	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),\n	rrun = /queueHooks$/,\n	animationPrefilters = [ defaultPrefilter ],\n	tweeners = {\n		"*": [ function( prop, value ) {\n			var tween = this.createTween( prop, value ),\n				target = tween.cur(),\n				parts = rfxnum.exec( value ),\n				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),\n\n				// Starting value computation is required for potential unit mismatches\n				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&\n					rfxnum.exec( jQuery.css( tween.elem, prop ) ),\n				scale = 1,\n				maxIterations = 20;\n\n			if ( start && start[ 3 ] !== unit ) {\n				// Trust units reported by jQuery.css\n				unit = unit || start[ 3 ];\n\n				// Make sure we update the tween properties later on\n				parts = parts || [];\n\n				// Iteratively approximate from a nonzero starting point\n				start = +target || 1;\n\n				do {\n					// If previous iteration zeroed out, double until we get *something*.\n					// Use string for doubling so we don\'t accidentally see scale as unchanged below\n					scale = scale || ".5";\n\n					// Adjust and apply\n					start = start / scale;\n					jQuery.style( tween.elem, prop, start + unit );\n\n				// Update scale, tolerating zero or NaN from tween.cur(),\n				// break the loop if scale is unchanged or perfect, or if we\'ve just had enough\n				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n			}\n\n			// Update tween properties\n			if ( parts ) {\n				start = tween.start = +start || +target || 0;\n				tween.unit = unit;\n				// If a +=/-= token was provided, we\'re doing a relative animation\n				tween.end = parts[ 1 ] ?\n					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n					+parts[ 2 ];\n			}\n\n			return tween;\n		} ]\n	};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n	setTimeout(function() {\n		fxNow = undefined;\n	});\n	return ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n	var which,\n		i = 0,\n		attrs = { height: type };\n\n	// If we include width, step value is 1 to do all cssExpand values,\n	// otherwise step value is 2 to skip over Left and Right\n	includeWidth = includeWidth ? 1 : 0;\n	for ( ; i < 4 ; i += 2 - includeWidth ) {\n		which = cssExpand[ i ];\n		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;\n	}\n\n	if ( includeWidth ) {\n		attrs.opacity = attrs.width = type;\n	}\n\n	return attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n	var tween,\n		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),\n		index = 0,\n		length = collection.length;\n	for ( ; index < length; index++ ) {\n		if ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n			// We\'re done with this property\n			return tween;\n		}\n	}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n	/* jshint validthis: true */\n	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n		anim = this,\n		orig = {},\n		style = elem.style,\n		hidden = elem.nodeType && isHidden( elem ),\n		dataShow = data_priv.get( elem, "fxshow" );\n\n	// Handle queue: false promises\n	if ( !opts.queue ) {\n		hooks = jQuery._queueHooks( elem, "fx" );\n		if ( hooks.unqueued == null ) {\n			hooks.unqueued = 0;\n			oldfire = hooks.empty.fire;\n			hooks.empty.fire = function() {\n				if ( !hooks.unqueued ) {\n					oldfire();\n				}\n			};\n		}\n		hooks.unqueued++;\n\n		anim.always(function() {\n			// Ensure the complete handler is called before this completes\n			anim.always(function() {\n				hooks.unqueued--;\n				if ( !jQuery.queue( elem, "fx" ).length ) {\n					hooks.empty.fire();\n				}\n			});\n		});\n	}\n\n	// Height/width overflow pass\n	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {\n		// Make sure that nothing sneaks out\n		// Record all 3 overflow attributes because IE9-10 do not\n		// change the overflow attribute when overflowX and\n		// overflowY are set to the same value\n		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n		// Set display property to inline-block for height/width\n		// animations on inline elements that are having width/height animated\n		display = jQuery.css( elem, "display" );\n\n		// Test default display if display is currently "none"\n		checkDisplay = display === "none" ?\n			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;\n\n		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {\n			style.display = "inline-block";\n		}\n	}\n\n	if ( opts.overflow ) {\n		style.overflow = "hidden";\n		anim.always(function() {\n			style.overflow = opts.overflow[ 0 ];\n			style.overflowX = opts.overflow[ 1 ];\n			style.overflowY = opts.overflow[ 2 ];\n		});\n	}\n\n	// show/hide pass\n	for ( prop in props ) {\n		value = props[ prop ];\n		if ( rfxtypes.exec( value ) ) {\n			delete props[ prop ];\n			toggle = toggle || value === "toggle";\n			if ( value === ( hidden ? "hide" : "show" ) ) {\n\n				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {\n					hidden = true;\n				} else {\n					continue;\n				}\n			}\n			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n		// Any non-fx value stops us from restoring the original display value\n		} else {\n			display = undefined;\n		}\n	}\n\n	if ( !jQuery.isEmptyObject( orig ) ) {\n		if ( dataShow ) {\n			if ( "hidden" in dataShow ) {\n				hidden = dataShow.hidden;\n			}\n		} else {\n			dataShow = data_priv.access( elem, "fxshow", {} );\n		}\n\n		// Store state if its toggle - enables .stop().toggle() to "reverse"\n		if ( toggle ) {\n			dataShow.hidden = !hidden;\n		}\n		if ( hidden ) {\n			jQuery( elem ).show();\n		} else {\n			anim.done(function() {\n				jQuery( elem ).hide();\n			});\n		}\n		anim.done(function() {\n			var prop;\n\n			data_priv.remove( elem, "fxshow" );\n			for ( prop in orig ) {\n				jQuery.style( elem, prop, orig[ prop ] );\n			}\n		});\n		for ( prop in orig ) {\n			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n			if ( !( prop in dataShow ) ) {\n				dataShow[ prop ] = tween.start;\n				if ( hidden ) {\n					tween.end = tween.start;\n					tween.start = prop === "width" || prop === "height" ? 1 : 0;\n				}\n			}\n		}\n\n	// If this is a noop like .hide().hide(), restore an overwritten display value\n	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {\n		style.display = display;\n	}\n}\n\nfunction propFilter( props, specialEasing ) {\n	var index, name, easing, value, hooks;\n\n	// camelCase, specialEasing and expand cssHook pass\n	for ( index in props ) {\n		name = jQuery.camelCase( index );\n		easing = specialEasing[ name ];\n		value = props[ index ];\n		if ( jQuery.isArray( value ) ) {\n			easing = value[ 1 ];\n			value = props[ index ] = value[ 0 ];\n		}\n\n		if ( index !== name ) {\n			props[ name ] = value;\n			delete props[ index ];\n		}\n\n		hooks = jQuery.cssHooks[ name ];\n		if ( hooks && "expand" in hooks ) {\n			value = hooks.expand( value );\n			delete props[ name ];\n\n			// Not quite $.extend, this won\'t overwrite existing keys.\n			// Reusing \'index\' because we have the correct "name"\n			for ( index in value ) {\n				if ( !( index in props ) ) {\n					props[ index ] = value[ index ];\n					specialEasing[ index ] = easing;\n				}\n			}\n		} else {\n			specialEasing[ name ] = easing;\n		}\n	}\n}\n\nfunction Animation( elem, properties, options ) {\n	var result,\n		stopped,\n		index = 0,\n		length = animationPrefilters.length,\n		deferred = jQuery.Deferred().always( function() {\n			// Don\'t match elem in the :animated selector\n			delete tick.elem;\n		}),\n		tick = function() {\n			if ( stopped ) {\n				return false;\n			}\n			var currentTime = fxNow || createFxNow(),\n				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n				// Support: Android 2.3\n				// Archaic crash bug won\'t allow us to use `1 - ( 0.5 || 0 )` (#12497)\n				temp = remaining / animation.duration || 0,\n				percent = 1 - temp,\n				index = 0,\n				length = animation.tweens.length;\n\n			for ( ; index < length ; index++ ) {\n				animation.tweens[ index ].run( percent );\n			}\n\n			deferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n			if ( percent < 1 && length ) {\n				return remaining;\n			} else {\n				deferred.resolveWith( elem, [ animation ] );\n				return false;\n			}\n		},\n		animation = deferred.promise({\n			elem: elem,\n			props: jQuery.extend( {}, properties ),\n			opts: jQuery.extend( true, { specialEasing: {} }, options ),\n			originalProperties: properties,\n			originalOptions: options,\n			startTime: fxNow || createFxNow(),\n			duration: options.duration,\n			tweens: [],\n			createTween: function( prop, end ) {\n				var tween = jQuery.Tween( elem, animation.opts, prop, end,\n						animation.opts.specialEasing[ prop ] || animation.opts.easing );\n				animation.tweens.push( tween );\n				return tween;\n			},\n			stop: function( gotoEnd ) {\n				var index = 0,\n					// If we are going to the end, we want to run all the tweens\n					// otherwise we skip this part\n					length = gotoEnd ? animation.tweens.length : 0;\n				if ( stopped ) {\n					return this;\n				}\n				stopped = true;\n				for ( ; index < length ; index++ ) {\n					animation.tweens[ index ].run( 1 );\n				}\n\n				// Resolve when we played the last frame; otherwise, reject\n				if ( gotoEnd ) {\n					deferred.resolveWith( elem, [ animation, gotoEnd ] );\n				} else {\n					deferred.rejectWith( elem, [ animation, gotoEnd ] );\n				}\n				return this;\n			}\n		}),\n		props = animation.props;\n\n	propFilter( props, animation.opts.specialEasing );\n\n	for ( ; index < length ; index++ ) {\n		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n		if ( result ) {\n			return result;\n		}\n	}\n\n	jQuery.map( props, createTween, animation );\n\n	if ( jQuery.isFunction( animation.opts.start ) ) {\n		animation.opts.start.call( elem, animation );\n	}\n\n	jQuery.fx.timer(\n		jQuery.extend( tick, {\n			elem: elem,\n			anim: animation,\n			queue: animation.opts.queue\n		})\n	);\n\n	// attach callbacks from options\n	return animation.progress( animation.opts.progress )\n		.done( animation.opts.done, animation.opts.complete )\n		.fail( animation.opts.fail )\n		.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n	tweener: function( props, callback ) {\n		if ( jQuery.isFunction( props ) ) {\n			callback = props;\n			props = [ "*" ];\n		} else {\n			props = props.split(" ");\n		}\n\n		var prop,\n			index = 0,\n			length = props.length;\n\n		for ( ; index < length ; index++ ) {\n			prop = props[ index ];\n			tweeners[ prop ] = tweeners[ prop ] || [];\n			tweeners[ prop ].unshift( callback );\n		}\n	},\n\n	prefilter: function( callback, prepend ) {\n		if ( prepend ) {\n			animationPrefilters.unshift( callback );\n		} else {\n			animationPrefilters.push( callback );\n		}\n	}\n});\n\njQuery.speed = function( speed, easing, fn ) {\n	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {\n		complete: fn || !fn && easing ||\n			jQuery.isFunction( speed ) && speed,\n		duration: speed,\n		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n	};\n\n	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :\n		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n	// Normalize opt.queue - true/undefined/null -> "fx"\n	if ( opt.queue == null || opt.queue === true ) {\n		opt.queue = "fx";\n	}\n\n	// Queueing\n	opt.old = opt.complete;\n\n	opt.complete = function() {\n		if ( jQuery.isFunction( opt.old ) ) {\n			opt.old.call( this );\n		}\n\n		if ( opt.queue ) {\n			jQuery.dequeue( this, opt.queue );\n		}\n	};\n\n	return opt;\n};\n\njQuery.fn.extend({\n	fadeTo: function( speed, to, easing, callback ) {\n\n		// Show any hidden elements after setting opacity to 0\n		return this.filter( isHidden ).css( "opacity", 0 ).show()\n\n			// Animate to the value specified\n			.end().animate({ opacity: to }, speed, easing, callback );\n	},\n	animate: function( prop, speed, easing, callback ) {\n		var empty = jQuery.isEmptyObject( prop ),\n			optall = jQuery.speed( speed, easing, callback ),\n			doAnimation = function() {\n				// Operate on a copy of prop so per-property easing won\'t be lost\n				var anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n				// Empty animations, or finishing resolves immediately\n				if ( empty || data_priv.get( this, "finish" ) ) {\n					anim.stop( true );\n				}\n			};\n			doAnimation.finish = doAnimation;\n\n		return empty || optall.queue === false ?\n			this.each( doAnimation ) :\n			this.queue( optall.queue, doAnimation );\n	},\n	stop: function( type, clearQueue, gotoEnd ) {\n		var stopQueue = function( hooks ) {\n			var stop = hooks.stop;\n			delete hooks.stop;\n			stop( gotoEnd );\n		};\n\n		if ( typeof type !== "string" ) {\n			gotoEnd = clearQueue;\n			clearQueue = type;\n			type = undefined;\n		}\n		if ( clearQueue && type !== false ) {\n			this.queue( type || "fx", [] );\n		}\n\n		return this.each(function() {\n			var dequeue = true,\n				index = type != null && type + "queueHooks",\n				timers = jQuery.timers,\n				data = data_priv.get( this );\n\n			if ( index ) {\n				if ( data[ index ] && data[ index ].stop ) {\n					stopQueue( data[ index ] );\n				}\n			} else {\n				for ( index in data ) {\n					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n						stopQueue( data[ index ] );\n					}\n				}\n			}\n\n			for ( index = timers.length; index--; ) {\n				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n					timers[ index ].anim.stop( gotoEnd );\n					dequeue = false;\n					timers.splice( index, 1 );\n				}\n			}\n\n			// Start the next in the queue if the last step wasn\'t forced.\n			// Timers currently will call their complete callbacks, which\n			// will dequeue but only if they were gotoEnd.\n			if ( dequeue || !gotoEnd ) {\n				jQuery.dequeue( this, type );\n			}\n		});\n	},\n	finish: function( type ) {\n		if ( type !== false ) {\n			type = type || "fx";\n		}\n		return this.each(function() {\n			var index,\n				data = data_priv.get( this ),\n				queue = data[ type + "queue" ],\n				hooks = data[ type + "queueHooks" ],\n				timers = jQuery.timers,\n				length = queue ? queue.length : 0;\n\n			// Enable finishing flag on private data\n			data.finish = true;\n\n			// Empty the queue first\n			jQuery.queue( this, type, [] );\n\n			if ( hooks && hooks.stop ) {\n				hooks.stop.call( this, true );\n			}\n\n			// Look for any active animations, and finish them\n			for ( index = timers.length; index--; ) {\n				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n					timers[ index ].anim.stop( true );\n					timers.splice( index, 1 );\n				}\n			}\n\n			// Look for any animations in the old queue and finish them\n			for ( index = 0; index < length; index++ ) {\n				if ( queue[ index ] && queue[ index ].finish ) {\n					queue[ index ].finish.call( this );\n				}\n			}\n\n			// Turn off finishing flag\n			delete data.finish;\n		});\n	}\n});\n\njQuery.each([ "toggle", "show", "hide" ], function( i, name ) {\n	var cssFn = jQuery.fn[ name ];\n	jQuery.fn[ name ] = function( speed, easing, callback ) {\n		return speed == null || typeof speed === "boolean" ?\n			cssFn.apply( this, arguments ) :\n			this.animate( genFx( name, true ), speed, easing, callback );\n	};\n});\n\n// Generate shortcuts for custom animations\njQuery.each({\n	slideDown: genFx("show"),\n	slideUp: genFx("hide"),\n	slideToggle: genFx("toggle"),\n	fadeIn: { opacity: "show" },\n	fadeOut: { opacity: "hide" },\n	fadeToggle: { opacity: "toggle" }\n}, function( name, props ) {\n	jQuery.fn[ name ] = function( speed, easing, callback ) {\n		return this.animate( props, speed, easing, callback );\n	};\n});\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n	var timer,\n		i = 0,\n		timers = jQuery.timers;\n\n	fxNow = jQuery.now();\n\n	for ( ; i < timers.length; i++ ) {\n		timer = timers[ i ];\n		// Checks the timer has not already been removed\n		if ( !timer() && timers[ i ] === timer ) {\n			timers.splice( i--, 1 );\n		}\n	}\n\n	if ( !timers.length ) {\n		jQuery.fx.stop();\n	}\n	fxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n	jQuery.timers.push( timer );\n	if ( timer() ) {\n		jQuery.fx.start();\n	} else {\n		jQuery.timers.pop();\n	}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n	if ( !timerId ) {\n		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n	}\n};\n\njQuery.fx.stop = function() {\n	clearInterval( timerId );\n	timerId = null;\n};\n\njQuery.fx.speeds = {\n	slow: 600,\n	fast: 200,\n	// Default speed\n	_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n	type = type || "fx";\n\n	return this.queue( type, function( next, hooks ) {\n		var timeout = setTimeout( next, time );\n		hooks.stop = function() {\n			clearTimeout( timeout );\n		};\n	});\n};\n\n\n(function() {\n	var input = document.createElement( "input" ),\n		select = document.createElement( "select" ),\n		opt = select.appendChild( document.createElement( "option" ) );\n\n	input.type = "checkbox";\n\n	// Support: iOS<=5.1, Android<=4.2+\n	// Default value for a checkbox should be "on"\n	support.checkOn = input.value !== "";\n\n	// Support: IE<=11+\n	// Must access selectedIndex to make default options select\n	support.optSelected = opt.selected;\n\n	// Support: Android<=2.3\n	// Options inside disabled selects are incorrectly marked as disabled\n	select.disabled = true;\n	support.optDisabled = !opt.disabled;\n\n	// Support: IE<=11+\n	// An input loses its value after becoming a radio\n	input = document.createElement( "input" );\n	input.value = "t";\n	input.type = "radio";\n	support.radioValue = input.value === "t";\n})();\n\n\nvar nodeHook, boolHook,\n	attrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend({\n	attr: function( name, value ) {\n		return access( this, jQuery.attr, name, value, arguments.length > 1 );\n	},\n\n	removeAttr: function( name ) {\n		return this.each(function() {\n			jQuery.removeAttr( this, name );\n		});\n	}\n});\n\njQuery.extend({\n	attr: function( elem, name, value ) {\n		var hooks, ret,\n			nType = elem.nodeType;\n\n		// don\'t get/set attributes on text, comment and attribute nodes\n		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n			return;\n		}\n\n		// Fallback to prop when attributes are not supported\n		if ( typeof elem.getAttribute === strundefined ) {\n			return jQuery.prop( elem, name, value );\n		}\n\n		// All attributes are lowercase\n		// Grab necessary hook if one is defined\n		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n			name = name.toLowerCase();\n			hooks = jQuery.attrHooks[ name ] ||\n				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n		}\n\n		if ( value !== undefined ) {\n\n			if ( value === null ) {\n				jQuery.removeAttr( elem, name );\n\n			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n				return ret;\n\n			} else {\n				elem.setAttribute( name, value + "" );\n				return value;\n			}\n\n		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n			return ret;\n\n		} else {\n			ret = jQuery.find.attr( elem, name );\n\n			// Non-existent attributes return null, we normalize to undefined\n			return ret == null ?\n				undefined :\n				ret;\n		}\n	},\n\n	removeAttr: function( elem, value ) {\n		var name, propName,\n			i = 0,\n			attrNames = value && value.match( rnotwhite );\n\n		if ( attrNames && elem.nodeType === 1 ) {\n			while ( (name = attrNames[i++]) ) {\n				propName = jQuery.propFix[ name ] || name;\n\n				// Boolean attributes get special treatment (#10870)\n				if ( jQuery.expr.match.bool.test( name ) ) {\n					// Set corresponding property to false\n					elem[ propName ] = false;\n				}\n\n				elem.removeAttribute( name );\n			}\n		}\n	},\n\n	attrHooks: {\n		type: {\n			set: function( elem, value ) {\n				if ( !support.radioValue && value === "radio" &&\n					jQuery.nodeName( elem, "input" ) ) {\n					var val = elem.value;\n					elem.setAttribute( "type", value );\n					if ( val ) {\n						elem.value = val;\n					}\n					return value;\n				}\n			}\n		}\n	}\n});\n\n// Hooks for boolean attributes\nboolHook = {\n	set: function( elem, value, name ) {\n		if ( value === false ) {\n			// Remove boolean attributes when set to false\n			jQuery.removeAttr( elem, name );\n		} else {\n			elem.setAttribute( name, name );\n		}\n		return name;\n	}\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n	var getter = attrHandle[ name ] || jQuery.find.attr;\n\n	attrHandle[ name ] = function( elem, name, isXML ) {\n		var ret, handle;\n		if ( !isXML ) {\n			// Avoid an infinite loop by temporarily removing this function from the getter\n			handle = attrHandle[ name ];\n			attrHandle[ name ] = ret;\n			ret = getter( elem, name, isXML ) != null ?\n				name.toLowerCase() :\n				null;\n			attrHandle[ name ] = handle;\n		}\n		return ret;\n	};\n});\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i;\n\njQuery.fn.extend({\n	prop: function( name, value ) {\n		return access( this, jQuery.prop, name, value, arguments.length > 1 );\n	},\n\n	removeProp: function( name ) {\n		return this.each(function() {\n			delete this[ jQuery.propFix[ name ] || name ];\n		});\n	}\n});\n\njQuery.extend({\n	propFix: {\n		"for": "htmlFor",\n		"class": "className"\n	},\n\n	prop: function( elem, name, value ) {\n		var ret, hooks, notxml,\n			nType = elem.nodeType;\n\n		// Don\'t get/set properties on text, comment and attribute nodes\n		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n			return;\n		}\n\n		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n		if ( notxml ) {\n			// Fix name and attach hooks\n			name = jQuery.propFix[ name ] || name;\n			hooks = jQuery.propHooks[ name ];\n		}\n\n		if ( value !== undefined ) {\n			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n				ret :\n				( elem[ name ] = value );\n\n		} else {\n			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?\n				ret :\n				elem[ name ];\n		}\n	},\n\n	propHooks: {\n		tabIndex: {\n			get: function( elem ) {\n				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n					elem.tabIndex :\n					-1;\n			}\n		}\n	}\n});\n\nif ( !support.optSelected ) {\n	jQuery.propHooks.selected = {\n		get: function( elem ) {\n			var parent = elem.parentNode;\n			if ( parent && parent.parentNode ) {\n				parent.parentNode.selectedIndex;\n			}\n			return null;\n		}\n	};\n}\n\njQuery.each([\n	"tabIndex",\n	"readOnly",\n	"maxLength",\n	"cellSpacing",\n	"cellPadding",\n	"rowSpan",\n	"colSpan",\n	"useMap",\n	"frameBorder",\n	"contentEditable"\n], function() {\n	jQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\njQuery.fn.extend({\n	addClass: function( value ) {\n		var classes, elem, cur, clazz, j, finalValue,\n			proceed = typeof value === "string" && value,\n			i = 0,\n			len = this.length;\n\n		if ( jQuery.isFunction( value ) ) {\n			return this.each(function( j ) {\n				jQuery( this ).addClass( value.call( this, j, this.className ) );\n			});\n		}\n\n		if ( proceed ) {\n			// The disjunction here is for better compressibility (see removeClass)\n			classes = ( value || "" ).match( rnotwhite ) || [];\n\n			for ( ; i < len; i++ ) {\n				elem = this[ i ];\n				cur = elem.nodeType === 1 && ( elem.className ?\n					( " " + elem.className + " " ).replace( rclass, " " ) :\n					" "\n				);\n\n				if ( cur ) {\n					j = 0;\n					while ( (clazz = classes[j++]) ) {\n						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {\n							cur += clazz + " ";\n						}\n					}\n\n					// only assign if different to avoid unneeded rendering.\n					finalValue = jQuery.trim( cur );\n					if ( elem.className !== finalValue ) {\n						elem.className = finalValue;\n					}\n				}\n			}\n		}\n\n		return this;\n	},\n\n	removeClass: function( value ) {\n		var classes, elem, cur, clazz, j, finalValue,\n			proceed = arguments.length === 0 || typeof value === "string" && value,\n			i = 0,\n			len = this.length;\n\n		if ( jQuery.isFunction( value ) ) {\n			return this.each(function( j ) {\n				jQuery( this ).removeClass( value.call( this, j, this.className ) );\n			});\n		}\n		if ( proceed ) {\n			classes = ( value || "" ).match( rnotwhite ) || [];\n\n			for ( ; i < len; i++ ) {\n				elem = this[ i ];\n				// This expression is here for better compressibility (see addClass)\n				cur = elem.nodeType === 1 && ( elem.className ?\n					( " " + elem.className + " " ).replace( rclass, " " ) :\n					""\n				);\n\n				if ( cur ) {\n					j = 0;\n					while ( (clazz = classes[j++]) ) {\n						// Remove *all* instances\n						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {\n							cur = cur.replace( " " + clazz + " ", " " );\n						}\n					}\n\n					// Only assign if different to avoid unneeded rendering.\n					finalValue = value ? jQuery.trim( cur ) : "";\n					if ( elem.className !== finalValue ) {\n						elem.className = finalValue;\n					}\n				}\n			}\n		}\n\n		return this;\n	},\n\n	toggleClass: function( value, stateVal ) {\n		var type = typeof value;\n\n		if ( typeof stateVal === "boolean" && type === "string" ) {\n			return stateVal ? this.addClass( value ) : this.removeClass( value );\n		}\n\n		if ( jQuery.isFunction( value ) ) {\n			return this.each(function( i ) {\n				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n			});\n		}\n\n		return this.each(function() {\n			if ( type === "string" ) {\n				// Toggle individual class names\n				var className,\n					i = 0,\n					self = jQuery( this ),\n					classNames = value.match( rnotwhite ) || [];\n\n				while ( (className = classNames[ i++ ]) ) {\n					// Check each className given, space separated list\n					if ( self.hasClass( className ) ) {\n						self.removeClass( className );\n					} else {\n						self.addClass( className );\n					}\n				}\n\n			// Toggle whole class name\n			} else if ( type === strundefined || type === "boolean" ) {\n				if ( this.className ) {\n					// store className if set\n					data_priv.set( this, "__className__", this.className );\n				}\n\n				// If the element has a class name or if we\'re passed `false`,\n				// then remove the whole classname (if there was one, the above saved it).\n				// Otherwise bring back whatever was previously saved (if anything),\n				// falling back to the empty string if nothing was stored.\n				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";\n			}\n		});\n	},\n\n	hasClass: function( selector ) {\n		var className = " " + selector + " ",\n			i = 0,\n			l = this.length;\n		for ( ; i < l; i++ ) {\n			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {\n				return true;\n			}\n		}\n\n		return false;\n	}\n});\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend({\n	val: function( value ) {\n		var hooks, ret, isFunction,\n			elem = this[0];\n\n		if ( !arguments.length ) {\n			if ( elem ) {\n				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {\n					return ret;\n				}\n\n				ret = elem.value;\n\n				return typeof ret === "string" ?\n					// Handle most common string cases\n					ret.replace(rreturn, "") :\n					// Handle cases where value is null/undef or number\n					ret == null ? "" : ret;\n			}\n\n			return;\n		}\n\n		isFunction = jQuery.isFunction( value );\n\n		return this.each(function( i ) {\n			var val;\n\n			if ( this.nodeType !== 1 ) {\n				return;\n			}\n\n			if ( isFunction ) {\n				val = value.call( this, i, jQuery( this ).val() );\n			} else {\n				val = value;\n			}\n\n			// Treat null/undefined as ""; convert numbers to string\n			if ( val == null ) {\n				val = "";\n\n			} else if ( typeof val === "number" ) {\n				val += "";\n\n			} else if ( jQuery.isArray( val ) ) {\n				val = jQuery.map( val, function( value ) {\n					return value == null ? "" : value + "";\n				});\n			}\n\n			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n			// If set returns undefined, fall back to normal setting\n			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {\n				this.value = val;\n			}\n		});\n	}\n});\n\njQuery.extend({\n	valHooks: {\n		option: {\n			get: function( elem ) {\n				var val = jQuery.find.attr( elem, "value" );\n				return val != null ?\n					val :\n					// Support: IE10-11+\n					// option.text throws exceptions (#14686, #14858)\n					jQuery.trim( jQuery.text( elem ) );\n			}\n		},\n		select: {\n			get: function( elem ) {\n				var value, option,\n					options = elem.options,\n					index = elem.selectedIndex,\n					one = elem.type === "select-one" || index < 0,\n					values = one ? null : [],\n					max = one ? index + 1 : options.length,\n					i = index < 0 ?\n						max :\n						one ? index : 0;\n\n				// Loop through all the selected options\n				for ( ; i < max; i++ ) {\n					option = options[ i ];\n\n					// IE6-9 doesn\'t update selected after form reset (#2551)\n					if ( ( option.selected || i === index ) &&\n							// Don\'t return options that are disabled or in a disabled optgroup\n							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&\n							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {\n\n						// Get the specific value for the option\n						value = jQuery( option ).val();\n\n						// We don\'t need an array for one selects\n						if ( one ) {\n							return value;\n						}\n\n						// Multi-Selects return an array\n						values.push( value );\n					}\n				}\n\n				return values;\n			},\n\n			set: function( elem, value ) {\n				var optionSet, option,\n					options = elem.options,\n					values = jQuery.makeArray( value ),\n					i = options.length;\n\n				while ( i-- ) {\n					option = options[ i ];\n					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {\n						optionSet = true;\n					}\n				}\n\n				// Force browsers to behave consistently when non-matching value is set\n				if ( !optionSet ) {\n					elem.selectedIndex = -1;\n				}\n				return values;\n			}\n		}\n	}\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ "radio", "checkbox" ], function() {\n	jQuery.valHooks[ this ] = {\n		set: function( elem, value ) {\n			if ( jQuery.isArray( value ) ) {\n				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n			}\n		}\n	};\n	if ( !support.checkOn ) {\n		jQuery.valHooks[ this ].get = function( elem ) {\n			return elem.getAttribute("value") === null ? "on" : elem.value;\n		};\n	}\n});\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\njQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +\n	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +\n	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {\n\n	// Handle event binding\n	jQuery.fn[ name ] = function( data, fn ) {\n		return arguments.length > 0 ?\n			this.on( name, null, data, fn ) :\n			this.trigger( name );\n	};\n});\n\njQuery.fn.extend({\n	hover: function( fnOver, fnOut ) {\n		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n	},\n\n	bind: function( types, data, fn ) {\n		return this.on( types, null, data, fn );\n	},\n	unbind: function( types, fn ) {\n		return this.off( types, null, fn );\n	},\n\n	delegate: function( selector, types, data, fn ) {\n		return this.on( types, selector, data, fn );\n	},\n	undelegate: function( selector, types, fn ) {\n		// ( namespace ) or ( selector, types [, fn] )\n		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );\n	}\n});\n\n\nvar nonce = jQuery.now();\n\nvar rquery = (/\\?/);\n\n\n\n// Support: Android 2.3\n// Workaround failure to string-cast null input\njQuery.parseJSON = function( data ) {\n	return JSON.parse( data + "" );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n	var xml, tmp;\n	if ( !data || typeof data !== "string" ) {\n		return null;\n	}\n\n	// Support: IE9\n	try {\n		tmp = new DOMParser();\n		xml = tmp.parseFromString( data, "text/xml" );\n	} catch ( e ) {\n		xml = undefined;\n	}\n\n	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {\n		jQuery.error( "Invalid XML: " + data );\n	}\n	return xml;\n};\n\n\nvar\n	rhash = /#.*$/,\n	rts = /([?&])_=[^&]*/,\n	rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n	// #7653, #8125, #8152: local protocol detection\n	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n	rnoContent = /^(?:GET|HEAD)$/,\n	rprotocol = /^\\/\\//,\n	rurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n	/* Prefilters\n	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n	 * 2) These are called:\n	 *    - BEFORE asking for a transport\n	 *    - AFTER param serialization (s.data is a string if s.processData is true)\n	 * 3) key is the dataType\n	 * 4) the catchall symbol "*" can be used\n	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed\n	 */\n	prefilters = {},\n\n	/* Transports bindings\n	 * 1) key is the dataType\n	 * 2) the catchall symbol "*" can be used\n	 * 3) selection will start with transport dataType and THEN go to "*" if needed\n	 */\n	transports = {},\n\n	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n	allTypes = "*/".concat( "*" ),\n\n	// Document location\n	ajaxLocation = window.location.href,\n\n	// Segment location into parts\n	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n	// dataTypeExpression is optional and defaults to "*"\n	return function( dataTypeExpression, func ) {\n\n		if ( typeof dataTypeExpression !== "string" ) {\n			func = dataTypeExpression;\n			dataTypeExpression = "*";\n		}\n\n		var dataType,\n			i = 0,\n			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n		if ( jQuery.isFunction( func ) ) {\n			// For each dataType in the dataTypeExpression\n			while ( (dataType = dataTypes[i++]) ) {\n				// Prepend if requested\n				if ( dataType[0] === "+" ) {\n					dataType = dataType.slice( 1 ) || "*";\n					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n				// Otherwise append\n				} else {\n					(structure[ dataType ] = structure[ dataType ] || []).push( func );\n				}\n			}\n		}\n	};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n	var inspected = {},\n		seekingTransport = ( structure === transports );\n\n	function inspect( dataType ) {\n		var selected;\n		inspected[ dataType ] = true;\n		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n				options.dataTypes.unshift( dataTypeOrTransport );\n				inspect( dataTypeOrTransport );\n				return false;\n			} else if ( seekingTransport ) {\n				return !( selected = dataTypeOrTransport );\n			}\n		});\n		return selected;\n	}\n\n	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );\n}\n\n// A special extend for ajax options\n// that takes "flat" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n	var key, deep,\n		flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n	for ( key in src ) {\n		if ( src[ key ] !== undefined ) {\n			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n		}\n	}\n	if ( deep ) {\n		jQuery.extend( true, target, deep );\n	}\n\n	return target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n	var ct, type, finalDataType, firstDataType,\n		contents = s.contents,\n		dataTypes = s.dataTypes;\n\n	// Remove auto dataType and get content-type in the process\n	while ( dataTypes[ 0 ] === "*" ) {\n		dataTypes.shift();\n		if ( ct === undefined ) {\n			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");\n		}\n	}\n\n	// Check if we\'re dealing with a known content-type\n	if ( ct ) {\n		for ( type in contents ) {\n			if ( contents[ type ] && contents[ type ].test( ct ) ) {\n				dataTypes.unshift( type );\n				break;\n			}\n		}\n	}\n\n	// Check to see if we have a response for the expected dataType\n	if ( dataTypes[ 0 ] in responses ) {\n		finalDataType = dataTypes[ 0 ];\n	} else {\n		// Try convertible dataTypes\n		for ( type in responses ) {\n			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {\n				finalDataType = type;\n				break;\n			}\n			if ( !firstDataType ) {\n				firstDataType = type;\n			}\n		}\n		// Or just use first one\n		finalDataType = finalDataType || firstDataType;\n	}\n\n	// If we found a dataType\n	// We add the dataType to the list if needed\n	// and return the corresponding response\n	if ( finalDataType ) {\n		if ( finalDataType !== dataTypes[ 0 ] ) {\n			dataTypes.unshift( finalDataType );\n		}\n		return responses[ finalDataType ];\n	}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n	var conv2, current, conv, tmp, prev,\n		converters = {},\n		// Work with a copy of dataTypes in case we need to modify it for conversion\n		dataTypes = s.dataTypes.slice();\n\n	// Create converters map with lowercased keys\n	if ( dataTypes[ 1 ] ) {\n		for ( conv in s.converters ) {\n			converters[ conv.toLowerCase() ] = s.converters[ conv ];\n		}\n	}\n\n	current = dataTypes.shift();\n\n	// Convert to each sequential dataType\n	while ( current ) {\n\n		if ( s.responseFields[ current ] ) {\n			jqXHR[ s.responseFields[ current ] ] = response;\n		}\n\n		// Apply the dataFilter if provided\n		if ( !prev && isSuccess && s.dataFilter ) {\n			response = s.dataFilter( response, s.dataType );\n		}\n\n		prev = current;\n		current = dataTypes.shift();\n\n		if ( current ) {\n\n		// There\'s only work to do if current dataType is non-auto\n			if ( current === "*" ) {\n\n				current = prev;\n\n			// Convert response if prev dataType is non-auto and differs from current\n			} else if ( prev !== "*" && prev !== current ) {\n\n				// Seek a direct converter\n				conv = converters[ prev + " " + current ] || converters[ "* " + current ];\n\n				// If none found, seek a pair\n				if ( !conv ) {\n					for ( conv2 in converters ) {\n\n						// If conv2 outputs current\n						tmp = conv2.split( " " );\n						if ( tmp[ 1 ] === current ) {\n\n							// If prev can be converted to accepted input\n							conv = converters[ prev + " " + tmp[ 0 ] ] ||\n								converters[ "* " + tmp[ 0 ] ];\n							if ( conv ) {\n								// Condense equivalence converters\n								if ( conv === true ) {\n									conv = converters[ conv2 ];\n\n								// Otherwise, insert the intermediate dataType\n								} else if ( converters[ conv2 ] !== true ) {\n									current = tmp[ 0 ];\n									dataTypes.unshift( tmp[ 1 ] );\n								}\n								break;\n							}\n						}\n					}\n				}\n\n				// Apply converter (if not an equivalence)\n				if ( conv !== true ) {\n\n					// Unless errors are allowed to bubble, catch and return them\n					if ( conv && s[ "throws" ] ) {\n						response = conv( response );\n					} else {\n						try {\n							response = conv( response );\n						} catch ( e ) {\n							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };\n						}\n					}\n				}\n			}\n		}\n	}\n\n	return { state: "success", data: response };\n}\n\njQuery.extend({\n\n	// Counter for holding the number of active queries\n	active: 0,\n\n	// Last-Modified header cache for next request\n	lastModified: {},\n	etag: {},\n\n	ajaxSettings: {\n		url: ajaxLocation,\n		type: "GET",\n		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n		global: true,\n		processData: true,\n		async: true,\n		contentType: "application/x-www-form-urlencoded; charset=UTF-8",\n		/*\n		timeout: 0,\n		data: null,\n		dataType: null,\n		username: null,\n		password: null,\n		cache: null,\n		throws: false,\n		traditional: false,\n		headers: {},\n		*/\n\n		accepts: {\n			"*": allTypes,\n			text: "text/plain",\n			html: "text/html",\n			xml: "application/xml, text/xml",\n			json: "application/json, text/javascript"\n		},\n\n		contents: {\n			xml: /xml/,\n			html: /html/,\n			json: /json/\n		},\n\n		responseFields: {\n			xml: "responseXML",\n			text: "responseText",\n			json: "responseJSON"\n		},\n\n		// Data converters\n		// Keys separate source (or catchall "*") and destination types with a single space\n		converters: {\n\n			// Convert anything to text\n			"* text": String,\n\n			// Text to html (true = no transformation)\n			"text html": true,\n\n			// Evaluate text as a json expression\n			"text json": jQuery.parseJSON,\n\n			// Parse text as xml\n			"text xml": jQuery.parseXML\n		},\n\n		// For options that shouldn\'t be deep extended:\n		// you can add your own custom options here if\n		// and when you create one that shouldn\'t be\n		// deep extended (see ajaxExtend)\n		flatOptions: {\n			url: true,\n			context: true\n		}\n	},\n\n	// Creates a full fledged settings object into target\n	// with both ajaxSettings and settings fields.\n	// If target is omitted, writes into ajaxSettings.\n	ajaxSetup: function( target, settings ) {\n		return settings ?\n\n			// Building a settings object\n			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n			// Extending ajaxSettings\n			ajaxExtend( jQuery.ajaxSettings, target );\n	},\n\n	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n	ajaxTransport: addToPrefiltersOrTransports( transports ),\n\n	// Main method\n	ajax: function( url, options ) {\n\n		// If url is an object, simulate pre-1.5 signature\n		if ( typeof url === "object" ) {\n			options = url;\n			url = undefined;\n		}\n\n		// Force options to be an object\n		options = options || {};\n\n		var transport,\n			// URL without anti-cache param\n			cacheURL,\n			// Response headers\n			responseHeadersString,\n			responseHeaders,\n			// timeout handle\n			timeoutTimer,\n			// Cross-domain detection vars\n			parts,\n			// To know if global events are to be dispatched\n			fireGlobals,\n			// Loop variable\n			i,\n			// Create the final options object\n			s = jQuery.ajaxSetup( {}, options ),\n			// Callbacks context\n			callbackContext = s.context || s,\n			// Context for global events is callbackContext if it is a DOM node or jQuery collection\n			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n				jQuery( callbackContext ) :\n				jQuery.event,\n			// Deferreds\n			deferred = jQuery.Deferred(),\n			completeDeferred = jQuery.Callbacks("once memory"),\n			// Status-dependent callbacks\n			statusCode = s.statusCode || {},\n			// Headers (they are sent all at once)\n			requestHeaders = {},\n			requestHeadersNames = {},\n			// The jqXHR state\n			state = 0,\n			// Default abort message\n			strAbort = "canceled",\n			// Fake xhr\n			jqXHR = {\n				readyState: 0,\n\n				// Builds headers hashtable if needed\n				getResponseHeader: function( key ) {\n					var match;\n					if ( state === 2 ) {\n						if ( !responseHeaders ) {\n							responseHeaders = {};\n							while ( (match = rheaders.exec( responseHeadersString )) ) {\n								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n							}\n						}\n						match = responseHeaders[ key.toLowerCase() ];\n					}\n					return match == null ? null : match;\n				},\n\n				// Raw string\n				getAllResponseHeaders: function() {\n					return state === 2 ? responseHeadersString : null;\n				},\n\n				// Caches the header\n				setRequestHeader: function( name, value ) {\n					var lname = name.toLowerCase();\n					if ( !state ) {\n						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n						requestHeaders[ name ] = value;\n					}\n					return this;\n				},\n\n				// Overrides response content-type header\n				overrideMimeType: function( type ) {\n					if ( !state ) {\n						s.mimeType = type;\n					}\n					return this;\n				},\n\n				// Status-dependent callbacks\n				statusCode: function( map ) {\n					var code;\n					if ( map ) {\n						if ( state < 2 ) {\n							for ( code in map ) {\n								// Lazy-add the new callback in a way that preserves old ones\n								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n							}\n						} else {\n							// Execute the appropriate callbacks\n							jqXHR.always( map[ jqXHR.status ] );\n						}\n					}\n					return this;\n				},\n\n				// Cancel the request\n				abort: function( statusText ) {\n					var finalText = statusText || strAbort;\n					if ( transport ) {\n						transport.abort( finalText );\n					}\n					done( 0, finalText );\n					return this;\n				}\n			};\n\n		// Attach deferreds\n		deferred.promise( jqXHR ).complete = completeDeferred.add;\n		jqXHR.success = jqXHR.done;\n		jqXHR.error = jqXHR.fail;\n\n		// Remove hash character (#7531: and string promotion)\n		// Add protocol if not provided (prefilters might expect it)\n		// Handle falsy url in the settings object (#10093: consistency with old signature)\n		// We also use the url parameter if available\n		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )\n			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );\n\n		// Alias method option to type as per ticket #12004\n		s.type = options.method || options.type || s.method || s.type;\n\n		// Extract dataTypes list\n		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];\n\n		// A cross-domain request is in order when we have a protocol:host:port mismatch\n		if ( s.crossDomain == null ) {\n			parts = rurl.exec( s.url.toLowerCase() );\n			s.crossDomain = !!( parts &&\n				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==\n						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )\n			);\n		}\n\n		// Convert data if not already a string\n		if ( s.data && s.processData && typeof s.data !== "string" ) {\n			s.data = jQuery.param( s.data, s.traditional );\n		}\n\n		// Apply prefilters\n		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n		// If request was aborted inside a prefilter, stop there\n		if ( state === 2 ) {\n			return jqXHR;\n		}\n\n		// We can fire global events as of now if asked to\n		// Don\'t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n		fireGlobals = jQuery.event && s.global;\n\n		// Watch for a new set of requests\n		if ( fireGlobals && jQuery.active++ === 0 ) {\n			jQuery.event.trigger("ajaxStart");\n		}\n\n		// Uppercase the type\n		s.type = s.type.toUpperCase();\n\n		// Determine if request has content\n		s.hasContent = !rnoContent.test( s.type );\n\n		// Save the URL in case we\'re toying with the If-Modified-Since\n		// and/or If-None-Match header later on\n		cacheURL = s.url;\n\n		// More options handling for requests with no content\n		if ( !s.hasContent ) {\n\n			// If data is available, append data to url\n			if ( s.data ) {\n				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );\n				// #9682: remove data so that it\'s not used in an eventual retry\n				delete s.data;\n			}\n\n			// Add anti-cache in url if needed\n			if ( s.cache === false ) {\n				s.url = rts.test( cacheURL ) ?\n\n					// If there is already a \'_\' parameter, set its value\n					cacheURL.replace( rts, "$1_=" + nonce++ ) :\n\n					// Otherwise add one to the end\n					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;\n			}\n		}\n\n		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n		if ( s.ifModified ) {\n			if ( jQuery.lastModified[ cacheURL ] ) {\n				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );\n			}\n			if ( jQuery.etag[ cacheURL ] ) {\n				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );\n			}\n		}\n\n		// Set the correct header, if data is being sent\n		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n			jqXHR.setRequestHeader( "Content-Type", s.contentType );\n		}\n\n		// Set the Accepts header for the server, depending on the dataType\n		jqXHR.setRequestHeader(\n			"Accept",\n			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :\n				s.accepts[ "*" ]\n		);\n\n		// Check for headers option\n		for ( i in s.headers ) {\n			jqXHR.setRequestHeader( i, s.headers[ i ] );\n		}\n\n		// Allow custom headers/mimetypes and early abort\n		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n			// Abort if not done already and return\n			return jqXHR.abort();\n		}\n\n		// Aborting is no longer a cancellation\n		strAbort = "abort";\n\n		// Install callbacks on deferreds\n		for ( i in { success: 1, error: 1, complete: 1 } ) {\n			jqXHR[ i ]( s[ i ] );\n		}\n\n		// Get transport\n		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n		// If no transport, we auto-abort\n		if ( !transport ) {\n			done( -1, "No Transport" );\n		} else {\n			jqXHR.readyState = 1;\n\n			// Send global event\n			if ( fireGlobals ) {\n				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );\n			}\n			// Timeout\n			if ( s.async && s.timeout > 0 ) {\n				timeoutTimer = setTimeout(function() {\n					jqXHR.abort("timeout");\n				}, s.timeout );\n			}\n\n			try {\n				state = 1;\n				transport.send( requestHeaders, done );\n			} catch ( e ) {\n				// Propagate exception as error if not done\n				if ( state < 2 ) {\n					done( -1, e );\n				// Simply rethrow otherwise\n				} else {\n					throw e;\n				}\n			}\n		}\n\n		// Callback for when everything is done\n		function done( status, nativeStatusText, responses, headers ) {\n			var isSuccess, success, error, response, modified,\n				statusText = nativeStatusText;\n\n			// Called once\n			if ( state === 2 ) {\n				return;\n			}\n\n			// State is "done" now\n			state = 2;\n\n			// Clear timeout if it exists\n			if ( timeoutTimer ) {\n				clearTimeout( timeoutTimer );\n			}\n\n			// Dereference transport for early garbage collection\n			// (no matter how long the jqXHR object will be used)\n			transport = undefined;\n\n			// Cache response headers\n			responseHeadersString = headers || "";\n\n			// Set readyState\n			jqXHR.readyState = status > 0 ? 4 : 0;\n\n			// Determine if successful\n			isSuccess = status >= 200 && status < 300 || status === 304;\n\n			// Get response data\n			if ( responses ) {\n				response = ajaxHandleResponses( s, jqXHR, responses );\n			}\n\n			// Convert no matter what (that way responseXXX fields are always set)\n			response = ajaxConvert( s, response, jqXHR, isSuccess );\n\n			// If successful, handle type chaining\n			if ( isSuccess ) {\n\n				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n				if ( s.ifModified ) {\n					modified = jqXHR.getResponseHeader("Last-Modified");\n					if ( modified ) {\n						jQuery.lastModified[ cacheURL ] = modified;\n					}\n					modified = jqXHR.getResponseHeader("etag");\n					if ( modified ) {\n						jQuery.etag[ cacheURL ] = modified;\n					}\n				}\n\n				// if no content\n				if ( status === 204 || s.type === "HEAD" ) {\n					statusText = "nocontent";\n\n				// if not modified\n				} else if ( status === 304 ) {\n					statusText = "notmodified";\n\n				// If we have data, let\'s convert it\n				} else {\n					statusText = response.state;\n					success = response.data;\n					error = response.error;\n					isSuccess = !error;\n				}\n			} else {\n				// Extract error from statusText and normalize for non-aborts\n				error = statusText;\n				if ( status || !statusText ) {\n					statusText = "error";\n					if ( status < 0 ) {\n						status = 0;\n					}\n				}\n			}\n\n			// Set data for the fake xhr object\n			jqXHR.status = status;\n			jqXHR.statusText = ( nativeStatusText || statusText ) + "";\n\n			// Success/Error\n			if ( isSuccess ) {\n				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n			} else {\n				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n			}\n\n			// Status-dependent callbacks\n			jqXHR.statusCode( statusCode );\n			statusCode = undefined;\n\n			if ( fireGlobals ) {\n				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",\n					[ jqXHR, s, isSuccess ? success : error ] );\n			}\n\n			// Complete\n			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n			if ( fireGlobals ) {\n				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );\n				// Handle the global AJAX counter\n				if ( !( --jQuery.active ) ) {\n					jQuery.event.trigger("ajaxStop");\n				}\n			}\n		}\n\n		return jqXHR;\n	},\n\n	getJSON: function( url, data, callback ) {\n		return jQuery.get( url, data, callback, "json" );\n	},\n\n	getScript: function( url, callback ) {\n		return jQuery.get( url, undefined, callback, "script" );\n	}\n});\n\njQuery.each( [ "get", "post" ], function( i, method ) {\n	jQuery[ method ] = function( url, data, callback, type ) {\n		// Shift arguments if data argument was omitted\n		if ( jQuery.isFunction( data ) ) {\n			type = type || callback;\n			callback = data;\n			data = undefined;\n		}\n\n		return jQuery.ajax({\n			url: url,\n			type: method,\n			dataType: type,\n			data: data,\n			success: callback\n		});\n	};\n});\n\n\njQuery._evalUrl = function( url ) {\n	return jQuery.ajax({\n		url: url,\n		type: "GET",\n		dataType: "script",\n		async: false,\n		global: false,\n		"throws": true\n	});\n};\n\n\njQuery.fn.extend({\n	wrapAll: function( html ) {\n		var wrap;\n\n		if ( jQuery.isFunction( html ) ) {\n			return this.each(function( i ) {\n				jQuery( this ).wrapAll( html.call(this, i) );\n			});\n		}\n\n		if ( this[ 0 ] ) {\n\n			// The elements to wrap the target around\n			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n			if ( this[ 0 ].parentNode ) {\n				wrap.insertBefore( this[ 0 ] );\n			}\n\n			wrap.map(function() {\n				var elem = this;\n\n				while ( elem.firstElementChild ) {\n					elem = elem.firstElementChild;\n				}\n\n				return elem;\n			}).append( this );\n		}\n\n		return this;\n	},\n\n	wrapInner: function( html ) {\n		if ( jQuery.isFunction( html ) ) {\n			return this.each(function( i ) {\n				jQuery( this ).wrapInner( html.call(this, i) );\n			});\n		}\n\n		return this.each(function() {\n			var self = jQuery( this ),\n				contents = self.contents();\n\n			if ( contents.length ) {\n				contents.wrapAll( html );\n\n			} else {\n				self.append( html );\n			}\n		});\n	},\n\n	wrap: function( html ) {\n		var isFunction = jQuery.isFunction( html );\n\n		return this.each(function( i ) {\n			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n		});\n	},\n\n	unwrap: function() {\n		return this.parent().each(function() {\n			if ( !jQuery.nodeName( this, "body" ) ) {\n				jQuery( this ).replaceWith( this.childNodes );\n			}\n		}).end();\n	}\n});\n\n\njQuery.expr.filters.hidden = function( elem ) {\n	// Support: Opera <= 12.12\n	// Opera reports offsetWidths and offsetHeights less than zero on some elements\n	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n};\njQuery.expr.filters.visible = function( elem ) {\n	return !jQuery.expr.filters.hidden( elem );\n};\n\n\n\n\nvar r20 = /%20/g,\n	rbracket = /\\[\\]$/,\n	rCRLF = /\\r?\\n/g,\n	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n	rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n	var name;\n\n	if ( jQuery.isArray( obj ) ) {\n		// Serialize array item.\n		jQuery.each( obj, function( i, v ) {\n			if ( traditional || rbracket.test( prefix ) ) {\n				// Treat each array item as a scalar.\n				add( prefix, v );\n\n			} else {\n				// Item is non-scalar (array or object), encode its numeric index.\n				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );\n			}\n		});\n\n	} else if ( !traditional && jQuery.type( obj ) === "object" ) {\n		// Serialize object item.\n		for ( name in obj ) {\n			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );\n		}\n\n	} else {\n		// Serialize scalar item.\n		add( prefix, obj );\n	}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n	var prefix,\n		s = [],\n		add = function( key, value ) {\n			// If value is a function, invoke it and return its value\n			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );\n			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );\n		};\n\n	// Set traditional to true for jQuery <= 1.3.2 behavior.\n	if ( traditional === undefined ) {\n		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n	}\n\n	// If an array was passed in, assume that it is an array of form elements.\n	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n		// Serialize the form elements\n		jQuery.each( a, function() {\n			add( this.name, this.value );\n		});\n\n	} else {\n		// If traditional, encode the "old" way (the way 1.3.2 or older\n		// did it), otherwise encode params recursively.\n		for ( prefix in a ) {\n			buildParams( prefix, a[ prefix ], traditional, add );\n		}\n	}\n\n	// Return the resulting serialization\n	return s.join( "&" ).replace( r20, "+" );\n};\n\njQuery.fn.extend({\n	serialize: function() {\n		return jQuery.param( this.serializeArray() );\n	},\n	serializeArray: function() {\n		return this.map(function() {\n			// Can add propHook for "elements" to filter or add form elements\n			var elements = jQuery.prop( this, "elements" );\n			return elements ? jQuery.makeArray( elements ) : this;\n		})\n		.filter(function() {\n			var type = this.type;\n\n			// Use .is( ":disabled" ) so that fieldset[disabled] works\n			return this.name && !jQuery( this ).is( ":disabled" ) &&\n				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n				( this.checked || !rcheckableType.test( type ) );\n		})\n		.map(function( i, elem ) {\n			var val = jQuery( this ).val();\n\n			return val == null ?\n				null :\n				jQuery.isArray( val ) ?\n					jQuery.map( val, function( val ) {\n						return { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n					}) :\n					{ name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n		}).get();\n	}\n});\n\n\njQuery.ajaxSettings.xhr = function() {\n	try {\n		return new XMLHttpRequest();\n	} catch( e ) {}\n};\n\nvar xhrId = 0,\n	xhrCallbacks = {},\n	xhrSuccessStatus = {\n		// file protocol always yields status code 0, assume 200\n		0: 200,\n		// Support: IE9\n		// #1450: sometimes IE returns 1223 when it should be 204\n		1223: 204\n	},\n	xhrSupported = jQuery.ajaxSettings.xhr();\n\n// Support: IE9\n// Open requests must be manually aborted on unload (#5280)\n// See https://support.microsoft.com/kb/2856746 for more info\nif ( window.attachEvent ) {\n	window.attachEvent( "onunload", function() {\n		for ( var key in xhrCallbacks ) {\n			xhrCallbacks[ key ]();\n		}\n	});\n}\n\nsupport.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport(function( options ) {\n	var callback;\n\n	// Cross domain only allowed if supported through XMLHttpRequest\n	if ( support.cors || xhrSupported && !options.crossDomain ) {\n		return {\n			send: function( headers, complete ) {\n				var i,\n					xhr = options.xhr(),\n					id = ++xhrId;\n\n				xhr.open( options.type, options.url, options.async, options.username, options.password );\n\n				// Apply custom fields if provided\n				if ( options.xhrFields ) {\n					for ( i in options.xhrFields ) {\n						xhr[ i ] = options.xhrFields[ i ];\n					}\n				}\n\n				// Override mime type if needed\n				if ( options.mimeType && xhr.overrideMimeType ) {\n					xhr.overrideMimeType( options.mimeType );\n				}\n\n				// X-Requested-With header\n				// For cross-domain requests, seeing as conditions for a preflight are\n				// akin to a jigsaw puzzle, we simply never set it to be sure.\n				// (it can always be set on a per-request basis or even using ajaxSetup)\n				// For same-domain requests, won\'t change header if already provided.\n				if ( !options.crossDomain && !headers["X-Requested-With"] ) {\n					headers["X-Requested-With"] = "XMLHttpRequest";\n				}\n\n				// Set headers\n				for ( i in headers ) {\n					xhr.setRequestHeader( i, headers[ i ] );\n				}\n\n				// Callback\n				callback = function( type ) {\n					return function() {\n						if ( callback ) {\n							delete xhrCallbacks[ id ];\n							callback = xhr.onload = xhr.onerror = null;\n\n							if ( type === "abort" ) {\n								xhr.abort();\n							} else if ( type === "error" ) {\n								complete(\n									// file: protocol always yields status 0; see #8605, #14207\n									xhr.status,\n									xhr.statusText\n								);\n							} else {\n								complete(\n									xhrSuccessStatus[ xhr.status ] || xhr.status,\n									xhr.statusText,\n									// Support: IE9\n									// Accessing binary-data responseText throws an exception\n									// (#11426)\n									typeof xhr.responseText === "string" ? {\n										text: xhr.responseText\n									} : undefined,\n									xhr.getAllResponseHeaders()\n								);\n							}\n						}\n					};\n				};\n\n				// Listen to events\n				xhr.onload = callback();\n				xhr.onerror = callback("error");\n\n				// Create the abort callback\n				callback = xhrCallbacks[ id ] = callback("abort");\n\n				try {\n					// Do send the request (this may raise an exception)\n					xhr.send( options.hasContent && options.data || null );\n				} catch ( e ) {\n					// #14683: Only rethrow if this hasn\'t been notified as an error yet\n					if ( callback ) {\n						throw e;\n					}\n				}\n			},\n\n			abort: function() {\n				if ( callback ) {\n					callback();\n				}\n			}\n		};\n	}\n});\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup({\n	accepts: {\n		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"\n	},\n	contents: {\n		script: /(?:java|ecma)script/\n	},\n	converters: {\n		"text script": function( text ) {\n			jQuery.globalEval( text );\n			return text;\n		}\n	}\n});\n\n// Handle cache\'s special case and crossDomain\njQuery.ajaxPrefilter( "script", function( s ) {\n	if ( s.cache === undefined ) {\n		s.cache = false;\n	}\n	if ( s.crossDomain ) {\n		s.type = "GET";\n	}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( "script", function( s ) {\n	// This transport only deals with cross domain requests\n	if ( s.crossDomain ) {\n		var script, callback;\n		return {\n			send: function( _, complete ) {\n				script = jQuery("<script>").prop({\n					async: true,\n					charset: s.scriptCharset,\n					src: s.url\n				}).on(\n					"load error",\n					callback = function( evt ) {\n						script.remove();\n						callback = null;\n						if ( evt ) {\n							complete( evt.type === "error" ? 404 : 200, evt.type );\n						}\n					}\n				);\n				document.head.appendChild( script[ 0 ] );\n			},\n			abort: function() {\n				if ( callback ) {\n					callback();\n				}\n			}\n		};\n	}\n});\n\n\n\n\nvar oldCallbacks = [],\n	rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n	jsonp: "callback",\n	jsonpCallback: function() {\n		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );\n		this[ callback ] = true;\n		return callback;\n	}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {\n\n	var callbackName, overwritten, responseContainer,\n		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n			"url" :\n			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"\n		);\n\n	// Handle iff the expected data type is "jsonp" or we have a parameter to set\n	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {\n\n		// Get callback name, remembering preexisting value associated with it\n		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n			s.jsonpCallback() :\n			s.jsonpCallback;\n\n		// Insert callback into url or form data\n		if ( jsonProp ) {\n			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );\n		} else if ( s.jsonp !== false ) {\n			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;\n		}\n\n		// Use data converter to retrieve json after script execution\n		s.converters["script json"] = function() {\n			if ( !responseContainer ) {\n				jQuery.error( callbackName + " was not called" );\n			}\n			return responseContainer[ 0 ];\n		};\n\n		// force json dataType\n		s.dataTypes[ 0 ] = "json";\n\n		// Install callback\n		overwritten = window[ callbackName ];\n		window[ callbackName ] = function() {\n			responseContainer = arguments;\n		};\n\n		// Clean-up function (fires after converters)\n		jqXHR.always(function() {\n			// Restore preexisting value\n			window[ callbackName ] = overwritten;\n\n			// Save back as free\n			if ( s[ callbackName ] ) {\n				// make sure that re-using the options doesn\'t screw things around\n				s.jsonpCallback = originalSettings.jsonpCallback;\n\n				// save the callback name for future use\n				oldCallbacks.push( callbackName );\n			}\n\n			// Call if it was a function and we have a response\n			if ( responseContainer && jQuery.isFunction( overwritten ) ) {\n				overwritten( responseContainer[ 0 ] );\n			}\n\n			responseContainer = overwritten = undefined;\n		});\n\n		// Delegate to script\n		return "script";\n	}\n});\n\n\n\n\n// data: string of html\n// context (optional): If specified, the fragment will be created in this context, defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n	if ( !data || typeof data !== "string" ) {\n		return null;\n	}\n	if ( typeof context === "boolean" ) {\n		keepScripts = context;\n		context = false;\n	}\n	context = context || document;\n\n	var parsed = rsingleTag.exec( data ),\n		scripts = !keepScripts && [];\n\n	// Single tag\n	if ( parsed ) {\n		return [ context.createElement( parsed[1] ) ];\n	}\n\n	parsed = jQuery.buildFragment( [ data ], context, scripts );\n\n	if ( scripts && scripts.length ) {\n		jQuery( scripts ).remove();\n	}\n\n	return jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n	if ( typeof url !== "string" && _load ) {\n		return _load.apply( this, arguments );\n	}\n\n	var selector, type, response,\n		self = this,\n		off = url.indexOf(" ");\n\n	if ( off >= 0 ) {\n		selector = jQuery.trim( url.slice( off ) );\n		url = url.slice( 0, off );\n	}\n\n	// If it\'s a function\n	if ( jQuery.isFunction( params ) ) {\n\n		// We assume that it\'s the callback\n		callback = params;\n		params = undefined;\n\n	// Otherwise, build a param string\n	} else if ( params && typeof params === "object" ) {\n		type = "POST";\n	}\n\n	// If we have elements to modify, make the request\n	if ( self.length > 0 ) {\n		jQuery.ajax({\n			url: url,\n\n			// if "type" variable is undefined, then "GET" method will be used\n			type: type,\n			dataType: "html",\n			data: params\n		}).done(function( responseText ) {\n\n			// Save response for use in complete callback\n			response = arguments;\n\n			self.html( selector ?\n\n				// If a selector was specified, locate the right elements in a dummy div\n				// Exclude scripts to avoid IE \'Permission Denied\' errors\n				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n				// Otherwise use the full result\n				responseText );\n\n		}).complete( callback && function( jqXHR, status ) {\n			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n		});\n	}\n\n	return this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {\n	jQuery.fn[ type ] = function( fn ) {\n		return this.on( type, fn );\n	};\n});\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n	return jQuery.grep(jQuery.timers, function( fn ) {\n		return elem === fn.elem;\n	}).length;\n};\n\n\n\n\nvar docElem = window.document.documentElement;\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n	setOffset: function( elem, options, i ) {\n		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n			position = jQuery.css( elem, "position" ),\n			curElem = jQuery( elem ),\n			props = {};\n\n		// Set position first, in-case top/left are set even on static elem\n		if ( position === "static" ) {\n			elem.style.position = "relative";\n		}\n\n		curOffset = curElem.offset();\n		curCSSTop = jQuery.css( elem, "top" );\n		curCSSLeft = jQuery.css( elem, "left" );\n		calculatePosition = ( position === "absolute" || position === "fixed" ) &&\n			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;\n\n		// Need to be able to calculate position if either\n		// top or left is auto and position is either absolute or fixed\n		if ( calculatePosition ) {\n			curPosition = curElem.position();\n			curTop = curPosition.top;\n			curLeft = curPosition.left;\n\n		} else {\n			curTop = parseFloat( curCSSTop ) || 0;\n			curLeft = parseFloat( curCSSLeft ) || 0;\n		}\n\n		if ( jQuery.isFunction( options ) ) {\n			options = options.call( elem, i, curOffset );\n		}\n\n		if ( options.top != null ) {\n			props.top = ( options.top - curOffset.top ) + curTop;\n		}\n		if ( options.left != null ) {\n			props.left = ( options.left - curOffset.left ) + curLeft;\n		}\n\n		if ( "using" in options ) {\n			options.using.call( elem, props );\n\n		} else {\n			curElem.css( props );\n		}\n	}\n};\n\njQuery.fn.extend({\n	offset: function( options ) {\n		if ( arguments.length ) {\n			return options === undefined ?\n				this :\n				this.each(function( i ) {\n					jQuery.offset.setOffset( this, options, i );\n				});\n		}\n\n		var docElem, win,\n			elem = this[ 0 ],\n			box = { top: 0, left: 0 },\n			doc = elem && elem.ownerDocument;\n\n		if ( !doc ) {\n			return;\n		}\n\n		docElem = doc.documentElement;\n\n		// Make sure it\'s not a disconnected DOM node\n		if ( !jQuery.contains( docElem, elem ) ) {\n			return box;\n		}\n\n		// Support: BlackBerry 5, iOS 3 (original iPhone)\n		// If we don\'t have gBCR, just use 0,0 rather than error\n		if ( typeof elem.getBoundingClientRect !== strundefined ) {\n			box = elem.getBoundingClientRect();\n		}\n		win = getWindow( doc );\n		return {\n			top: box.top + win.pageYOffset - docElem.clientTop,\n			left: box.left + win.pageXOffset - docElem.clientLeft\n		};\n	},\n\n	position: function() {\n		if ( !this[ 0 ] ) {\n			return;\n		}\n\n		var offsetParent, offset,\n			elem = this[ 0 ],\n			parentOffset = { top: 0, left: 0 };\n\n		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n		if ( jQuery.css( elem, "position" ) === "fixed" ) {\n			// Assume getBoundingClientRect is there when computed position is fixed\n			offset = elem.getBoundingClientRect();\n\n		} else {\n			// Get *real* offsetParent\n			offsetParent = this.offsetParent();\n\n			// Get correct offsets\n			offset = this.offset();\n			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {\n				parentOffset = offsetParent.offset();\n			}\n\n			// Add offsetParent borders\n			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );\n			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );\n		}\n\n		// Subtract parent offsets and element margins\n		return {\n			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),\n			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )\n		};\n	},\n\n	offsetParent: function() {\n		return this.map(function() {\n			var offsetParent = this.offsetParent || docElem;\n\n			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {\n				offsetParent = offsetParent.offsetParent;\n			}\n\n			return offsetParent || docElem;\n		});\n	}\n});\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {\n	var top = "pageYOffset" === prop;\n\n	jQuery.fn[ method ] = function( val ) {\n		return access( this, function( elem, method, val ) {\n			var win = getWindow( elem );\n\n			if ( val === undefined ) {\n				return win ? win[ prop ] : elem[ method ];\n			}\n\n			if ( win ) {\n				win.scrollTo(\n					!top ? val : window.pageXOffset,\n					top ? val : window.pageYOffset\n				);\n\n			} else {\n				elem[ method ] = val;\n			}\n		}, method, val, arguments.length, null );\n	};\n});\n\n// Support: Safari<7+, Chrome<37+\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ "top", "left" ], function( i, prop ) {\n	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n		function( elem, computed ) {\n			if ( computed ) {\n				computed = curCSS( elem, prop );\n				// If curCSS returns percentage, fallback to offset\n				return rnumnonpx.test( computed ) ?\n					jQuery( elem ).position()[ prop ] + "px" :\n					computed;\n			}\n		}\n	);\n});\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: "height", Width: "width" }, function( name, type ) {\n	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {\n		// Margin is only for outerHeight, outerWidth\n		jQuery.fn[ funcName ] = function( margin, value ) {\n			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),\n				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );\n\n			return access( this, function( elem, type, value ) {\n				var doc;\n\n				if ( jQuery.isWindow( elem ) ) {\n					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n					// isn\'t a whole lot we can do. See pull request at this URL for discussion:\n					// https://github.com/jquery/jquery/pull/764\n					return elem.document.documentElement[ "client" + name ];\n				}\n\n				// Get document width or height\n				if ( elem.nodeType === 9 ) {\n					doc = elem.documentElement;\n\n					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n					// whichever is greatest\n					return Math.max(\n						elem.body[ "scroll" + name ], doc[ "scroll" + name ],\n						elem.body[ "offset" + name ], doc[ "offset" + name ],\n						doc[ "client" + name ]\n					);\n				}\n\n				return value === undefined ?\n					// Get width or height on the element, requesting but not forcing parseFloat\n					jQuery.css( elem, type, extra ) :\n\n					// Set width or height on the element\n					jQuery.style( elem, type, value, extra );\n			}, type, chainable ? margin : undefined, chainable, null );\n		};\n	});\n});\n\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n	return this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n		return jQuery;\n	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n	// Map over jQuery in case of overwrite\n	_jQuery = window.jQuery,\n\n	// Map over the $ in case of overwrite\n	_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n	if ( window.$ === jQuery ) {\n		window.$ = _$;\n	}\n\n	if ( deep && window.jQuery === jQuery ) {\n		window.jQuery = _jQuery;\n	}\n\n	return jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === strundefined ) {\n	window.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jquery/dist/jquery.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/jquery/dist/jquery.js?');
},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.10\n * ©2008-2015 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     DataTables\n * @description Paginate, search and order HTML tables\n * @version     1.10.10\n * @file        jquery.dataTables.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2008-2015 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n\n/*jslint evil: true, undef: true, browser: true */\n/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/\n\n(function( factory ) {\n	\"use strict\";\n\n	if ( true ) {\n		// AMD\n		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function ( $ ) {\n			return factory( $, window, document );\n		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n	}\n	else if ( typeof exports === 'object' ) {\n		// CommonJS\n		module.exports = function (root, $) {\n			if ( ! root ) {\n				// CommonJS environments without a window global must pass a\n				// root. This will give an error otherwise\n				root = window;\n			}\n\n			if ( ! $ ) {\n				$ = typeof window !== 'undefined' ? // jQuery's factory checks for a global window\n					require('jquery') :\n					require('jquery')( root );\n			}\n\n			return factory( $, root, root.document );\n		};\n	}\n	else {\n		// Browser\n		factory( jQuery, window, document );\n	}\n}\n(function( $, window, document, undefined ) {\n	\"use strict\";\n\n	/**\n	 * DataTables is a plug-in for the jQuery Javascript library. It is a highly\n	 * flexible tool, based upon the foundations of progressive enhancement,\n	 * which will add advanced interaction controls to any HTML table. For a\n	 * full list of features please refer to\n	 * [DataTables.net](href=\"http://datatables.net).\n	 *\n	 * Note that the `DataTable` object is not a global variable but is aliased\n	 * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may\n	 * be  accessed.\n	 *\n	 *  @class\n	 *  @param {object} [init={}] Configuration object for DataTables. Options\n	 *    are defined by {@link DataTable.defaults}\n	 *  @requires jQuery 1.7+\n	 *\n	 *  @example\n	 *    // Basic initialisation\n	 *    $(document).ready( function {\n	 *      $('#example').dataTable();\n	 *    } );\n	 *\n	 *  @example\n	 *    // Initialisation with configuration options - in this case, disable\n	 *    // pagination and sorting.\n	 *    $(document).ready( function {\n	 *      $('#example').dataTable( {\n	 *        \"paginate\": false,\n	 *        \"sort\": false\n	 *      } );\n	 *    } );\n	 */\n	var DataTable;\n\n	\n	/*\n	 * It is useful to have variables which are scoped locally so only the\n	 * DataTables functions can access them and they don't leak into global space.\n	 * At the same time these functions are often useful over multiple files in the\n	 * core and API, so we list, or at least document, all variables which are used\n	 * by DataTables as private variables here. This also ensures that there is no\n	 * clashing of variable names and that they can easily referenced for reuse.\n	 */\n	\n	\n	// Defined else where\n	//  _selector_run\n	//  _selector_opts\n	//  _selector_first\n	//  _selector_row_indexes\n	\n	var _ext; // DataTable.ext\n	var _Api; // DataTable.Api\n	var _api_register; // DataTable.Api.register\n	var _api_registerPlural; // DataTable.Api.registerPlural\n	\n	var _re_dic = {};\n	var _re_new_lines = /[\\r\\n]/g;\n	var _re_html = /<.*?>/g;\n	var _re_date_start = /^[\\w\\+\\-]/;\n	var _re_date_end = /[\\w\\+\\-]$/;\n	\n	// Escape regular expression special characters\n	var _re_escape_regex = new RegExp( '(\\\\' + [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\', '$', '^', '-' ].join('|\\\\') + ')', 'g' );\n	\n	// http://en.wikipedia.org/wiki/Foreign_exchange_market\n	// - \\u20BD - Russian ruble.\n	// - \\u20a9 - South Korean Won\n	// - \\u20BA - Turkish Lira\n	// - \\u20B9 - Indian Rupee\n	// - R - Brazil (R$) and South Africa\n	// - fr - Swiss Franc\n	// - kr - Swedish krona, Norwegian krone and Danish krone\n	// - \\u2009 is thin space and \\u202F is narrow no-break space, both used in many\n	//   standards as thousands separators.\n	var _re_formatted_numeric = /[',$£€¥%\\u2009\\u202F\\u20BD\\u20a9\\u20BArfk]/gi;\n	\n	\n	var _empty = function ( d ) {\n		return !d || d === true || d === '-' ? true : false;\n	};\n	\n	\n	var _intVal = function ( s ) {\n		var integer = parseInt( s, 10 );\n		return !isNaN(integer) && isFinite(s) ? integer : null;\n	};\n	\n	// Convert from a formatted number with characters other than `.` as the\n	// decimal place, to a Javascript number\n	var _numToDecimal = function ( num, decimalPoint ) {\n		// Cache created regular expressions for speed as this function is called often\n		if ( ! _re_dic[ decimalPoint ] ) {\n			_re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), 'g' );\n		}\n		return typeof num === 'string' && decimalPoint !== '.' ?\n			num.replace( /\\./g, '' ).replace( _re_dic[ decimalPoint ], '.' ) :\n			num;\n	};\n	\n	\n	var _isNumber = function ( d, decimalPoint, formatted ) {\n		var strType = typeof d === 'string';\n	\n		// If empty return immediately so there must be a number if it is a\n		// formatted string (this stops the string \"k\", or \"kr\", etc being detected\n		// as a formatted number for currency\n		if ( _empty( d ) ) {\n			return true;\n		}\n	\n		if ( decimalPoint && strType ) {\n			d = _numToDecimal( d, decimalPoint );\n		}\n	\n		if ( formatted && strType ) {\n			d = d.replace( _re_formatted_numeric, '' );\n		}\n	\n		return !isNaN( parseFloat(d) ) && isFinite( d );\n	};\n	\n	\n	// A string without HTML in it can be considered to be HTML still\n	var _isHtml = function ( d ) {\n		return _empty( d ) || typeof d === 'string';\n	};\n	\n	\n	var _htmlNumeric = function ( d, decimalPoint, formatted ) {\n		if ( _empty( d ) ) {\n			return true;\n		}\n	\n		var html = _isHtml( d );\n		return ! html ?\n			null :\n			_isNumber( _stripHtml( d ), decimalPoint, formatted ) ?\n				true :\n				null;\n	};\n	\n	\n	var _pluck = function ( a, prop, prop2 ) {\n		var out = [];\n		var i=0, ien=a.length;\n	\n		// Could have the test in the loop for slightly smaller code, but speed\n		// is essential here\n		if ( prop2 !== undefined ) {\n			for ( ; i<ien ; i++ ) {\n				if ( a[i] && a[i][ prop ] ) {\n					out.push( a[i][ prop ][ prop2 ] );\n				}\n			}\n		}\n		else {\n			for ( ; i<ien ; i++ ) {\n				if ( a[i] ) {\n					out.push( a[i][ prop ] );\n				}\n			}\n		}\n	\n		return out;\n	};\n	\n	\n	// Basically the same as _pluck, but rather than looping over `a` we use `order`\n	// as the indexes to pick from `a`\n	var _pluck_order = function ( a, order, prop, prop2 )\n	{\n		var out = [];\n		var i=0, ien=order.length;\n	\n		// Could have the test in the loop for slightly smaller code, but speed\n		// is essential here\n		if ( prop2 !== undefined ) {\n			for ( ; i<ien ; i++ ) {\n				if ( a[ order[i] ][ prop ] ) {\n					out.push( a[ order[i] ][ prop ][ prop2 ] );\n				}\n			}\n		}\n		else {\n			for ( ; i<ien ; i++ ) {\n				out.push( a[ order[i] ][ prop ] );\n			}\n		}\n	\n		return out;\n	};\n	\n	\n	var _range = function ( len, start )\n	{\n		var out = [];\n		var end;\n	\n		if ( start === undefined ) {\n			start = 0;\n			end = len;\n		}\n		else {\n			end = start;\n			start = len;\n		}\n	\n		for ( var i=start ; i<end ; i++ ) {\n			out.push( i );\n		}\n	\n		return out;\n	};\n	\n	\n	var _removeEmpty = function ( a )\n	{\n		var out = [];\n	\n		for ( var i=0, ien=a.length ; i<ien ; i++ ) {\n			if ( a[i] ) { // careful - will remove all falsy values!\n				out.push( a[i] );\n			}\n		}\n	\n		return out;\n	};\n	\n	\n	var _stripHtml = function ( d ) {\n		return d.replace( _re_html, '' );\n	};\n	\n	\n	/**\n	 * Find the unique elements in a source array.\n	 *\n	 * @param  {array} src Source array\n	 * @return {array} Array of unique items\n	 * @ignore\n	 */\n	var _unique = function ( src )\n	{\n		// A faster unique method is to use object keys to identify used values,\n		// but this doesn't work with arrays or objects, which we must also\n		// consider. See jsperf.com/compare-array-unique-versions/4 for more\n		// information.\n		var\n			out = [],\n			val,\n			i, ien=src.length,\n			j, k=0;\n	\n		again: for ( i=0 ; i<ien ; i++ ) {\n			val = src[i];\n	\n			for ( j=0 ; j<k ; j++ ) {\n				if ( out[j] === val ) {\n					continue again;\n				}\n			}\n	\n			out.push( val );\n			k++;\n		}\n	\n		return out;\n	};\n	\n	\n	\n	/**\n	 * Create a mapping object that allows camel case parameters to be looked up\n	 * for their Hungarian counterparts. The mapping is stored in a private\n	 * parameter called `_hungarianMap` which can be accessed on the source object.\n	 *  @param {object} o\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnHungarianMap ( o )\n	{\n		var\n			hungarian = 'a aa ai ao as b fn i m o s ',\n			match,\n			newKey,\n			map = {};\n	\n		$.each( o, function (key, val) {\n			match = key.match(/^([^A-Z]+?)([A-Z])/);\n	\n			if ( match && hungarian.indexOf(match[1]+' ') !== -1 )\n			{\n				newKey = key.replace( match[0], match[2].toLowerCase() );\n				map[ newKey ] = key;\n	\n				if ( match[1] === 'o' )\n				{\n					_fnHungarianMap( o[key] );\n				}\n			}\n		} );\n	\n		o._hungarianMap = map;\n	}\n	\n	\n	/**\n	 * Convert from camel case parameters to Hungarian, based on a Hungarian map\n	 * created by _fnHungarianMap.\n	 *  @param {object} src The model object which holds all parameters that can be\n	 *    mapped.\n	 *  @param {object} user The object to convert from camel case to Hungarian.\n	 *  @param {boolean} force When set to `true`, properties which already have a\n	 *    Hungarian value in the `user` object will be overwritten. Otherwise they\n	 *    won't be.\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnCamelToHungarian ( src, user, force )\n	{\n		if ( ! src._hungarianMap ) {\n			_fnHungarianMap( src );\n		}\n	\n		var hungarianKey;\n	\n		$.each( user, function (key, val) {\n			hungarianKey = src._hungarianMap[ key ];\n	\n			if ( hungarianKey !== undefined && (force || user[hungarianKey] === undefined) )\n			{\n				// For objects, we need to buzz down into the object to copy parameters\n				if ( hungarianKey.charAt(0) === 'o' )\n				{\n					// Copy the camelCase options over to the hungarian\n					if ( ! user[ hungarianKey ] ) {\n						user[ hungarianKey ] = {};\n					}\n					$.extend( true, user[hungarianKey], user[key] );\n	\n					_fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );\n				}\n				else {\n					user[hungarianKey] = user[ key ];\n				}\n			}\n		} );\n	}\n	\n	\n	/**\n	 * Language compatibility - when certain options are given, and others aren't, we\n	 * need to duplicate the values over, in order to provide backwards compatibility\n	 * with older language files.\n	 *  @param {object} oSettings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnLanguageCompat( lang )\n	{\n		var defaults = DataTable.defaults.oLanguage;\n		var zeroRecords = lang.sZeroRecords;\n	\n		/* Backwards compatibility - if there is no sEmptyTable given, then use the same as\n		 * sZeroRecords - assuming that is given.\n		 */\n		if ( ! lang.sEmptyTable && zeroRecords &&\n			defaults.sEmptyTable === \"No data available in table\" )\n		{\n			_fnMap( lang, lang, 'sZeroRecords', 'sEmptyTable' );\n		}\n	\n		/* Likewise with loading records */\n		if ( ! lang.sLoadingRecords && zeroRecords &&\n			defaults.sLoadingRecords === \"Loading...\" )\n		{\n			_fnMap( lang, lang, 'sZeroRecords', 'sLoadingRecords' );\n		}\n	\n		// Old parameter name of the thousands separator mapped onto the new\n		if ( lang.sInfoThousands ) {\n			lang.sThousands = lang.sInfoThousands;\n		}\n	\n		var decimal = lang.sDecimal;\n		if ( decimal ) {\n			_addNumericSort( decimal );\n		}\n	}\n	\n	\n	/**\n	 * Map one parameter onto another\n	 *  @param {object} o Object to map\n	 *  @param {*} knew The new parameter name\n	 *  @param {*} old The old parameter name\n	 */\n	var _fnCompatMap = function ( o, knew, old ) {\n		if ( o[ knew ] !== undefined ) {\n			o[ old ] = o[ knew ];\n		}\n	};\n	\n	\n	/**\n	 * Provide backwards compatibility for the main DT options. Note that the new\n	 * options are mapped onto the old parameters, so this is an external interface\n	 * change only.\n	 *  @param {object} init Object to map\n	 */\n	function _fnCompatOpts ( init )\n	{\n		_fnCompatMap( init, 'ordering',      'bSort' );\n		_fnCompatMap( init, 'orderMulti',    'bSortMulti' );\n		_fnCompatMap( init, 'orderClasses',  'bSortClasses' );\n		_fnCompatMap( init, 'orderCellsTop', 'bSortCellsTop' );\n		_fnCompatMap( init, 'order',         'aaSorting' );\n		_fnCompatMap( init, 'orderFixed',    'aaSortingFixed' );\n		_fnCompatMap( init, 'paging',        'bPaginate' );\n		_fnCompatMap( init, 'pagingType',    'sPaginationType' );\n		_fnCompatMap( init, 'pageLength',    'iDisplayLength' );\n		_fnCompatMap( init, 'searching',     'bFilter' );\n	\n		// Boolean initialisation of x-scrolling\n		if ( typeof init.sScrollX === 'boolean' ) {\n			init.sScrollX = init.sScrollX ? '100%' : '';\n		}\n		if ( typeof init.scrollX === 'boolean' ) {\n			init.scrollX = init.scrollX ? '100%' : '';\n		}\n	\n		// Column search objects are in an array, so it needs to be converted\n		// element by element\n		var searchCols = init.aoSearchCols;\n	\n		if ( searchCols ) {\n			for ( var i=0, ien=searchCols.length ; i<ien ; i++ ) {\n				if ( searchCols[i] ) {\n					_fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );\n				}\n			}\n		}\n	}\n	\n	\n	/**\n	 * Provide backwards compatibility for column options. Note that the new options\n	 * are mapped onto the old parameters, so this is an external interface change\n	 * only.\n	 *  @param {object} init Object to map\n	 */\n	function _fnCompatCols ( init )\n	{\n		_fnCompatMap( init, 'orderable',     'bSortable' );\n		_fnCompatMap( init, 'orderData',     'aDataSort' );\n		_fnCompatMap( init, 'orderSequence', 'asSorting' );\n		_fnCompatMap( init, 'orderDataType', 'sortDataType' );\n	\n		// orderData can be given as an integer\n		var dataSort = init.aDataSort;\n		if ( dataSort && ! $.isArray( dataSort ) ) {\n			init.aDataSort = [ dataSort ];\n		}\n	}\n	\n	\n	/**\n	 * Browser feature detection for capabilities, quirks\n	 *  @param {object} settings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnBrowserDetect( settings )\n	{\n		// We don't need to do this every time DataTables is constructed, the values\n		// calculated are specific to the browser and OS configuration which we\n		// don't expect to change between initialisations\n		if ( ! DataTable.__browser ) {\n			var browser = {};\n			DataTable.__browser = browser;\n	\n			// Scrolling feature / quirks detection\n			var n = $('<div/>')\n				.css( {\n					position: 'fixed',\n					top: 0,\n					left: 0,\n					height: 1,\n					width: 1,\n					overflow: 'hidden'\n				} )\n				.append(\n					$('<div/>')\n						.css( {\n							position: 'absolute',\n							top: 1,\n							left: 1,\n							width: 100,\n							overflow: 'scroll'\n						} )\n						.append(\n							$('<div/>')\n								.css( {\n									width: '100%',\n									height: 10\n								} )\n						)\n				)\n				.appendTo( 'body' );\n	\n			var outer = n.children();\n			var inner = outer.children();\n	\n			// Numbers below, in order, are:\n			// inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth\n			//\n			// IE6 XP:                           100 100 100  83\n			// IE7 Vista:                        100 100 100  83\n			// IE 8+ Windows:                     83  83 100  83\n			// Evergreen Windows:                 83  83 100  83\n			// Evergreen Mac with scrollbars:     85  85 100  85\n			// Evergreen Mac without scrollbars: 100 100 100 100\n	\n			// Get scrollbar width\n			browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;\n	\n			// IE6/7 will oversize a width 100% element inside a scrolling element, to\n			// include the width of the scrollbar, while other browsers ensure the inner\n			// element is contained without forcing scrolling\n			browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;\n	\n			// In rtl text layout, some browsers (most, but not all) will place the\n			// scrollbar on the left, rather than the right.\n			browser.bScrollbarLeft = Math.round( inner.offset().left ) !== 1;\n	\n			// IE8- don't provide height and width for getBoundingClientRect\n			browser.bBounding = n[0].getBoundingClientRect().width ? true : false;\n	\n			n.remove();\n		}\n	\n		$.extend( settings.oBrowser, DataTable.__browser );\n		settings.oScroll.iBarWidth = DataTable.__browser.barWidth;\n	}\n	\n	\n	/**\n	 * Array.prototype reduce[Right] method, used for browsers which don't support\n	 * JS 1.6. Done this way to reduce code size, since we iterate either way\n	 *  @param {object} settings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnReduce ( that, fn, init, start, end, inc )\n	{\n		var\n			i = start,\n			value,\n			isSet = false;\n	\n		if ( init !== undefined ) {\n			value = init;\n			isSet = true;\n		}\n	\n		while ( i !== end ) {\n			if ( ! that.hasOwnProperty(i) ) {\n				continue;\n			}\n	\n			value = isSet ?\n				fn( value, that[i], i, that ) :\n				that[i];\n	\n			isSet = true;\n			i += inc;\n		}\n	\n		return value;\n	}\n	\n	/**\n	 * Add a column to the list used for the table with default values\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {node} nTh The th element for this column\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnAddColumn( oSettings, nTh )\n	{\n		// Add column to aoColumns array\n		var oDefaults = DataTable.defaults.column;\n		var iCol = oSettings.aoColumns.length;\n		var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {\n			\"nTh\": nTh ? nTh : document.createElement('th'),\n			\"sTitle\":    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : '',\n			\"aDataSort\": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],\n			\"mData\": oDefaults.mData ? oDefaults.mData : iCol,\n			idx: iCol\n		} );\n		oSettings.aoColumns.push( oCol );\n	\n		// Add search object for column specific search. Note that the `searchCols[ iCol ]`\n		// passed into extend can be undefined. This allows the user to give a default\n		// with only some of the parameters defined, and also not give a default\n		var searchCols = oSettings.aoPreSearchCols;\n		searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );\n	\n		// Use the default column options function to initialise classes etc\n		_fnColumnOptions( oSettings, iCol, $(nTh).data() );\n	}\n	\n	\n	/**\n	 * Apply options for a column\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {int} iCol column index to consider\n	 *  @param {object} oOptions object with sType, bVisible and bSearchable etc\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnColumnOptions( oSettings, iCol, oOptions )\n	{\n		var oCol = oSettings.aoColumns[ iCol ];\n		var oClasses = oSettings.oClasses;\n		var th = $(oCol.nTh);\n	\n		// Try to get width information from the DOM. We can't get it from CSS\n		// as we'd need to parse the CSS stylesheet. `width` option can override\n		if ( ! oCol.sWidthOrig ) {\n			// Width attribute\n			oCol.sWidthOrig = th.attr('width') || null;\n	\n			// Style attribute\n			var t = (th.attr('style') || '').match(/width:\\s*(\\d+[pxem%]+)/);\n			if ( t ) {\n				oCol.sWidthOrig = t[1];\n			}\n		}\n	\n		/* User specified column options */\n		if ( oOptions !== undefined && oOptions !== null )\n		{\n			// Backwards compatibility\n			_fnCompatCols( oOptions );\n	\n			// Map camel case parameters to their Hungarian counterparts\n			_fnCamelToHungarian( DataTable.defaults.column, oOptions );\n	\n			/* Backwards compatibility for mDataProp */\n			if ( oOptions.mDataProp !== undefined && !oOptions.mData )\n			{\n				oOptions.mData = oOptions.mDataProp;\n			}\n	\n			if ( oOptions.sType )\n			{\n				oCol._sManualType = oOptions.sType;\n			}\n	\n			// `class` is a reserved word in Javascript, so we need to provide\n			// the ability to use a valid name for the camel case input\n			if ( oOptions.className && ! oOptions.sClass )\n			{\n				oOptions.sClass = oOptions.className;\n			}\n	\n			$.extend( oCol, oOptions );\n			_fnMap( oCol, oOptions, \"sWidth\", \"sWidthOrig\" );\n	\n			/* iDataSort to be applied (backwards compatibility), but aDataSort will take\n			 * priority if defined\n			 */\n			if ( oOptions.iDataSort !== undefined )\n			{\n				oCol.aDataSort = [ oOptions.iDataSort ];\n			}\n			_fnMap( oCol, oOptions, \"aDataSort\" );\n		}\n	\n		/* Cache the data get and set functions for speed */\n		var mDataSrc = oCol.mData;\n		var mData = _fnGetObjectDataFn( mDataSrc );\n		var mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;\n	\n		var attrTest = function( src ) {\n			return typeof src === 'string' && src.indexOf('@') !== -1;\n		};\n		oCol._bAttrSrc = $.isPlainObject( mDataSrc ) && (\n			attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)\n		);\n	\n		oCol.fnGetData = function (rowData, type, meta) {\n			var innerData = mData( rowData, type, undefined, meta );\n	\n			return mRender && type ?\n				mRender( innerData, type, rowData, meta ) :\n				innerData;\n		};\n		oCol.fnSetData = function ( rowData, val, meta ) {\n			return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );\n		};\n	\n		// Indicate if DataTables should read DOM data as an object or array\n		// Used in _fnGetRowElements\n		if ( typeof mDataSrc !== 'number' ) {\n			oSettings._rowReadObject = true;\n		}\n	\n		/* Feature sorting overrides column specific when off */\n		if ( !oSettings.oFeatures.bSort )\n		{\n			oCol.bSortable = false;\n			th.addClass( oClasses.sSortableNone ); // Have to add class here as order event isn't called\n		}\n	\n		/* Check that the class assignment is correct for sorting */\n		var bAsc = $.inArray('asc', oCol.asSorting) !== -1;\n		var bDesc = $.inArray('desc', oCol.asSorting) !== -1;\n		if ( !oCol.bSortable || (!bAsc && !bDesc) )\n		{\n			oCol.sSortingClass = oClasses.sSortableNone;\n			oCol.sSortingClassJUI = \"\";\n		}\n		else if ( bAsc && !bDesc )\n		{\n			oCol.sSortingClass = oClasses.sSortableAsc;\n			oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;\n		}\n		else if ( !bAsc && bDesc )\n		{\n			oCol.sSortingClass = oClasses.sSortableDesc;\n			oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;\n		}\n		else\n		{\n			oCol.sSortingClass = oClasses.sSortable;\n			oCol.sSortingClassJUI = oClasses.sSortJUI;\n		}\n	}\n	\n	\n	/**\n	 * Adjust the table column widths for new data. Note: you would probably want to\n	 * do a redraw after calling this function!\n	 *  @param {object} settings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnAdjustColumnSizing ( settings )\n	{\n		/* Not interested in doing column width calculation if auto-width is disabled */\n		if ( settings.oFeatures.bAutoWidth !== false )\n		{\n			var columns = settings.aoColumns;\n	\n			_fnCalculateColumnWidths( settings );\n			for ( var i=0 , iLen=columns.length ; i<iLen ; i++ )\n			{\n				columns[i].nTh.style.width = columns[i].sWidth;\n			}\n		}\n	\n		var scroll = settings.oScroll;\n		if ( scroll.sY !== '' || scroll.sX !== '')\n		{\n			_fnScrollDraw( settings );\n		}\n	\n		_fnCallbackFire( settings, null, 'column-sizing', [settings] );\n	}\n	\n	\n	/**\n	 * Covert the index of a visible column to the index in the data array (take account\n	 * of hidden columns)\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {int} iMatch Visible column index to lookup\n	 *  @returns {int} i the data index\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnVisibleToColumnIndex( oSettings, iMatch )\n	{\n		var aiVis = _fnGetColumns( oSettings, 'bVisible' );\n	\n		return typeof aiVis[iMatch] === 'number' ?\n			aiVis[iMatch] :\n			null;\n	}\n	\n	\n	/**\n	 * Covert the index of an index in the data array and convert it to the visible\n	 *   column index (take account of hidden columns)\n	 *  @param {int} iMatch Column index to lookup\n	 *  @param {object} oSettings dataTables settings object\n	 *  @returns {int} i the data index\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnColumnIndexToVisible( oSettings, iMatch )\n	{\n		var aiVis = _fnGetColumns( oSettings, 'bVisible' );\n		var iPos = $.inArray( iMatch, aiVis );\n	\n		return iPos !== -1 ? iPos : null;\n	}\n	\n	\n	/**\n	 * Get the number of visible columns\n	 *  @param {object} oSettings dataTables settings object\n	 *  @returns {int} i the number of visible columns\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnVisbleColumns( oSettings )\n	{\n		return _fnGetColumns( oSettings, 'bVisible' ).length;\n	}\n	\n	\n	/**\n	 * Get an array of column indexes that match a given property\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {string} sParam Parameter in aoColumns to look for - typically\n	 *    bVisible or bSearchable\n	 *  @returns {array} Array of indexes with matched properties\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnGetColumns( oSettings, sParam )\n	{\n		var a = [];\n	\n		$.map( oSettings.aoColumns, function(val, i) {\n			if ( val[sParam] ) {\n				a.push( i );\n			}\n		} );\n	\n		return a;\n	}\n	\n	\n	/**\n	 * Calculate the 'type' of a column\n	 *  @param {object} settings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnColumnTypes ( settings )\n	{\n		var columns = settings.aoColumns;\n		var data = settings.aoData;\n		var types = DataTable.ext.type.detect;\n		var i, ien, j, jen, k, ken;\n		var col, cell, detectedType, cache;\n	\n		// For each column, spin over the \n		for ( i=0, ien=columns.length ; i<ien ; i++ ) {\n			col = columns[i];\n			cache = [];\n	\n			if ( ! col.sType && col._sManualType ) {\n				col.sType = col._sManualType;\n			}\n			else if ( ! col.sType ) {\n				for ( j=0, jen=types.length ; j<jen ; j++ ) {\n					for ( k=0, ken=data.length ; k<ken ; k++ ) {\n						// Use a cache array so we only need to get the type data\n						// from the formatter once (when using multiple detectors)\n						if ( cache[k] === undefined ) {\n							cache[k] = _fnGetCellData( settings, k, i, 'type' );\n						}\n	\n						detectedType = types[j]( cache[k], settings );\n	\n						// If null, then this type can't apply to this column, so\n						// rather than testing all cells, break out. There is an\n						// exception for the last type which is `html`. We need to\n						// scan all rows since it is possible to mix string and HTML\n						// types\n						if ( ! detectedType && j !== types.length-1 ) {\n							break;\n						}\n	\n						// Only a single match is needed for html type since it is\n						// bottom of the pile and very similar to string\n						if ( detectedType === 'html' ) {\n							break;\n						}\n					}\n	\n					// Type is valid for all data points in the column - use this\n					// type\n					if ( detectedType ) {\n						col.sType = detectedType;\n						break;\n					}\n				}\n	\n				// Fall back - if no type was detected, always use string\n				if ( ! col.sType ) {\n					col.sType = 'string';\n				}\n			}\n		}\n	}\n	\n	\n	/**\n	 * Take the column definitions and static columns arrays and calculate how\n	 * they relate to column indexes. The callback function will then apply the\n	 * definition found for a column to a suitable configuration object.\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied\n	 *  @param {array} aoCols The aoColumns array that defines columns individually\n	 *  @param {function} fn Callback function - takes two parameters, the calculated\n	 *    column index and the definition for that column.\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )\n	{\n		var i, iLen, j, jLen, k, kLen, def;\n		var columns = oSettings.aoColumns;\n	\n		// Column definitions with aTargets\n		if ( aoColDefs )\n		{\n			/* Loop over the definitions array - loop in reverse so first instance has priority */\n			for ( i=aoColDefs.length-1 ; i>=0 ; i-- )\n			{\n				def = aoColDefs[i];\n	\n				/* Each definition can target multiple columns, as it is an array */\n				var aTargets = def.targets !== undefined ?\n					def.targets :\n					def.aTargets;\n	\n				if ( ! $.isArray( aTargets ) )\n				{\n					aTargets = [ aTargets ];\n				}\n	\n				for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )\n				{\n					if ( typeof aTargets[j] === 'number' && aTargets[j] >= 0 )\n					{\n						/* Add columns that we don't yet know about */\n						while( columns.length <= aTargets[j] )\n						{\n							_fnAddColumn( oSettings );\n						}\n	\n						/* Integer, basic index */\n						fn( aTargets[j], def );\n					}\n					else if ( typeof aTargets[j] === 'number' && aTargets[j] < 0 )\n					{\n						/* Negative integer, right to left column counting */\n						fn( columns.length+aTargets[j], def );\n					}\n					else if ( typeof aTargets[j] === 'string' )\n					{\n						/* Class name matching on TH element */\n						for ( k=0, kLen=columns.length ; k<kLen ; k++ )\n						{\n							if ( aTargets[j] == \"_all\" ||\n							     $(columns[k].nTh).hasClass( aTargets[j] ) )\n							{\n								fn( k, def );\n							}\n						}\n					}\n				}\n			}\n		}\n	\n		// Statically defined columns array\n		if ( aoCols )\n		{\n			for ( i=0, iLen=aoCols.length ; i<iLen ; i++ )\n			{\n				fn( i, aoCols[i] );\n			}\n		}\n	}\n	\n	/**\n	 * Add a data array to the table, creating DOM node etc. This is the parallel to\n	 * _fnGatherData, but for adding rows from a Javascript source, rather than a\n	 * DOM source.\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {array} aData data array to be added\n	 *  @param {node} [nTr] TR element to add to the table - optional. If not given,\n	 *    DataTables will create a row automatically\n	 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\n	 *    if nTr is.\n	 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnAddData ( oSettings, aDataIn, nTr, anTds )\n	{\n		/* Create the object for storing information about this new row */\n		var iRow = oSettings.aoData.length;\n		var oData = $.extend( true, {}, DataTable.models.oRow, {\n			src: nTr ? 'dom' : 'data',\n			idx: iRow\n		} );\n	\n		oData._aData = aDataIn;\n		oSettings.aoData.push( oData );\n	\n		/* Create the cells */\n		var nTd, sThisType;\n		var columns = oSettings.aoColumns;\n	\n		// Invalidate the column types as the new data needs to be revalidated\n		for ( var i=0, iLen=columns.length ; i<iLen ; i++ )\n		{\n			columns[i].sType = null;\n		}\n	\n		/* Add to the display array */\n		oSettings.aiDisplayMaster.push( iRow );\n	\n		var id = oSettings.rowIdFn( aDataIn );\n		if ( id !== undefined ) {\n			oSettings.aIds[ id ] = oData;\n		}\n	\n		/* Create the DOM information, or register it if already present */\n		if ( nTr || ! oSettings.oFeatures.bDeferRender )\n		{\n			_fnCreateTr( oSettings, iRow, nTr, anTds );\n		}\n	\n		return iRow;\n	}\n	\n	\n	/**\n	 * Add one or more TR elements to the table. Generally we'd expect to\n	 * use this for reading data from a DOM sourced table, but it could be\n	 * used for an TR element. Note that if a TR is given, it is used (i.e.\n	 * it is not cloned).\n	 *  @param {object} settings dataTables settings object\n	 *  @param {array|node|jQuery} trs The TR element(s) to add to the table\n	 *  @returns {array} Array of indexes for the added rows\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnAddTr( settings, trs )\n	{\n		var row;\n	\n		// Allow an individual node to be passed in\n		if ( ! (trs instanceof $) ) {\n			trs = $(trs);\n		}\n	\n		return trs.map( function (i, el) {\n			row = _fnGetRowElements( settings, el );\n			return _fnAddData( settings, row.data, el, row.cells );\n		} );\n	}\n	\n	\n	/**\n	 * Take a TR element and convert it to an index in aoData\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {node} n the TR element to find\n	 *  @returns {int} index if the node is found, null if not\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnNodeToDataIndex( oSettings, n )\n	{\n		return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;\n	}\n	\n	\n	/**\n	 * Take a TD element and convert it into a column data index (not the visible index)\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {int} iRow The row number the TD/TH can be found in\n	 *  @param {node} n The TD/TH element to find\n	 *  @returns {int} index if the node is found, -1 if not\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnNodeToColumnIndex( oSettings, iRow, n )\n	{\n		return $.inArray( n, oSettings.aoData[ iRow ].anCells );\n	}\n	\n	\n	/**\n	 * Get the data for a given cell from the internal cache, taking into account data mapping\n	 *  @param {object} settings dataTables settings object\n	 *  @param {int} rowIdx aoData row id\n	 *  @param {int} colIdx Column index\n	 *  @param {string} type data get type ('display', 'type' 'filter' 'sort')\n	 *  @returns {*} Cell data\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnGetCellData( settings, rowIdx, colIdx, type )\n	{\n		var draw           = settings.iDraw;\n		var col            = settings.aoColumns[colIdx];\n		var rowData        = settings.aoData[rowIdx]._aData;\n		var defaultContent = col.sDefaultContent;\n		var cellData       = col.fnGetData( rowData, type, {\n			settings: settings,\n			row:      rowIdx,\n			col:      colIdx\n		} );\n	\n		if ( cellData === undefined ) {\n			if ( settings.iDrawError != draw && defaultContent === null ) {\n				_fnLog( settings, 0, \"Requested unknown parameter \"+\n					(typeof col.mData=='function' ? '{function}' : \"'\"+col.mData+\"'\")+\n					\" for row \"+rowIdx+\", column \"+colIdx, 4 );\n				settings.iDrawError = draw;\n			}\n			return defaultContent;\n		}\n	\n		/* When the data source is null, we can use default column data */\n		if ( (cellData === rowData || cellData === null) && defaultContent !== null ) {\n			cellData = defaultContent;\n		}\n		else if ( typeof cellData === 'function' ) {\n			// If the data source is a function, then we run it and use the return,\n			// executing in the scope of the data object (for instances)\n			return cellData.call( rowData );\n		}\n	\n		if ( cellData === null && type == 'display' ) {\n			return '';\n		}\n		return cellData;\n	}\n	\n	\n	/**\n	 * Set the value for a specific cell, into the internal data cache\n	 *  @param {object} settings dataTables settings object\n	 *  @param {int} rowIdx aoData row id\n	 *  @param {int} colIdx Column index\n	 *  @param {*} val Value to set\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnSetCellData( settings, rowIdx, colIdx, val )\n	{\n		var col     = settings.aoColumns[colIdx];\n		var rowData = settings.aoData[rowIdx]._aData;\n	\n		col.fnSetData( rowData, val, {\n			settings: settings,\n			row:      rowIdx,\n			col:      colIdx\n		}  );\n	}\n	\n	\n	// Private variable that is used to match action syntax in the data property object\n	var __reArray = /\\[.*?\\]$/;\n	var __reFn = /\\(\\)$/;\n	\n	/**\n	 * Split string on periods, taking into account escaped periods\n	 * @param  {string} str String to split\n	 * @return {array} Split string\n	 */\n	function _fnSplitObjNotation( str )\n	{\n		return $.map( str.match(/(\\\\.|[^\\.])+/g) || [''], function ( s ) {\n			return s.replace(/\\\\./g, '.');\n		} );\n	}\n	\n	\n	/**\n	 * Return a function that can be used to get data from a source object, taking\n	 * into account the ability to use nested objects as a source\n	 *  @param {string|int|function} mSource The data source for the object\n	 *  @returns {function} Data get function\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnGetObjectDataFn( mSource )\n	{\n		if ( $.isPlainObject( mSource ) )\n		{\n			/* Build an object of get functions, and wrap them in a single call */\n			var o = {};\n			$.each( mSource, function (key, val) {\n				if ( val ) {\n					o[key] = _fnGetObjectDataFn( val );\n				}\n			} );\n	\n			return function (data, type, row, meta) {\n				var t = o[type] || o._;\n				return t !== undefined ?\n					t(data, type, row, meta) :\n					data;\n			};\n		}\n		else if ( mSource === null )\n		{\n			/* Give an empty string for rendering / sorting etc */\n			return function (data) { // type, row and meta also passed, but not used\n				return data;\n			};\n		}\n		else if ( typeof mSource === 'function' )\n		{\n			return function (data, type, row, meta) {\n				return mSource( data, type, row, meta );\n			};\n		}\n		else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||\n			      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )\n		{\n			/* If there is a . in the source string then the data source is in a\n			 * nested object so we loop over the data for each level to get the next\n			 * level down. On each loop we test for undefined, and if found immediately\n			 * return. This allows entire objects to be missing and sDefaultContent to\n			 * be used if defined, rather than throwing an error\n			 */\n			var fetchData = function (data, type, src) {\n				var arrayNotation, funcNotation, out, innerSrc;\n	\n				if ( src !== \"\" )\n				{\n					var a = _fnSplitObjNotation( src );\n	\n					for ( var i=0, iLen=a.length ; i<iLen ; i++ )\n					{\n						// Check if we are dealing with special notation\n						arrayNotation = a[i].match(__reArray);\n						funcNotation = a[i].match(__reFn);\n	\n						if ( arrayNotation )\n						{\n							// Array notation\n							a[i] = a[i].replace(__reArray, '');\n	\n							// Condition allows simply [] to be passed in\n							if ( a[i] !== \"\" ) {\n								data = data[ a[i] ];\n							}\n							out = [];\n	\n							// Get the remainder of the nested object to get\n							a.splice( 0, i+1 );\n							innerSrc = a.join('.');\n	\n							// Traverse each entry in the array getting the properties requested\n							if ( $.isArray( data ) ) {\n								for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {\n									out.push( fetchData( data[j], type, innerSrc ) );\n								}\n							}\n	\n							// If a string is given in between the array notation indicators, that\n							// is used to join the strings together, otherwise an array is returned\n							var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);\n							data = (join===\"\") ? out : out.join(join);\n	\n							// The inner call to fetchData has already traversed through the remainder\n							// of the source requested, so we exit from the loop\n							break;\n						}\n						else if ( funcNotation )\n						{\n							// Function call\n							a[i] = a[i].replace(__reFn, '');\n							data = data[ a[i] ]();\n							continue;\n						}\n	\n						if ( data === null || data[ a[i] ] === undefined )\n						{\n							return undefined;\n						}\n						data = data[ a[i] ];\n					}\n				}\n	\n				return data;\n			};\n	\n			return function (data, type) { // row and meta also passed, but not used\n				return fetchData( data, type, mSource );\n			};\n		}\n		else\n		{\n			/* Array or flat object mapping */\n			return function (data, type) { // row and meta also passed, but not used\n				return data[mSource];\n			};\n		}\n	}\n	\n	\n	/**\n	 * Return a function that can be used to set data from a source object, taking\n	 * into account the ability to use nested objects as a source\n	 *  @param {string|int|function} mSource The data source for the object\n	 *  @returns {function} Data set function\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnSetObjectDataFn( mSource )\n	{\n		if ( $.isPlainObject( mSource ) )\n		{\n			/* Unlike get, only the underscore (global) option is used for for\n			 * setting data since we don't know the type here. This is why an object\n			 * option is not documented for `mData` (which is read/write), but it is\n			 * for `mRender` which is read only.\n			 */\n			return _fnSetObjectDataFn( mSource._ );\n		}\n		else if ( mSource === null )\n		{\n			/* Nothing to do when the data source is null */\n			return function () {};\n		}\n		else if ( typeof mSource === 'function' )\n		{\n			return function (data, val, meta) {\n				mSource( data, 'set', val, meta );\n			};\n		}\n		else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||\n			      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )\n		{\n			/* Like the get, we need to get data from a nested object */\n			var setData = function (data, val, src) {\n				var a = _fnSplitObjNotation( src ), b;\n				var aLast = a[a.length-1];\n				var arrayNotation, funcNotation, o, innerSrc;\n	\n				for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ )\n				{\n					// Check if we are dealing with an array notation request\n					arrayNotation = a[i].match(__reArray);\n					funcNotation = a[i].match(__reFn);\n	\n					if ( arrayNotation )\n					{\n						a[i] = a[i].replace(__reArray, '');\n						data[ a[i] ] = [];\n	\n						// Get the remainder of the nested object to set so we can recurse\n						b = a.slice();\n						b.splice( 0, i+1 );\n						innerSrc = b.join('.');\n	\n						// Traverse each entry in the array setting the properties requested\n						if ( $.isArray( val ) )\n						{\n							for ( var j=0, jLen=val.length ; j<jLen ; j++ )\n							{\n								o = {};\n								setData( o, val[j], innerSrc );\n								data[ a[i] ].push( o );\n							}\n						}\n						else\n						{\n							// We've been asked to save data to an array, but it\n							// isn't array data to be saved. Best that can be done\n							// is to just save the value.\n							data[ a[i] ] = val;\n						}\n	\n						// The inner call to setData has already traversed through the remainder\n						// of the source and has set the data, thus we can exit here\n						return;\n					}\n					else if ( funcNotation )\n					{\n						// Function call\n						a[i] = a[i].replace(__reFn, '');\n						data = data[ a[i] ]( val );\n					}\n	\n					// If the nested object doesn't currently exist - since we are\n					// trying to set the value - create it\n					if ( data[ a[i] ] === null || data[ a[i] ] === undefined )\n					{\n						data[ a[i] ] = {};\n					}\n					data = data[ a[i] ];\n				}\n	\n				// Last item in the input - i.e, the actual set\n				if ( aLast.match(__reFn ) )\n				{\n					// Function call\n					data = data[ aLast.replace(__reFn, '') ]( val );\n				}\n				else\n				{\n					// If array notation is used, we just want to strip it and use the property name\n					// and assign the value. If it isn't used, then we get the result we want anyway\n					data[ aLast.replace(__reArray, '') ] = val;\n				}\n			};\n	\n			return function (data, val) { // meta is also passed in, but not used\n				return setData( data, val, mSource );\n			};\n		}\n		else\n		{\n			/* Array or flat object mapping */\n			return function (data, val) { // meta is also passed in, but not used\n				data[mSource] = val;\n			};\n		}\n	}\n	\n	\n	/**\n	 * Return an array with the full table data\n	 *  @param {object} oSettings dataTables settings object\n	 *  @returns array {array} aData Master data array\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnGetDataMaster ( settings )\n	{\n		return _pluck( settings.aoData, '_aData' );\n	}\n	\n	\n	/**\n	 * Nuke the table\n	 *  @param {object} oSettings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnClearTable( settings )\n	{\n		settings.aoData.length = 0;\n		settings.aiDisplayMaster.length = 0;\n		settings.aiDisplay.length = 0;\n		settings.aIds = {};\n	}\n	\n	\n	 /**\n	 * Take an array of integers (index array) and remove a target integer (value - not\n	 * the key!)\n	 *  @param {array} a Index array to target\n	 *  @param {int} iTarget value to find\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnDeleteIndex( a, iTarget, splice )\n	{\n		var iTargetIndex = -1;\n	\n		for ( var i=0, iLen=a.length ; i<iLen ; i++ )\n		{\n			if ( a[i] == iTarget )\n			{\n				iTargetIndex = i;\n			}\n			else if ( a[i] > iTarget )\n			{\n				a[i]--;\n			}\n		}\n	\n		if ( iTargetIndex != -1 && splice === undefined )\n		{\n			a.splice( iTargetIndex, 1 );\n		}\n	}\n	\n	\n	/**\n	 * Mark cached data as invalid such that a re-read of the data will occur when\n	 * the cached data is next requested. Also update from the data source object.\n	 *\n	 * @param {object} settings DataTables settings object\n	 * @param {int}    rowIdx   Row index to invalidate\n	 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'\n	 *     or 'data'\n	 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole\n	 *     row will be invalidated\n	 * @memberof DataTable#oApi\n	 *\n	 * @todo For the modularisation of v1.11 this will need to become a callback, so\n	 *   the sort and filter methods can subscribe to it. That will required\n	 *   initialisation options for sorting, which is why it is not already baked in\n	 */\n	function _fnInvalidate( settings, rowIdx, src, colIdx )\n	{\n		var row = settings.aoData[ rowIdx ];\n		var i, ien;\n		var cellWrite = function ( cell, col ) {\n			// This is very frustrating, but in IE if you just write directly\n			// to innerHTML, and elements that are overwritten are GC'ed,\n			// even if there is a reference to them elsewhere\n			while ( cell.childNodes.length ) {\n				cell.removeChild( cell.firstChild );\n			}\n	\n			cell.innerHTML = _fnGetCellData( settings, rowIdx, col, 'display' );\n		};\n	\n		// Are we reading last data from DOM or the data object?\n		if ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {\n			// Read the data from the DOM\n			row._aData = _fnGetRowElements(\n					settings, row, colIdx, colIdx === undefined ? undefined : row._aData\n				)\n				.data;\n		}\n		else {\n			// Reading from data object, update the DOM\n			var cells = row.anCells;\n	\n			if ( cells ) {\n				if ( colIdx !== undefined ) {\n					cellWrite( cells[colIdx], colIdx );\n				}\n				else {\n					for ( i=0, ien=cells.length ; i<ien ; i++ ) {\n						cellWrite( cells[i], i );\n					}\n				}\n			}\n		}\n	\n		// For both row and cell invalidation, the cached data for sorting and\n		// filtering is nulled out\n		row._aSortData = null;\n		row._aFilterData = null;\n	\n		// Invalidate the type for a specific column (if given) or all columns since\n		// the data might have changed\n		var cols = settings.aoColumns;\n		if ( colIdx !== undefined ) {\n			cols[ colIdx ].sType = null;\n		}\n		else {\n			for ( i=0, ien=cols.length ; i<ien ; i++ ) {\n				cols[i].sType = null;\n			}\n	\n			// Update DataTables special `DT_*` attributes for the row\n			_fnRowAttributes( settings, row );\n		}\n	}\n	\n	\n	/**\n	 * Build a data source object from an HTML row, reading the contents of the\n	 * cells that are in the row.\n	 *\n	 * @param {object} settings DataTables settings object\n	 * @param {node|object} TR element from which to read data or existing row\n	 *   object from which to re-read the data from the cells\n	 * @param {int} [colIdx] Optional column index\n	 * @param {array|object} [d] Data source object. If `colIdx` is given then this\n	 *   parameter should also be given and will be used to write the data into.\n	 *   Only the column in question will be written\n	 * @returns {object} Object with two parameters: `data` the data read, in\n	 *   document order, and `cells` and array of nodes (they can be useful to the\n	 *   caller, so rather than needing a second traversal to get them, just return\n	 *   them from here).\n	 * @memberof DataTable#oApi\n	 */\n	function _fnGetRowElements( settings, row, colIdx, d )\n	{\n		var\n			tds = [],\n			td = row.firstChild,\n			name, col, o, i=0, contents,\n			columns = settings.aoColumns,\n			objectRead = settings._rowReadObject;\n	\n		// Allow the data object to be passed in, or construct\n		d = d !== undefined ?\n			d :\n			objectRead ?\n				{} :\n				[];\n	\n		var attr = function ( str, td  ) {\n			if ( typeof str === 'string' ) {\n				var idx = str.indexOf('@');\n	\n				if ( idx !== -1 ) {\n					var attr = str.substring( idx+1 );\n					var setter = _fnSetObjectDataFn( str );\n					setter( d, td.getAttribute( attr ) );\n				}\n			}\n		};\n	\n		// Read data from a cell and store into the data object\n		var cellProcess = function ( cell ) {\n			if ( colIdx === undefined || colIdx === i ) {\n				col = columns[i];\n				contents = $.trim(cell.innerHTML);\n	\n				if ( col && col._bAttrSrc ) {\n					var setter = _fnSetObjectDataFn( col.mData._ );\n					setter( d, contents );\n	\n					attr( col.mData.sort, cell );\n					attr( col.mData.type, cell );\n					attr( col.mData.filter, cell );\n				}\n				else {\n					// Depending on the `data` option for the columns the data can\n					// be read to either an object or an array.\n					if ( objectRead ) {\n						if ( ! col._setter ) {\n							// Cache the setter function\n							col._setter = _fnSetObjectDataFn( col.mData );\n						}\n						col._setter( d, contents );\n					}\n					else {\n						d[i] = contents;\n					}\n				}\n			}\n	\n			i++;\n		};\n	\n		if ( td ) {\n			// `tr` element was passed in\n			while ( td ) {\n				name = td.nodeName.toUpperCase();\n	\n				if ( name == \"TD\" || name == \"TH\" ) {\n					cellProcess( td );\n					tds.push( td );\n				}\n	\n				td = td.nextSibling;\n			}\n		}\n		else {\n			// Existing row object passed in\n			tds = row.anCells;\n	\n			for ( var j=0, jen=tds.length ; j<jen ; j++ ) {\n				cellProcess( tds[j] );\n			}\n		}\n	\n		// Read the ID from the DOM if present\n		var rowNode = row.firstChild ? row : row.nTr;\n	\n		if ( rowNode ) {\n			var id = rowNode.getAttribute( 'id' );\n	\n			if ( id ) {\n				_fnSetObjectDataFn( settings.rowId )( d, id );\n			}\n		}\n	\n		return {\n			data: d,\n			cells: tds\n		};\n	}\n	/**\n	 * Create a new TR element (and it's TD children) for a row\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {int} iRow Row to consider\n	 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,\n	 *    DataTables will create a row automatically\n	 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\n	 *    if nTr is.\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )\n	{\n		var\n			row = oSettings.aoData[iRow],\n			rowData = row._aData,\n			cells = [],\n			nTr, nTd, oCol,\n			i, iLen;\n	\n		if ( row.nTr === null )\n		{\n			nTr = nTrIn || document.createElement('tr');\n	\n			row.nTr = nTr;\n			row.anCells = cells;\n	\n			/* Use a private property on the node to allow reserve mapping from the node\n			 * to the aoData array for fast look up\n			 */\n			nTr._DT_RowIndex = iRow;\n	\n			/* Special parameters can be given by the data source to be used on the row */\n			_fnRowAttributes( oSettings, row );\n	\n			/* Process each column */\n			for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )\n			{\n				oCol = oSettings.aoColumns[i];\n	\n				nTd = nTrIn ? anTds[i] : document.createElement( oCol.sCellType );\n				nTd._DT_CellIndex = {\n					row: iRow,\n					column: i\n				};\n				\n				cells.push( nTd );\n	\n				// Need to create the HTML if new, or if a rendering function is defined\n				if ( !nTrIn || oCol.mRender || oCol.mData !== i )\n				{\n					nTd.innerHTML = _fnGetCellData( oSettings, iRow, i, 'display' );\n				}\n	\n				/* Add user defined class */\n				if ( oCol.sClass )\n				{\n					nTd.className += ' '+oCol.sClass;\n				}\n	\n				// Visibility - add or remove as required\n				if ( oCol.bVisible && ! nTrIn )\n				{\n					nTr.appendChild( nTd );\n				}\n				else if ( ! oCol.bVisible && nTrIn )\n				{\n					nTd.parentNode.removeChild( nTd );\n				}\n	\n				if ( oCol.fnCreatedCell )\n				{\n					oCol.fnCreatedCell.call( oSettings.oInstance,\n						nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i\n					);\n				}\n			}\n	\n			_fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow] );\n		}\n	\n		// Remove once webkit bug 131819 and Chromium bug 365619 have been resolved\n		// and deployed\n		row.nTr.setAttribute( 'role', 'row' );\n	}\n	\n	\n	/**\n	 * Add attributes to a row based on the special `DT_*` parameters in a data\n	 * source object.\n	 *  @param {object} settings DataTables settings object\n	 *  @param {object} DataTables row object for the row to be modified\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnRowAttributes( settings, row )\n	{\n		var tr = row.nTr;\n		var data = row._aData;\n	\n		if ( tr ) {\n			var id = settings.rowIdFn( data );\n	\n			if ( id ) {\n				tr.id = id;\n			}\n	\n			if ( data.DT_RowClass ) {\n				// Remove any classes added by DT_RowClass before\n				var a = data.DT_RowClass.split(' ');\n				row.__rowc = row.__rowc ?\n					_unique( row.__rowc.concat( a ) ) :\n					a;\n	\n				$(tr)\n					.removeClass( row.__rowc.join(' ') )\n					.addClass( data.DT_RowClass );\n			}\n	\n			if ( data.DT_RowAttr ) {\n				$(tr).attr( data.DT_RowAttr );\n			}\n	\n			if ( data.DT_RowData ) {\n				$(tr).data( data.DT_RowData );\n			}\n		}\n	}\n	\n	\n	/**\n	 * Create the HTML header for the table\n	 *  @param {object} oSettings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnBuildHead( oSettings )\n	{\n		var i, ien, cell, row, column;\n		var thead = oSettings.nTHead;\n		var tfoot = oSettings.nTFoot;\n		var createHeader = $('th, td', thead).length === 0;\n		var classes = oSettings.oClasses;\n		var columns = oSettings.aoColumns;\n	\n		if ( createHeader ) {\n			row = $('<tr/>').appendTo( thead );\n		}\n	\n		for ( i=0, ien=columns.length ; i<ien ; i++ ) {\n			column = columns[i];\n			cell = $( column.nTh ).addClass( column.sClass );\n	\n			if ( createHeader ) {\n				cell.appendTo( row );\n			}\n	\n			// 1.11 move into sorting\n			if ( oSettings.oFeatures.bSort ) {\n				cell.addClass( column.sSortingClass );\n	\n				if ( column.bSortable !== false ) {\n					cell\n						.attr( 'tabindex', oSettings.iTabIndex )\n						.attr( 'aria-controls', oSettings.sTableId );\n	\n					_fnSortAttachListener( oSettings, column.nTh, i );\n				}\n			}\n	\n			if ( column.sTitle != cell[0].innerHTML ) {\n				cell.html( column.sTitle );\n			}\n	\n			_fnRenderer( oSettings, 'header' )(\n				oSettings, cell, column, classes\n			);\n		}\n	\n		if ( createHeader ) {\n			_fnDetectHeader( oSettings.aoHeader, thead );\n		}\n		\n		/* ARIA role for the rows */\n	 	$(thead).find('>tr').attr('role', 'row');\n	\n		/* Deal with the footer - add classes if required */\n		$(thead).find('>tr>th, >tr>td').addClass( classes.sHeaderTH );\n		$(tfoot).find('>tr>th, >tr>td').addClass( classes.sFooterTH );\n	\n		// Cache the footer cells. Note that we only take the cells from the first\n		// row in the footer. If there is more than one row the user wants to\n		// interact with, they need to use the table().foot() method. Note also this\n		// allows cells to be used for multiple columns using colspan\n		if ( tfoot !== null ) {\n			var cells = oSettings.aoFooter[0];\n	\n			for ( i=0, ien=cells.length ; i<ien ; i++ ) {\n				column = columns[i];\n				column.nTf = cells[i].cell;\n	\n				if ( column.sClass ) {\n					$(column.nTf).addClass( column.sClass );\n				}\n			}\n		}\n	}\n	\n	\n	/**\n	 * Draw the header (or footer) element based on the column visibility states. The\n	 * methodology here is to use the layout array from _fnDetectHeader, modified for\n	 * the instantaneous column visibility, to construct the new layout. The grid is\n	 * traversed over cell at a time in a rows x columns grid fashion, although each\n	 * cell insert can cover multiple elements in the grid - which is tracks using the\n	 * aApplied array. Cell inserts in the grid will only occur where there isn't\n	 * already a cell in that position.\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param array {objects} aoSource Layout array from _fnDetectHeader\n	 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnDrawHead( oSettings, aoSource, bIncludeHidden )\n	{\n		var i, iLen, j, jLen, k, kLen, n, nLocalTr;\n		var aoLocal = [];\n		var aApplied = [];\n		var iColumns = oSettings.aoColumns.length;\n		var iRowspan, iColspan;\n	\n		if ( ! aoSource )\n		{\n			return;\n		}\n	\n		if (  bIncludeHidden === undefined )\n		{\n			bIncludeHidden = false;\n		}\n	\n		/* Make a copy of the master layout array, but without the visible columns in it */\n		for ( i=0, iLen=aoSource.length ; i<iLen ; i++ )\n		{\n			aoLocal[i] = aoSource[i].slice();\n			aoLocal[i].nTr = aoSource[i].nTr;\n	\n			/* Remove any columns which are currently hidden */\n			for ( j=iColumns-1 ; j>=0 ; j-- )\n			{\n				if ( !oSettings.aoColumns[j].bVisible && !bIncludeHidden )\n				{\n					aoLocal[i].splice( j, 1 );\n				}\n			}\n	\n			/* Prep the applied array - it needs an element for each row */\n			aApplied.push( [] );\n		}\n	\n		for ( i=0, iLen=aoLocal.length ; i<iLen ; i++ )\n		{\n			nLocalTr = aoLocal[i].nTr;\n	\n			/* All cells are going to be replaced, so empty out the row */\n			if ( nLocalTr )\n			{\n				while( (n = nLocalTr.firstChild) )\n				{\n					nLocalTr.removeChild( n );\n				}\n			}\n	\n			for ( j=0, jLen=aoLocal[i].length ; j<jLen ; j++ )\n			{\n				iRowspan = 1;\n				iColspan = 1;\n	\n				/* Check to see if there is already a cell (row/colspan) covering our target\n				 * insert point. If there is, then there is nothing to do.\n				 */\n				if ( aApplied[i][j] === undefined )\n				{\n					nLocalTr.appendChild( aoLocal[i][j].cell );\n					aApplied[i][j] = 1;\n	\n					/* Expand the cell to cover as many rows as needed */\n					while ( aoLocal[i+iRowspan] !== undefined &&\n					        aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )\n					{\n						aApplied[i+iRowspan][j] = 1;\n						iRowspan++;\n					}\n	\n					/* Expand the cell to cover as many columns as needed */\n					while ( aoLocal[i][j+iColspan] !== undefined &&\n					        aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )\n					{\n						/* Must update the applied array over the rows for the columns */\n						for ( k=0 ; k<iRowspan ; k++ )\n						{\n							aApplied[i+k][j+iColspan] = 1;\n						}\n						iColspan++;\n					}\n	\n					/* Do the actual expansion in the DOM */\n					$(aoLocal[i][j].cell)\n						.attr('rowspan', iRowspan)\n						.attr('colspan', iColspan);\n				}\n			}\n		}\n	}\n	\n	\n	/**\n	 * Insert the required TR nodes into the table for display\n	 *  @param {object} oSettings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnDraw( oSettings )\n	{\n		/* Provide a pre-callback function which can be used to cancel the draw is false is returned */\n		var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );\n		if ( $.inArray( false, aPreDraw ) !== -1 )\n		{\n			_fnProcessingDisplay( oSettings, false );\n			return;\n		}\n	\n		var i, iLen, n;\n		var anRows = [];\n		var iRowCount = 0;\n		var asStripeClasses = oSettings.asStripeClasses;\n		var iStripes = asStripeClasses.length;\n		var iOpenRows = oSettings.aoOpenRows.length;\n		var oLang = oSettings.oLanguage;\n		var iInitDisplayStart = oSettings.iInitDisplayStart;\n		var bServerSide = _fnDataSource( oSettings ) == 'ssp';\n		var aiDisplay = oSettings.aiDisplay;\n	\n		oSettings.bDrawing = true;\n	\n		/* Check and see if we have an initial draw position from state saving */\n		if ( iInitDisplayStart !== undefined && iInitDisplayStart !== -1 )\n		{\n			oSettings._iDisplayStart = bServerSide ?\n				iInitDisplayStart :\n				iInitDisplayStart >= oSettings.fnRecordsDisplay() ?\n					0 :\n					iInitDisplayStart;\n	\n			oSettings.iInitDisplayStart = -1;\n		}\n	\n		var iDisplayStart = oSettings._iDisplayStart;\n		var iDisplayEnd = oSettings.fnDisplayEnd();\n	\n		/* Server-side processing draw intercept */\n		if ( oSettings.bDeferLoading )\n		{\n			oSettings.bDeferLoading = false;\n			oSettings.iDraw++;\n			_fnProcessingDisplay( oSettings, false );\n		}\n		else if ( !bServerSide )\n		{\n			oSettings.iDraw++;\n		}\n		else if ( !oSettings.bDestroying && !_fnAjaxUpdate( oSettings ) )\n		{\n			return;\n		}\n	\n		if ( aiDisplay.length !== 0 )\n		{\n			var iStart = bServerSide ? 0 : iDisplayStart;\n			var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;\n	\n			for ( var j=iStart ; j<iEnd ; j++ )\n			{\n				var iDataIndex = aiDisplay[j];\n				var aoData = oSettings.aoData[ iDataIndex ];\n				if ( aoData.nTr === null )\n				{\n					_fnCreateTr( oSettings, iDataIndex );\n				}\n	\n				var nRow = aoData.nTr;\n	\n				/* Remove the old striping classes and then add the new one */\n				if ( iStripes !== 0 )\n				{\n					var sStripe = asStripeClasses[ iRowCount % iStripes ];\n					if ( aoData._sRowStripe != sStripe )\n					{\n						$(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );\n						aoData._sRowStripe = sStripe;\n					}\n				}\n	\n				// Row callback functions - might want to manipulate the row\n				// iRowCount and j are not currently documented. Are they at all\n				// useful?\n				_fnCallbackFire( oSettings, 'aoRowCallback', null,\n					[nRow, aoData._aData, iRowCount, j] );\n	\n				anRows.push( nRow );\n				iRowCount++;\n			}\n		}\n		else\n		{\n			/* Table is empty - create a row with an empty message in it */\n			var sZero = oLang.sZeroRecords;\n			if ( oSettings.iDraw == 1 &&  _fnDataSource( oSettings ) == 'ajax' )\n			{\n				sZero = oLang.sLoadingRecords;\n			}\n			else if ( oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0 )\n			{\n				sZero = oLang.sEmptyTable;\n			}\n	\n			anRows[ 0 ] = $( '<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' } )\n				.append( $('<td />', {\n					'valign':  'top',\n					'colSpan': _fnVisbleColumns( oSettings ),\n					'class':   oSettings.oClasses.sRowEmpty\n				} ).html( sZero ) )[0];\n		}\n	\n		/* Header and footer callbacks */\n		_fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],\n			_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );\n	\n		_fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],\n			_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );\n	\n		var body = $(oSettings.nTBody);\n	\n		body.children().detach();\n		body.append( $(anRows) );\n	\n		/* Call all required callback functions for the end of a draw */\n		_fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings] );\n	\n		/* Draw is complete, sorting and filtering must be as well */\n		oSettings.bSorted = false;\n		oSettings.bFiltered = false;\n		oSettings.bDrawing = false;\n	}\n	\n	\n	/**\n	 * Redraw the table - taking account of the various features which are enabled\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {boolean} [holdPosition] Keep the current paging position. By default\n	 *    the paging is reset to the first page\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnReDraw( settings, holdPosition )\n	{\n		var\n			features = settings.oFeatures,\n			sort     = features.bSort,\n			filter   = features.bFilter;\n	\n		if ( sort ) {\n			_fnSort( settings );\n		}\n	\n		if ( filter ) {\n			_fnFilterComplete( settings, settings.oPreviousSearch );\n		}\n		else {\n			// No filtering, so we want to just use the display master\n			settings.aiDisplay = settings.aiDisplayMaster.slice();\n		}\n	\n		if ( holdPosition !== true ) {\n			settings._iDisplayStart = 0;\n		}\n	\n		// Let any modules know about the draw hold position state (used by\n		// scrolling internally)\n		settings._drawHold = holdPosition;\n	\n		_fnDraw( settings );\n	\n		settings._drawHold = false;\n	}\n	\n	\n	/**\n	 * Add the options to the page HTML for the table\n	 *  @param {object} oSettings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnAddOptionsHtml ( oSettings )\n	{\n		var classes = oSettings.oClasses;\n		var table = $(oSettings.nTable);\n		var holding = $('<div/>').insertBefore( table ); // Holding element for speed\n		var features = oSettings.oFeatures;\n	\n		// All DataTables are wrapped in a div\n		var insert = $('<div/>', {\n			id:      oSettings.sTableId+'_wrapper',\n			'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' '+classes.sNoFooter)\n		} );\n	\n		oSettings.nHolding = holding[0];\n		oSettings.nTableWrapper = insert[0];\n		oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;\n	\n		/* Loop over the user set positioning and place the elements as needed */\n		var aDom = oSettings.sDom.split('');\n		var featureNode, cOption, nNewNode, cNext, sAttr, j;\n		for ( var i=0 ; i<aDom.length ; i++ )\n		{\n			featureNode = null;\n			cOption = aDom[i];\n	\n			if ( cOption == '<' )\n			{\n				/* New container div */\n				nNewNode = $('<div/>')[0];\n	\n				/* Check to see if we should append an id and/or a class name to the container */\n				cNext = aDom[i+1];\n				if ( cNext == \"'\" || cNext == '\"' )\n				{\n					sAttr = \"\";\n					j = 2;\n					while ( aDom[i+j] != cNext )\n					{\n						sAttr += aDom[i+j];\n						j++;\n					}\n	\n					/* Replace jQuery UI constants @todo depreciated */\n					if ( sAttr == \"H\" )\n					{\n						sAttr = classes.sJUIHeader;\n					}\n					else if ( sAttr == \"F\" )\n					{\n						sAttr = classes.sJUIFooter;\n					}\n	\n					/* The attribute can be in the format of \"#id.class\", \"#id\" or \"class\" This logic\n					 * breaks the string into parts and applies them as needed\n					 */\n					if ( sAttr.indexOf('.') != -1 )\n					{\n						var aSplit = sAttr.split('.');\n						nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);\n						nNewNode.className = aSplit[1];\n					}\n					else if ( sAttr.charAt(0) == \"#\" )\n					{\n						nNewNode.id = sAttr.substr(1, sAttr.length-1);\n					}\n					else\n					{\n						nNewNode.className = sAttr;\n					}\n	\n					i += j; /* Move along the position array */\n				}\n	\n				insert.append( nNewNode );\n				insert = $(nNewNode);\n			}\n			else if ( cOption == '>' )\n			{\n				/* End container div */\n				insert = insert.parent();\n			}\n			// @todo Move options into their own plugins?\n			else if ( cOption == 'l' && features.bPaginate && features.bLengthChange )\n			{\n				/* Length */\n				featureNode = _fnFeatureHtmlLength( oSettings );\n			}\n			else if ( cOption == 'f' && features.bFilter )\n			{\n				/* Filter */\n				featureNode = _fnFeatureHtmlFilter( oSettings );\n			}\n			else if ( cOption == 'r' && features.bProcessing )\n			{\n				/* pRocessing */\n				featureNode = _fnFeatureHtmlProcessing( oSettings );\n			}\n			else if ( cOption == 't' )\n			{\n				/* Table */\n				featureNode = _fnFeatureHtmlTable( oSettings );\n			}\n			else if ( cOption ==  'i' && features.bInfo )\n			{\n				/* Info */\n				featureNode = _fnFeatureHtmlInfo( oSettings );\n			}\n			else if ( cOption == 'p' && features.bPaginate )\n			{\n				/* Pagination */\n				featureNode = _fnFeatureHtmlPaginate( oSettings );\n			}\n			else if ( DataTable.ext.feature.length !== 0 )\n			{\n				/* Plug-in features */\n				var aoFeatures = DataTable.ext.feature;\n				for ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )\n				{\n					if ( cOption == aoFeatures[k].cFeature )\n					{\n						featureNode = aoFeatures[k].fnInit( oSettings );\n						break;\n					}\n				}\n			}\n	\n			/* Add to the 2D features array */\n			if ( featureNode )\n			{\n				var aanFeatures = oSettings.aanFeatures;\n	\n				if ( ! aanFeatures[cOption] )\n				{\n					aanFeatures[cOption] = [];\n				}\n	\n				aanFeatures[cOption].push( featureNode );\n				insert.append( featureNode );\n			}\n		}\n	\n		/* Built our DOM structure - replace the holding div with what we want */\n		holding.replaceWith( insert );\n		oSettings.nHolding = null;\n	}\n	\n	\n	/**\n	 * Use the DOM source to create up an array of header cells. The idea here is to\n	 * create a layout grid (array) of rows x columns, which contains a reference\n	 * to the cell that that point in the grid (regardless of col/rowspan), such that\n	 * any column / row could be removed and the new grid constructed\n	 *  @param array {object} aLayout Array to store the calculated layout in\n	 *  @param {node} nThead The header/footer element for the table\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnDetectHeader ( aLayout, nThead )\n	{\n		var nTrs = $(nThead).children('tr');\n		var nTr, nCell;\n		var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;\n		var bUnique;\n		var fnShiftCol = function ( a, i, j ) {\n			var k = a[i];\n	                while ( k[j] ) {\n				j++;\n			}\n			return j;\n		};\n	\n		aLayout.splice( 0, aLayout.length );\n	\n		/* We know how many rows there are in the layout - so prep it */\n		for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )\n		{\n			aLayout.push( [] );\n		}\n	\n		/* Calculate a layout array */\n		for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )\n		{\n			nTr = nTrs[i];\n			iColumn = 0;\n	\n			/* For every cell in the row... */\n			nCell = nTr.firstChild;\n			while ( nCell ) {\n				if ( nCell.nodeName.toUpperCase() == \"TD\" ||\n				     nCell.nodeName.toUpperCase() == \"TH\" )\n				{\n					/* Get the col and rowspan attributes from the DOM and sanitise them */\n					iColspan = nCell.getAttribute('colspan') * 1;\n					iRowspan = nCell.getAttribute('rowspan') * 1;\n					iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;\n					iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;\n	\n					/* There might be colspan cells already in this row, so shift our target\n					 * accordingly\n					 */\n					iColShifted = fnShiftCol( aLayout, i, iColumn );\n	\n					/* Cache calculation for unique columns */\n					bUnique = iColspan === 1 ? true : false;\n	\n					/* If there is col / rowspan, copy the information into the layout grid */\n					for ( l=0 ; l<iColspan ; l++ )\n					{\n						for ( k=0 ; k<iRowspan ; k++ )\n						{\n							aLayout[i+k][iColShifted+l] = {\n								\"cell\": nCell,\n								\"unique\": bUnique\n							};\n							aLayout[i+k].nTr = nTr;\n						}\n					}\n				}\n				nCell = nCell.nextSibling;\n			}\n		}\n	}\n	\n	\n	/**\n	 * Get an array of unique th elements, one for each column\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {node} nHeader automatically detect the layout from this node - optional\n	 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional\n	 *  @returns array {node} aReturn list of unique th's\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnGetUniqueThs ( oSettings, nHeader, aLayout )\n	{\n		var aReturn = [];\n		if ( !aLayout )\n		{\n			aLayout = oSettings.aoHeader;\n			if ( nHeader )\n			{\n				aLayout = [];\n				_fnDetectHeader( aLayout, nHeader );\n			}\n		}\n	\n		for ( var i=0, iLen=aLayout.length ; i<iLen ; i++ )\n		{\n			for ( var j=0, jLen=aLayout[i].length ; j<jLen ; j++ )\n			{\n				if ( aLayout[i][j].unique &&\n					 (!aReturn[j] || !oSettings.bSortCellsTop) )\n				{\n					aReturn[j] = aLayout[i][j].cell;\n				}\n			}\n		}\n	\n		return aReturn;\n	}\n	\n	/**\n	 * Create an Ajax call based on the table's settings, taking into account that\n	 * parameters can have multiple forms, and backwards compatibility.\n	 *\n	 * @param {object} oSettings dataTables settings object\n	 * @param {array} data Data to send to the server, required by\n	 *     DataTables - may be augmented by developer callbacks\n	 * @param {function} fn Callback function to run when data is obtained\n	 */\n	function _fnBuildAjax( oSettings, data, fn )\n	{\n		// Compatibility with 1.9-, allow fnServerData and event to manipulate\n		_fnCallbackFire( oSettings, 'aoServerParams', 'serverParams', [data] );\n	\n		// Convert to object based for 1.10+ if using the old array scheme which can\n		// come from server-side processing or serverParams\n		if ( data && $.isArray(data) ) {\n			var tmp = {};\n			var rbracket = /(.*?)\\[\\]$/;\n	\n			$.each( data, function (key, val) {\n				var match = val.name.match(rbracket);\n	\n				if ( match ) {\n					// Support for arrays\n					var name = match[0];\n	\n					if ( ! tmp[ name ] ) {\n						tmp[ name ] = [];\n					}\n					tmp[ name ].push( val.value );\n				}\n				else {\n					tmp[val.name] = val.value;\n				}\n			} );\n			data = tmp;\n		}\n	\n		var ajaxData;\n		var ajax = oSettings.ajax;\n		var instance = oSettings.oInstance;\n		var callback = function ( json ) {\n			_fnCallbackFire( oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR] );\n			fn( json );\n		};\n	\n		if ( $.isPlainObject( ajax ) && ajax.data )\n		{\n			ajaxData = ajax.data;\n	\n			var newData = $.isFunction( ajaxData ) ?\n				ajaxData( data, oSettings ) :  // fn can manipulate data or return\n				ajaxData;                      // an object object or array to merge\n	\n			// If the function returned something, use that alone\n			data = $.isFunction( ajaxData ) && newData ?\n				newData :\n				$.extend( true, data, newData );\n	\n			// Remove the data property as we've resolved it already and don't want\n			// jQuery to do it again (it is restored at the end of the function)\n			delete ajax.data;\n		}\n	\n		var baseAjax = {\n			\"data\": data,\n			\"success\": function (json) {\n				var error = json.error || json.sError;\n				if ( error ) {\n					_fnLog( oSettings, 0, error );\n				}\n	\n				oSettings.json = json;\n				callback( json );\n			},\n			\"dataType\": \"json\",\n			\"cache\": false,\n			\"type\": oSettings.sServerMethod,\n			\"error\": function (xhr, error, thrown) {\n				var ret = _fnCallbackFire( oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR] );\n	\n				if ( $.inArray( true, ret ) === -1 ) {\n					if ( error == \"parsererror\" ) {\n						_fnLog( oSettings, 0, 'Invalid JSON response', 1 );\n					}\n					else if ( xhr.readyState === 4 ) {\n						_fnLog( oSettings, 0, 'Ajax error', 7 );\n					}\n				}\n	\n				_fnProcessingDisplay( oSettings, false );\n			}\n		};\n	\n		// Store the data submitted for the API\n		oSettings.oAjaxData = data;\n	\n		// Allow plug-ins and external processes to modify the data\n		_fnCallbackFire( oSettings, null, 'preXhr', [oSettings, data] );\n	\n		if ( oSettings.fnServerData )\n		{\n			// DataTables 1.9- compatibility\n			oSettings.fnServerData.call( instance,\n				oSettings.sAjaxSource,\n				$.map( data, function (val, key) { // Need to convert back to 1.9 trad format\n					return { name: key, value: val };\n				} ),\n				callback,\n				oSettings\n			);\n		}\n		else if ( oSettings.sAjaxSource || typeof ajax === 'string' )\n		{\n			// DataTables 1.9- compatibility\n			oSettings.jqXHR = $.ajax( $.extend( baseAjax, {\n				url: ajax || oSettings.sAjaxSource\n			} ) );\n		}\n		else if ( $.isFunction( ajax ) )\n		{\n			// Is a function - let the caller define what needs to be done\n			oSettings.jqXHR = ajax.call( instance, data, callback, oSettings );\n		}\n		else\n		{\n			// Object to extend the base settings\n			oSettings.jqXHR = $.ajax( $.extend( baseAjax, ajax ) );\n	\n			// Restore for next time around\n			ajax.data = ajaxData;\n		}\n	}\n	\n	\n	/**\n	 * Update the table using an Ajax call\n	 *  @param {object} settings dataTables settings object\n	 *  @returns {boolean} Block the table drawing or not\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnAjaxUpdate( settings )\n	{\n		if ( settings.bAjaxDataGet ) {\n			settings.iDraw++;\n			_fnProcessingDisplay( settings, true );\n	\n			_fnBuildAjax(\n				settings,\n				_fnAjaxParameters( settings ),\n				function(json) {\n					_fnAjaxUpdateDraw( settings, json );\n				}\n			);\n	\n			return false;\n		}\n		return true;\n	}\n	\n	\n	/**\n	 * Build up the parameters in an object needed for a server-side processing\n	 * request. Note that this is basically done twice, is different ways - a modern\n	 * method which is used by default in DataTables 1.10 which uses objects and\n	 * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if\n	 * the sAjaxSource option is used in the initialisation, or the legacyAjax\n	 * option is set.\n	 *  @param {object} oSettings dataTables settings object\n	 *  @returns {bool} block the table drawing or not\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnAjaxParameters( settings )\n	{\n		var\n			columns = settings.aoColumns,\n			columnCount = columns.length,\n			features = settings.oFeatures,\n			preSearch = settings.oPreviousSearch,\n			preColSearch = settings.aoPreSearchCols,\n			i, data = [], dataProp, column, columnSearch,\n			sort = _fnSortFlatten( settings ),\n			displayStart = settings._iDisplayStart,\n			displayLength = features.bPaginate !== false ?\n				settings._iDisplayLength :\n				-1;\n	\n		var param = function ( name, value ) {\n			data.push( { 'name': name, 'value': value } );\n		};\n	\n		// DataTables 1.9- compatible method\n		param( 'sEcho',          settings.iDraw );\n		param( 'iColumns',       columnCount );\n		param( 'sColumns',       _pluck( columns, 'sName' ).join(',') );\n		param( 'iDisplayStart',  displayStart );\n		param( 'iDisplayLength', displayLength );\n	\n		// DataTables 1.10+ method\n		var d = {\n			draw:    settings.iDraw,\n			columns: [],\n			order:   [],\n			start:   displayStart,\n			length:  displayLength,\n			search:  {\n				value: preSearch.sSearch,\n				regex: preSearch.bRegex\n			}\n		};\n	\n		for ( i=0 ; i<columnCount ; i++ ) {\n			column = columns[i];\n			columnSearch = preColSearch[i];\n			dataProp = typeof column.mData==\"function\" ? 'function' : column.mData ;\n	\n			d.columns.push( {\n				data:       dataProp,\n				name:       column.sName,\n				searchable: column.bSearchable,\n				orderable:  column.bSortable,\n				search:     {\n					value: columnSearch.sSearch,\n					regex: columnSearch.bRegex\n				}\n			} );\n	\n			param( \"mDataProp_\"+i, dataProp );\n	\n			if ( features.bFilter ) {\n				param( 'sSearch_'+i,     columnSearch.sSearch );\n				param( 'bRegex_'+i,      columnSearch.bRegex );\n				param( 'bSearchable_'+i, column.bSearchable );\n			}\n	\n			if ( features.bSort ) {\n				param( 'bSortable_'+i, column.bSortable );\n			}\n		}\n	\n		if ( features.bFilter ) {\n			param( 'sSearch', preSearch.sSearch );\n			param( 'bRegex', preSearch.bRegex );\n		}\n	\n		if ( features.bSort ) {\n			$.each( sort, function ( i, val ) {\n				d.order.push( { column: val.col, dir: val.dir } );\n	\n				param( 'iSortCol_'+i, val.col );\n				param( 'sSortDir_'+i, val.dir );\n			} );\n	\n			param( 'iSortingCols', sort.length );\n		}\n	\n		// If the legacy.ajax parameter is null, then we automatically decide which\n		// form to use, based on sAjaxSource\n		var legacy = DataTable.ext.legacy.ajax;\n		if ( legacy === null ) {\n			return settings.sAjaxSource ? data : d;\n		}\n	\n		// Otherwise, if legacy has been specified then we use that to decide on the\n		// form\n		return legacy ? data : d;\n	}\n	\n	\n	/**\n	 * Data the data from the server (nuking the old) and redraw the table\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {object} json json data return from the server.\n	 *  @param {string} json.sEcho Tracking flag for DataTables to match requests\n	 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering\n	 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering\n	 *  @param {array} json.aaData The data to display on this page\n	 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnAjaxUpdateDraw ( settings, json )\n	{\n		// v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.\n		// Support both\n		var compat = function ( old, modern ) {\n			return json[old] !== undefined ? json[old] : json[modern];\n		};\n	\n		var data = _fnAjaxDataSrc( settings, json );\n		var draw            = compat( 'sEcho',                'draw' );\n		var recordsTotal    = compat( 'iTotalRecords',        'recordsTotal' );\n		var recordsFiltered = compat( 'iTotalDisplayRecords', 'recordsFiltered' );\n	\n		if ( draw ) {\n			// Protect against out of sequence returns\n			if ( draw*1 < settings.iDraw ) {\n				return;\n			}\n			settings.iDraw = draw * 1;\n		}\n	\n		_fnClearTable( settings );\n		settings._iRecordsTotal   = parseInt(recordsTotal, 10);\n		settings._iRecordsDisplay = parseInt(recordsFiltered, 10);\n	\n		for ( var i=0, ien=data.length ; i<ien ; i++ ) {\n			_fnAddData( settings, data[i] );\n		}\n		settings.aiDisplay = settings.aiDisplayMaster.slice();\n	\n		settings.bAjaxDataGet = false;\n		_fnDraw( settings );\n	\n		if ( ! settings._bInitComplete ) {\n			_fnInitComplete( settings, json );\n		}\n	\n		settings.bAjaxDataGet = true;\n		_fnProcessingDisplay( settings, false );\n	}\n	\n	\n	/**\n	 * Get the data from the JSON data source to use for drawing a table. Using\n	 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the\n	 * source object, or from a processing function.\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param  {object} json Data source object / array from the server\n	 *  @return {array} Array of data to use\n	 */\n	function _fnAjaxDataSrc ( oSettings, json )\n	{\n		var dataSrc = $.isPlainObject( oSettings.ajax ) && oSettings.ajax.dataSrc !== undefined ?\n			oSettings.ajax.dataSrc :\n			oSettings.sAjaxDataProp; // Compatibility with 1.9-.\n	\n		// Compatibility with 1.9-. In order to read from aaData, check if the\n		// default has been changed, if not, check for aaData\n		if ( dataSrc === 'data' ) {\n			return json.aaData || json[dataSrc];\n		}\n	\n		return dataSrc !== \"\" ?\n			_fnGetObjectDataFn( dataSrc )( json ) :\n			json;\n	}\n	\n	/**\n	 * Generate the node required for filtering text\n	 *  @returns {node} Filter control element\n	 *  @param {object} oSettings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnFeatureHtmlFilter ( settings )\n	{\n		var classes = settings.oClasses;\n		var tableId = settings.sTableId;\n		var language = settings.oLanguage;\n		var previousSearch = settings.oPreviousSearch;\n		var features = settings.aanFeatures;\n		var input = '<input type=\"search\" class=\"'+classes.sFilterInput+'\"/>';\n	\n		var str = language.sSearch;\n		str = str.match(/_INPUT_/) ?\n			str.replace('_INPUT_', input) :\n			str+input;\n	\n		var filter = $('<div/>', {\n				'id': ! features.f ? tableId+'_filter' : null,\n				'class': classes.sFilter\n			} )\n			.append( $('<label/>' ).append( str ) );\n	\n		var searchFn = function() {\n			/* Update all other filter input elements for the new display */\n			var n = features.f;\n			var val = !this.value ? \"\" : this.value; // mental IE8 fix :-(\n	\n			/* Now do the filter */\n			if ( val != previousSearch.sSearch ) {\n				_fnFilterComplete( settings, {\n					\"sSearch\": val,\n					\"bRegex\": previousSearch.bRegex,\n					\"bSmart\": previousSearch.bSmart ,\n					\"bCaseInsensitive\": previousSearch.bCaseInsensitive\n				} );\n	\n				// Need to redraw, without resorting\n				settings._iDisplayStart = 0;\n				_fnDraw( settings );\n			}\n		};\n	\n		var searchDelay = settings.searchDelay !== null ?\n			settings.searchDelay :\n			_fnDataSource( settings ) === 'ssp' ?\n				400 :\n				0;\n	\n		var jqFilter = $('input', filter)\n			.val( previousSearch.sSearch )\n			.attr( 'placeholder', language.sSearchPlaceholder )\n			.bind(\n				'keyup.DT search.DT input.DT paste.DT cut.DT',\n				searchDelay ?\n					_fnThrottle( searchFn, searchDelay ) :\n					searchFn\n			)\n			.bind( 'keypress.DT', function(e) {\n				/* Prevent form submission */\n				if ( e.keyCode == 13 ) {\n					return false;\n				}\n			} )\n			.attr('aria-controls', tableId);\n	\n		// Update the input elements whenever the table is filtered\n		$(settings.nTable).on( 'search.dt.DT', function ( ev, s ) {\n			if ( settings === s ) {\n				// IE9 throws an 'unknown error' if document.activeElement is used\n				// inside an iframe or frame...\n				try {\n					if ( jqFilter[0] !== document.activeElement ) {\n						jqFilter.val( previousSearch.sSearch );\n					}\n				}\n				catch ( e ) {}\n			}\n		} );\n	\n		return filter[0];\n	}\n	\n	\n	/**\n	 * Filter the table using both the global filter and column based filtering\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {object} oSearch search information\n	 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnFilterComplete ( oSettings, oInput, iForce )\n	{\n		var oPrevSearch = oSettings.oPreviousSearch;\n		var aoPrevSearch = oSettings.aoPreSearchCols;\n		var fnSaveFilter = function ( oFilter ) {\n			/* Save the filtering values */\n			oPrevSearch.sSearch = oFilter.sSearch;\n			oPrevSearch.bRegex = oFilter.bRegex;\n			oPrevSearch.bSmart = oFilter.bSmart;\n			oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;\n		};\n		var fnRegex = function ( o ) {\n			// Backwards compatibility with the bEscapeRegex option\n			return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;\n		};\n	\n		// Resolve any column types that are unknown due to addition or invalidation\n		// @todo As per sort - can this be moved into an event handler?\n		_fnColumnTypes( oSettings );\n	\n		/* In server-side processing all filtering is done by the server, so no point hanging around here */\n		if ( _fnDataSource( oSettings ) != 'ssp' )\n		{\n			/* Global filter */\n			_fnFilter( oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive );\n			fnSaveFilter( oInput );\n	\n			/* Now do the individual column filter */\n			for ( var i=0 ; i<aoPrevSearch.length ; i++ )\n			{\n				_fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),\n					aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );\n			}\n	\n			/* Custom filtering */\n			_fnFilterCustom( oSettings );\n		}\n		else\n		{\n			fnSaveFilter( oInput );\n		}\n	\n		/* Tell the draw function we have been filtering */\n		oSettings.bFiltered = true;\n		_fnCallbackFire( oSettings, null, 'search', [oSettings] );\n	}\n	\n	\n	/**\n	 * Apply custom filtering functions\n	 *  @param {object} oSettings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnFilterCustom( settings )\n	{\n		var filters = DataTable.ext.search;\n		var displayRows = settings.aiDisplay;\n		var row, rowIdx;\n	\n		for ( var i=0, ien=filters.length ; i<ien ; i++ ) {\n			var rows = [];\n	\n			// Loop over each row and see if it should be included\n			for ( var j=0, jen=displayRows.length ; j<jen ; j++ ) {\n				rowIdx = displayRows[ j ];\n				row = settings.aoData[ rowIdx ];\n	\n				if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {\n					rows.push( rowIdx );\n				}\n			}\n	\n			// So the array reference doesn't break set the results into the\n			// existing array\n			displayRows.length = 0;\n			$.merge( displayRows, rows );\n		}\n	}\n	\n	\n	/**\n	 * Filter the table on a per-column basis\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {string} sInput string to filter on\n	 *  @param {int} iColumn column to filter\n	 *  @param {bool} bRegex treat search string as a regular expression or not\n	 *  @param {bool} bSmart use smart filtering or not\n	 *  @param {bool} bCaseInsensitive Do case insenstive matching or not\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnFilterColumn ( settings, searchStr, colIdx, regex, smart, caseInsensitive )\n	{\n		if ( searchStr === '' ) {\n			return;\n		}\n	\n		var data;\n		var display = settings.aiDisplay;\n		var rpSearch = _fnFilterCreateSearch( searchStr, regex, smart, caseInsensitive );\n	\n		for ( var i=display.length-1 ; i>=0 ; i-- ) {\n			data = settings.aoData[ display[i] ]._aFilterData[ colIdx ];\n	\n			if ( ! rpSearch.test( data ) ) {\n				display.splice( i, 1 );\n			}\n		}\n	}\n	\n	\n	/**\n	 * Filter the data table based on user input and draw the table\n	 *  @param {object} settings dataTables settings object\n	 *  @param {string} input string to filter on\n	 *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)\n	 *  @param {bool} regex treat as a regular expression or not\n	 *  @param {bool} smart perform smart filtering or not\n	 *  @param {bool} caseInsensitive Do case insenstive matching or not\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnFilter( settings, input, force, regex, smart, caseInsensitive )\n	{\n		var rpSearch = _fnFilterCreateSearch( input, regex, smart, caseInsensitive );\n		var prevSearch = settings.oPreviousSearch.sSearch;\n		var displayMaster = settings.aiDisplayMaster;\n		var display, invalidated, i;\n	\n		// Need to take account of custom filtering functions - always filter\n		if ( DataTable.ext.search.length !== 0 ) {\n			force = true;\n		}\n	\n		// Check if any of the rows were invalidated\n		invalidated = _fnFilterData( settings );\n	\n		// If the input is blank - we just want the full data set\n		if ( input.length <= 0 ) {\n			settings.aiDisplay = displayMaster.slice();\n		}\n		else {\n			// New search - start from the master array\n			if ( invalidated ||\n				 force ||\n				 prevSearch.length > input.length ||\n				 input.indexOf(prevSearch) !== 0 ||\n				 settings.bSorted // On resort, the display master needs to be\n				                  // re-filtered since indexes will have changed\n			) {\n				settings.aiDisplay = displayMaster.slice();\n			}\n	\n			// Search the display array\n			display = settings.aiDisplay;\n	\n			for ( i=display.length-1 ; i>=0 ; i-- ) {\n				if ( ! rpSearch.test( settings.aoData[ display[i] ]._sFilterRow ) ) {\n					display.splice( i, 1 );\n				}\n			}\n		}\n	}\n	\n	\n	/**\n	 * Build a regular expression object suitable for searching a table\n	 *  @param {string} sSearch string to search for\n	 *  @param {bool} bRegex treat as a regular expression or not\n	 *  @param {bool} bSmart perform smart filtering or not\n	 *  @param {bool} bCaseInsensitive Do case insensitive matching or not\n	 *  @returns {RegExp} constructed object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnFilterCreateSearch( search, regex, smart, caseInsensitive )\n	{\n		search = regex ?\n			search :\n			_fnEscapeRegex( search );\n		\n		if ( smart ) {\n			/* For smart filtering we want to allow the search to work regardless of\n			 * word order. We also want double quoted text to be preserved, so word\n			 * order is important - a la google. So this is what we want to\n			 * generate:\n			 * \n			 * ^(?=.*?\\bone\\b)(?=.*?\\btwo three\\b)(?=.*?\\bfour\\b).*$\n			 */\n			var a = $.map( search.match( /\"[^\"]+\"|[^ ]+/g ) || [''], function ( word ) {\n				if ( word.charAt(0) === '\"' ) {\n					var m = word.match( /^\"(.*)\"$/ );\n					word = m ? m[1] : word;\n				}\n	\n				return word.replace('\"', '');\n			} );\n	\n			search = '^(?=.*?'+a.join( ')(?=.*?' )+').*$';\n		}\n	\n		return new RegExp( search, caseInsensitive ? 'i' : '' );\n	}\n	\n	\n	/**\n	 * Escape a string such that it can be used in a regular expression\n	 *  @param {string} sVal string to escape\n	 *  @returns {string} escaped string\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnEscapeRegex ( sVal )\n	{\n		return sVal.replace( _re_escape_regex, '\\\\$1' );\n	}\n	\n	\n	\n	var __filter_div = $('<div>')[0];\n	var __filter_div_textContent = __filter_div.textContent !== undefined;\n	\n	// Update the filtering data for each row if needed (by invalidation or first run)\n	function _fnFilterData ( settings )\n	{\n		var columns = settings.aoColumns;\n		var column;\n		var i, j, ien, jen, filterData, cellData, row;\n		var fomatters = DataTable.ext.type.search;\n		var wasInvalidated = false;\n	\n		for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {\n			row = settings.aoData[i];\n	\n			if ( ! row._aFilterData ) {\n				filterData = [];\n	\n				for ( j=0, jen=columns.length ; j<jen ; j++ ) {\n					column = columns[j];\n	\n					if ( column.bSearchable ) {\n						cellData = _fnGetCellData( settings, i, j, 'filter' );\n	\n						if ( fomatters[ column.sType ] ) {\n							cellData = fomatters[ column.sType ]( cellData );\n						}\n	\n						// Search in DataTables 1.10 is string based. In 1.11 this\n						// should be altered to also allow strict type checking.\n						if ( cellData === null ) {\n							cellData = '';\n						}\n	\n						if ( typeof cellData !== 'string' && cellData.toString ) {\n							cellData = cellData.toString();\n						}\n					}\n					else {\n						cellData = '';\n					}\n	\n					// If it looks like there is an HTML entity in the string,\n					// attempt to decode it so sorting works as expected. Note that\n					// we could use a single line of jQuery to do this, but the DOM\n					// method used here is much faster http://jsperf.com/html-decode\n					if ( cellData.indexOf && cellData.indexOf('&') !== -1 ) {\n						__filter_div.innerHTML = cellData;\n						cellData = __filter_div_textContent ?\n							__filter_div.textContent :\n							__filter_div.innerText;\n					}\n	\n					if ( cellData.replace ) {\n						cellData = cellData.replace(/[\\r\\n]/g, '');\n					}\n	\n					filterData.push( cellData );\n				}\n	\n				row._aFilterData = filterData;\n				row._sFilterRow = filterData.join('  ');\n				wasInvalidated = true;\n			}\n		}\n	\n		return wasInvalidated;\n	}\n	\n	\n	/**\n	 * Convert from the internal Hungarian notation to camelCase for external\n	 * interaction\n	 *  @param {object} obj Object to convert\n	 *  @returns {object} Inverted object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnSearchToCamel ( obj )\n	{\n		return {\n			search:          obj.sSearch,\n			smart:           obj.bSmart,\n			regex:           obj.bRegex,\n			caseInsensitive: obj.bCaseInsensitive\n		};\n	}\n	\n	\n	\n	/**\n	 * Convert from camelCase notation to the internal Hungarian. We could use the\n	 * Hungarian convert function here, but this is cleaner\n	 *  @param {object} obj Object to convert\n	 *  @returns {object} Inverted object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnSearchToHung ( obj )\n	{\n		return {\n			sSearch:          obj.search,\n			bSmart:           obj.smart,\n			bRegex:           obj.regex,\n			bCaseInsensitive: obj.caseInsensitive\n		};\n	}\n	\n	/**\n	 * Generate the node required for the info display\n	 *  @param {object} oSettings dataTables settings object\n	 *  @returns {node} Information element\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnFeatureHtmlInfo ( settings )\n	{\n		var\n			tid = settings.sTableId,\n			nodes = settings.aanFeatures.i,\n			n = $('<div/>', {\n				'class': settings.oClasses.sInfo,\n				'id': ! nodes ? tid+'_info' : null\n			} );\n	\n		if ( ! nodes ) {\n			// Update display on each draw\n			settings.aoDrawCallback.push( {\n				\"fn\": _fnUpdateInfo,\n				\"sName\": \"information\"\n			} );\n	\n			n\n				.attr( 'role', 'status' )\n				.attr( 'aria-live', 'polite' );\n	\n			// Table is described by our info div\n			$(settings.nTable).attr( 'aria-describedby', tid+'_info' );\n		}\n	\n		return n[0];\n	}\n	\n	\n	/**\n	 * Update the information elements in the display\n	 *  @param {object} settings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnUpdateInfo ( settings )\n	{\n		/* Show information about the table */\n		var nodes = settings.aanFeatures.i;\n		if ( nodes.length === 0 ) {\n			return;\n		}\n	\n		var\n			lang  = settings.oLanguage,\n			start = settings._iDisplayStart+1,\n			end   = settings.fnDisplayEnd(),\n			max   = settings.fnRecordsTotal(),\n			total = settings.fnRecordsDisplay(),\n			out   = total ?\n				lang.sInfo :\n				lang.sInfoEmpty;\n	\n		if ( total !== max ) {\n			/* Record set after filtering */\n			out += ' ' + lang.sInfoFiltered;\n		}\n	\n		// Convert the macros\n		out += lang.sInfoPostFix;\n		out = _fnInfoMacros( settings, out );\n	\n		var callback = lang.fnInfoCallback;\n		if ( callback !== null ) {\n			out = callback.call( settings.oInstance,\n				settings, start, end, max, total, out\n			);\n		}\n	\n		$(nodes).html( out );\n	}\n	\n	\n	function _fnInfoMacros ( settings, str )\n	{\n		// When infinite scrolling, we are always starting at 1. _iDisplayStart is used only\n		// internally\n		var\n			formatter  = settings.fnFormatNumber,\n			start      = settings._iDisplayStart+1,\n			len        = settings._iDisplayLength,\n			vis        = settings.fnRecordsDisplay(),\n			all        = len === -1;\n	\n		return str.\n			replace(/_START_/g, formatter.call( settings, start ) ).\n			replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).\n			replace(/_MAX_/g,   formatter.call( settings, settings.fnRecordsTotal() ) ).\n			replace(/_TOTAL_/g, formatter.call( settings, vis ) ).\n			replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).\n			replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) );\n	}\n	\n	\n	\n	/**\n	 * Draw the table for the first time, adding all required features\n	 *  @param {object} settings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnInitialise ( settings )\n	{\n		var i, iLen, iAjaxStart=settings.iInitDisplayStart;\n		var columns = settings.aoColumns, column;\n		var features = settings.oFeatures;\n		var deferLoading = settings.bDeferLoading; // value modified by the draw\n	\n		/* Ensure that the table data is fully initialised */\n		if ( ! settings.bInitialised ) {\n			setTimeout( function(){ _fnInitialise( settings ); }, 200 );\n			return;\n		}\n	\n		/* Show the display HTML options */\n		_fnAddOptionsHtml( settings );\n	\n		/* Build and draw the header / footer for the table */\n		_fnBuildHead( settings );\n		_fnDrawHead( settings, settings.aoHeader );\n		_fnDrawHead( settings, settings.aoFooter );\n	\n		/* Okay to show that something is going on now */\n		_fnProcessingDisplay( settings, true );\n	\n		/* Calculate sizes for columns */\n		if ( features.bAutoWidth ) {\n			_fnCalculateColumnWidths( settings );\n		}\n	\n		for ( i=0, iLen=columns.length ; i<iLen ; i++ ) {\n			column = columns[i];\n	\n			if ( column.sWidth ) {\n				column.nTh.style.width = _fnStringToCss( column.sWidth );\n			}\n		}\n	\n		_fnCallbackFire( settings, null, 'preInit', [settings] );\n	\n		// If there is default sorting required - let's do it. The sort function\n		// will do the drawing for us. Otherwise we draw the table regardless of the\n		// Ajax source - this allows the table to look initialised for Ajax sourcing\n		// data (show 'loading' message possibly)\n		_fnReDraw( settings );\n	\n		// Server-side processing init complete is done by _fnAjaxUpdateDraw\n		var dataSrc = _fnDataSource( settings );\n		if ( dataSrc != 'ssp' || deferLoading ) {\n			// if there is an ajax source load the data\n			if ( dataSrc == 'ajax' ) {\n				_fnBuildAjax( settings, [], function(json) {\n					var aData = _fnAjaxDataSrc( settings, json );\n	\n					// Got the data - add it to the table\n					for ( i=0 ; i<aData.length ; i++ ) {\n						_fnAddData( settings, aData[i] );\n					}\n	\n					// Reset the init display for cookie saving. We've already done\n					// a filter, and therefore cleared it before. So we need to make\n					// it appear 'fresh'\n					settings.iInitDisplayStart = iAjaxStart;\n	\n					_fnReDraw( settings );\n	\n					_fnProcessingDisplay( settings, false );\n					_fnInitComplete( settings, json );\n				}, settings );\n			}\n			else {\n				_fnProcessingDisplay( settings, false );\n				_fnInitComplete( settings );\n			}\n		}\n	}\n	\n	\n	/**\n	 * Draw the table for the first time, adding all required features\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source\n	 *    with client-side processing (optional)\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnInitComplete ( settings, json )\n	{\n		settings._bInitComplete = true;\n	\n		// When data was added after the initialisation (data or Ajax) we need to\n		// calculate the column sizing\n		if ( json || settings.oInit.aaData ) {\n			_fnAdjustColumnSizing( settings );\n		}\n	\n		_fnCallbackFire( settings, null, 'plugin-init', [settings, json] );\n		_fnCallbackFire( settings, 'aoInitComplete', 'init', [settings, json] );\n	}\n	\n	\n	function _fnLengthChange ( settings, val )\n	{\n		var len = parseInt( val, 10 );\n		settings._iDisplayLength = len;\n	\n		_fnLengthOverflow( settings );\n	\n		// Fire length change event\n		_fnCallbackFire( settings, null, 'length', [settings, len] );\n	}\n	\n	\n	/**\n	 * Generate the node required for user display length changing\n	 *  @param {object} settings dataTables settings object\n	 *  @returns {node} Display length feature node\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnFeatureHtmlLength ( settings )\n	{\n		var\n			classes  = settings.oClasses,\n			tableId  = settings.sTableId,\n			menu     = settings.aLengthMenu,\n			d2       = $.isArray( menu[0] ),\n			lengths  = d2 ? menu[0] : menu,\n			language = d2 ? menu[1] : menu;\n	\n		var select = $('<select/>', {\n			'name':          tableId+'_length',\n			'aria-controls': tableId,\n			'class':         classes.sLengthSelect\n		} );\n	\n		for ( var i=0, ien=lengths.length ; i<ien ; i++ ) {\n			select[0][ i ] = new Option( language[i], lengths[i] );\n		}\n	\n		var div = $('<div><label/></div>').addClass( classes.sLength );\n		if ( ! settings.aanFeatures.l ) {\n			div[0].id = tableId+'_length';\n		}\n	\n		div.children().append(\n			settings.oLanguage.sLengthMenu.replace( '_MENU_', select[0].outerHTML )\n		);\n	\n		// Can't use `select` variable as user might provide their own and the\n		// reference is broken by the use of outerHTML\n		$('select', div)\n			.val( settings._iDisplayLength )\n			.bind( 'change.DT', function(e) {\n				_fnLengthChange( settings, $(this).val() );\n				_fnDraw( settings );\n			} );\n	\n		// Update node value whenever anything changes the table's length\n		$(settings.nTable).bind( 'length.dt.DT', function (e, s, len) {\n			if ( settings === s ) {\n				$('select', div).val( len );\n			}\n		} );\n	\n		return div[0];\n	}\n	\n	\n	\n	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n	 * Note that most of the paging logic is done in\n	 * DataTable.ext.pager\n	 */\n	\n	/**\n	 * Generate the node required for default pagination\n	 *  @param {object} oSettings dataTables settings object\n	 *  @returns {node} Pagination feature node\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnFeatureHtmlPaginate ( settings )\n	{\n		var\n			type   = settings.sPaginationType,\n			plugin = DataTable.ext.pager[ type ],\n			modern = typeof plugin === 'function',\n			redraw = function( settings ) {\n				_fnDraw( settings );\n			},\n			node = $('<div/>').addClass( settings.oClasses.sPaging + type )[0],\n			features = settings.aanFeatures;\n	\n		if ( ! modern ) {\n			plugin.fnInit( settings, node, redraw );\n		}\n	\n		/* Add a draw callback for the pagination on first instance, to update the paging display */\n		if ( ! features.p )\n		{\n			node.id = settings.sTableId+'_paginate';\n	\n			settings.aoDrawCallback.push( {\n				\"fn\": function( settings ) {\n					if ( modern ) {\n						var\n							start      = settings._iDisplayStart,\n							len        = settings._iDisplayLength,\n							visRecords = settings.fnRecordsDisplay(),\n							all        = len === -1,\n							page = all ? 0 : Math.ceil( start / len ),\n							pages = all ? 1 : Math.ceil( visRecords / len ),\n							buttons = plugin(page, pages),\n							i, ien;\n	\n						for ( i=0, ien=features.p.length ; i<ien ; i++ ) {\n							_fnRenderer( settings, 'pageButton' )(\n								settings, features.p[i], i, buttons, page, pages\n							);\n						}\n					}\n					else {\n						plugin.fnUpdate( settings, redraw );\n					}\n				},\n				\"sName\": \"pagination\"\n			} );\n		}\n	\n		return node;\n	}\n	\n	\n	/**\n	 * Alter the display settings to change the page\n	 *  @param {object} settings DataTables settings object\n	 *  @param {string|int} action Paging action to take: \"first\", \"previous\",\n	 *    \"next\" or \"last\" or page number to jump to (integer)\n	 *  @param [bool] redraw Automatically draw the update or not\n	 *  @returns {bool} true page has changed, false - no change\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnPageChange ( settings, action, redraw )\n	{\n		var\n			start     = settings._iDisplayStart,\n			len       = settings._iDisplayLength,\n			records   = settings.fnRecordsDisplay();\n	\n		if ( records === 0 || len === -1 )\n		{\n			start = 0;\n		}\n		else if ( typeof action === \"number\" )\n		{\n			start = action * len;\n	\n			if ( start > records )\n			{\n				start = 0;\n			}\n		}\n		else if ( action == \"first\" )\n		{\n			start = 0;\n		}\n		else if ( action == \"previous\" )\n		{\n			start = len >= 0 ?\n				start - len :\n				0;\n	\n			if ( start < 0 )\n			{\n			  start = 0;\n			}\n		}\n		else if ( action == \"next\" )\n		{\n			if ( start + len < records )\n			{\n				start += len;\n			}\n		}\n		else if ( action == \"last\" )\n		{\n			start = Math.floor( (records-1) / len) * len;\n		}\n		else\n		{\n			_fnLog( settings, 0, \"Unknown paging action: \"+action, 5 );\n		}\n	\n		var changed = settings._iDisplayStart !== start;\n		settings._iDisplayStart = start;\n	\n		if ( changed ) {\n			_fnCallbackFire( settings, null, 'page', [settings] );\n	\n			if ( redraw ) {\n				_fnDraw( settings );\n			}\n		}\n	\n		return changed;\n	}\n	\n	\n	\n	/**\n	 * Generate the node required for the processing node\n	 *  @param {object} settings dataTables settings object\n	 *  @returns {node} Processing element\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnFeatureHtmlProcessing ( settings )\n	{\n		return $('<div/>', {\n				'id': ! settings.aanFeatures.r ? settings.sTableId+'_processing' : null,\n				'class': settings.oClasses.sProcessing\n			} )\n			.html( settings.oLanguage.sProcessing )\n			.insertBefore( settings.nTable )[0];\n	}\n	\n	\n	/**\n	 * Display or hide the processing indicator\n	 *  @param {object} settings dataTables settings object\n	 *  @param {bool} show Show the processing indicator (true) or not (false)\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnProcessingDisplay ( settings, show )\n	{\n		if ( settings.oFeatures.bProcessing ) {\n			$(settings.aanFeatures.r).css( 'display', show ? 'block' : 'none' );\n		}\n	\n		_fnCallbackFire( settings, null, 'processing', [settings, show] );\n	}\n	\n	/**\n	 * Add any control elements for the table - specifically scrolling\n	 *  @param {object} settings dataTables settings object\n	 *  @returns {node} Node to add to the DOM\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnFeatureHtmlTable ( settings )\n	{\n		var table = $(settings.nTable);\n	\n		// Add the ARIA grid role to the table\n		table.attr( 'role', 'grid' );\n	\n		// Scrolling from here on in\n		var scroll = settings.oScroll;\n	\n		if ( scroll.sX === '' && scroll.sY === '' ) {\n			return settings.nTable;\n		}\n	\n		var scrollX = scroll.sX;\n		var scrollY = scroll.sY;\n		var classes = settings.oClasses;\n		var caption = table.children('caption');\n		var captionSide = caption.length ? caption[0]._captionSide : null;\n		var headerClone = $( table[0].cloneNode(false) );\n		var footerClone = $( table[0].cloneNode(false) );\n		var footer = table.children('tfoot');\n		var _div = '<div/>';\n		var size = function ( s ) {\n			return !s ? null : _fnStringToCss( s );\n		};\n	\n		if ( ! footer.length ) {\n			footer = null;\n		}\n	\n		/*\n		 * The HTML structure that we want to generate in this function is:\n		 *  div - scroller\n		 *    div - scroll head\n		 *      div - scroll head inner\n		 *        table - scroll head table\n		 *          thead - thead\n		 *    div - scroll body\n		 *      table - table (master table)\n		 *        thead - thead clone for sizing\n		 *        tbody - tbody\n		 *    div - scroll foot\n		 *      div - scroll foot inner\n		 *        table - scroll foot table\n		 *          tfoot - tfoot\n		 */\n		var scroller = $( _div, { 'class': classes.sScrollWrapper } )\n			.append(\n				$(_div, { 'class': classes.sScrollHead } )\n					.css( {\n						overflow: 'hidden',\n						position: 'relative',\n						border: 0,\n						width: scrollX ? size(scrollX) : '100%'\n					} )\n					.append(\n						$(_div, { 'class': classes.sScrollHeadInner } )\n							.css( {\n								'box-sizing': 'content-box',\n								width: scroll.sXInner || '100%'\n							} )\n							.append(\n								headerClone\n									.removeAttr('id')\n									.css( 'margin-left', 0 )\n									.append( captionSide === 'top' ? caption : null )\n									.append(\n										table.children('thead')\n									)\n							)\n					)\n			)\n			.append(\n				$(_div, { 'class': classes.sScrollBody } )\n					.css( {\n						position: 'relative',\n						overflow: 'auto',\n						width: size( scrollX )\n					} )\n					.append( table )\n			);\n	\n		if ( footer ) {\n			scroller.append(\n				$(_div, { 'class': classes.sScrollFoot } )\n					.css( {\n						overflow: 'hidden',\n						border: 0,\n						width: scrollX ? size(scrollX) : '100%'\n					} )\n					.append(\n						$(_div, { 'class': classes.sScrollFootInner } )\n							.append(\n								footerClone\n									.removeAttr('id')\n									.css( 'margin-left', 0 )\n									.append( captionSide === 'bottom' ? caption : null )\n									.append(\n										table.children('tfoot')\n									)\n							)\n					)\n			);\n		}\n	\n		var children = scroller.children();\n		var scrollHead = children[0];\n		var scrollBody = children[1];\n		var scrollFoot = footer ? children[2] : null;\n	\n		// When the body is scrolled, then we also want to scroll the headers\n		if ( scrollX ) {\n			$(scrollBody).on( 'scroll.DT', function (e) {\n				var scrollLeft = this.scrollLeft;\n	\n				scrollHead.scrollLeft = scrollLeft;\n	\n				if ( footer ) {\n					scrollFoot.scrollLeft = scrollLeft;\n				}\n			} );\n		}\n	\n		$(scrollBody).css(\n			scrollY && scroll.bCollapse ? 'max-height' : 'height', \n			scrollY\n		);\n	\n		settings.nScrollHead = scrollHead;\n		settings.nScrollBody = scrollBody;\n		settings.nScrollFoot = scrollFoot;\n	\n		// On redraw - align columns\n		settings.aoDrawCallback.push( {\n			\"fn\": _fnScrollDraw,\n			\"sName\": \"scrolling\"\n		} );\n	\n		return scroller[0];\n	}\n	\n	\n	\n	/**\n	 * Update the header, footer and body tables for resizing - i.e. column\n	 * alignment.\n	 *\n	 * Welcome to the most horrible function DataTables. The process that this\n	 * function follows is basically:\n	 *   1. Re-create the table inside the scrolling div\n	 *   2. Take live measurements from the DOM\n	 *   3. Apply the measurements to align the columns\n	 *   4. Clean up\n	 *\n	 *  @param {object} settings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnScrollDraw ( settings )\n	{\n		// Given that this is such a monster function, a lot of variables are use\n		// to try and keep the minimised size as small as possible\n		var\n			scroll         = settings.oScroll,\n			scrollX        = scroll.sX,\n			scrollXInner   = scroll.sXInner,\n			scrollY        = scroll.sY,\n			barWidth       = scroll.iBarWidth,\n			divHeader      = $(settings.nScrollHead),\n			divHeaderStyle = divHeader[0].style,\n			divHeaderInner = divHeader.children('div'),\n			divHeaderInnerStyle = divHeaderInner[0].style,\n			divHeaderTable = divHeaderInner.children('table'),\n			divBodyEl      = settings.nScrollBody,\n			divBody        = $(divBodyEl),\n			divBodyStyle   = divBodyEl.style,\n			divFooter      = $(settings.nScrollFoot),\n			divFooterInner = divFooter.children('div'),\n			divFooterTable = divFooterInner.children('table'),\n			header         = $(settings.nTHead),\n			table          = $(settings.nTable),\n			tableEl        = table[0],\n			tableStyle     = tableEl.style,\n			footer         = settings.nTFoot ? $(settings.nTFoot) : null,\n			browser        = settings.oBrowser,\n			ie67           = browser.bScrollOversize,\n			headerTrgEls, footerTrgEls,\n			headerSrcEls, footerSrcEls,\n			headerCopy, footerCopy,\n			headerWidths=[], footerWidths=[],\n			headerContent=[],\n			idx, correction, sanityWidth,\n			zeroOut = function(nSizer) {\n				var style = nSizer.style;\n				style.paddingTop = \"0\";\n				style.paddingBottom = \"0\";\n				style.borderTopWidth = \"0\";\n				style.borderBottomWidth = \"0\";\n				style.height = 0;\n			};\n	\n		// If the scrollbar visibility has changed from the last draw, we need to\n		// adjust the column sizes as the table width will have changed to account\n		// for the scrollbar\n		var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;\n		\n		if ( settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined ) {\n			settings.scrollBarVis = scrollBarVis;\n			_fnAdjustColumnSizing( settings );\n			return; // adjust column sizing will call this function again\n		}\n		else {\n			settings.scrollBarVis = scrollBarVis;\n		}\n	\n		/*\n		 * 1. Re-create the table inside the scrolling div\n		 */\n	\n		// Remove the old minimised thead and tfoot elements in the inner table\n		table.children('thead, tfoot').remove();\n	\n		// Clone the current header and footer elements and then place it into the inner table\n		headerCopy = header.clone().prependTo( table );\n		headerTrgEls = header.find('tr'); // original header is in its own table\n		headerSrcEls = headerCopy.find('tr');\n		headerCopy.find('th, td').removeAttr('tabindex');\n	\n		if ( footer ) {\n			footerCopy = footer.clone().prependTo( table );\n			footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized\n			footerSrcEls = footerCopy.find('tr');\n		}\n	\n	\n		/*\n		 * 2. Take live measurements from the DOM - do not alter the DOM itself!\n		 */\n	\n		// Remove old sizing and apply the calculated column widths\n		// Get the unique column headers in the newly created (cloned) header. We want to apply the\n		// calculated sizes to this header\n		if ( ! scrollX )\n		{\n			divBodyStyle.width = '100%';\n			divHeader[0].style.width = '100%';\n		}\n	\n		$.each( _fnGetUniqueThs( settings, headerCopy ), function ( i, el ) {\n			idx = _fnVisibleToColumnIndex( settings, i );\n			el.style.width = settings.aoColumns[idx].sWidth;\n		} );\n	\n		if ( footer ) {\n			_fnApplyToChildren( function(n) {\n				n.style.width = \"\";\n			}, footerSrcEls );\n		}\n	\n		// Size the table as a whole\n		sanityWidth = table.outerWidth();\n		if ( scrollX === \"\" ) {\n			// No x scrolling\n			tableStyle.width = \"100%\";\n	\n			// IE7 will make the width of the table when 100% include the scrollbar\n			// - which is shouldn't. When there is a scrollbar we need to take this\n			// into account.\n			if ( ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||\n				divBody.css('overflow-y') == \"scroll\")\n			) {\n				tableStyle.width = _fnStringToCss( table.outerWidth() - barWidth);\n			}\n	\n			// Recalculate the sanity width\n			sanityWidth = table.outerWidth();\n		}\n		else if ( scrollXInner !== \"\" ) {\n			// legacy x scroll inner has been given - use it\n			tableStyle.width = _fnStringToCss(scrollXInner);\n	\n			// Recalculate the sanity width\n			sanityWidth = table.outerWidth();\n		}\n	\n		// Hidden header should have zero height, so remove padding and borders. Then\n		// set the width based on the real headers\n	\n		// Apply all styles in one pass\n		_fnApplyToChildren( zeroOut, headerSrcEls );\n	\n		// Read all widths in next pass\n		_fnApplyToChildren( function(nSizer) {\n			headerContent.push( nSizer.innerHTML );\n			headerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );\n		}, headerSrcEls );\n	\n		// Apply all widths in final pass\n		_fnApplyToChildren( function(nToSize, i) {\n			nToSize.style.width = headerWidths[i];\n		}, headerTrgEls );\n	\n		$(headerSrcEls).height(0);\n	\n		/* Same again with the footer if we have one */\n		if ( footer )\n		{\n			_fnApplyToChildren( zeroOut, footerSrcEls );\n	\n			_fnApplyToChildren( function(nSizer) {\n				footerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );\n			}, footerSrcEls );\n	\n			_fnApplyToChildren( function(nToSize, i) {\n				nToSize.style.width = footerWidths[i];\n			}, footerTrgEls );\n	\n			$(footerSrcEls).height(0);\n		}\n	\n	\n		/*\n		 * 3. Apply the measurements\n		 */\n	\n		// \"Hide\" the header and footer that we used for the sizing. We need to keep\n		// the content of the cell so that the width applied to the header and body\n		// both match, but we want to hide it completely. We want to also fix their\n		// width to what they currently are\n		_fnApplyToChildren( function(nSizer, i) {\n			nSizer.innerHTML = '<div class=\"dataTables_sizing\" style=\"height:0;overflow:hidden;\">'+headerContent[i]+'</div>';\n			nSizer.style.width = headerWidths[i];\n		}, headerSrcEls );\n	\n		if ( footer )\n		{\n			_fnApplyToChildren( function(nSizer, i) {\n				nSizer.innerHTML = \"\";\n				nSizer.style.width = footerWidths[i];\n			}, footerSrcEls );\n		}\n	\n		// Sanity check that the table is of a sensible width. If not then we are going to get\n		// misalignment - try to prevent this by not allowing the table to shrink below its min width\n		if ( table.outerWidth() < sanityWidth )\n		{\n			// The min width depends upon if we have a vertical scrollbar visible or not */\n			correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||\n				divBody.css('overflow-y') == \"scroll\")) ?\n					sanityWidth+barWidth :\n					sanityWidth;\n	\n			// IE6/7 are a law unto themselves...\n			if ( ie67 && (divBodyEl.scrollHeight >\n				divBodyEl.offsetHeight || divBody.css('overflow-y') == \"scroll\")\n			) {\n				tableStyle.width = _fnStringToCss( correction-barWidth );\n			}\n	\n			// And give the user a warning that we've stopped the table getting too small\n			if ( scrollX === \"\" || scrollXInner !== \"\" ) {\n				_fnLog( settings, 1, 'Possible column misalignment', 6 );\n			}\n		}\n		else\n		{\n			correction = '100%';\n		}\n	\n		// Apply to the container elements\n		divBodyStyle.width = _fnStringToCss( correction );\n		divHeaderStyle.width = _fnStringToCss( correction );\n	\n		if ( footer ) {\n			settings.nScrollFoot.style.width = _fnStringToCss( correction );\n		}\n	\n	\n		/*\n		 * 4. Clean up\n		 */\n		if ( ! scrollY ) {\n			/* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting\n			 * the scrollbar height from the visible display, rather than adding it on. We need to\n			 * set the height in order to sort this. Don't want to do it in any other browsers.\n			 */\n			if ( ie67 ) {\n				divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+barWidth );\n			}\n		}\n	\n		/* Finally set the width's of the header and footer tables */\n		var iOuterWidth = table.outerWidth();\n		divHeaderTable[0].style.width = _fnStringToCss( iOuterWidth );\n		divHeaderInnerStyle.width = _fnStringToCss( iOuterWidth );\n	\n		// Figure out if there are scrollbar present - if so then we need a the header and footer to\n		// provide a bit more space to allow \"overflow\" scrolling (i.e. past the scrollbar)\n		var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == \"scroll\";\n		var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right' );\n		divHeaderInnerStyle[ padding ] = bScrolling ? barWidth+\"px\" : \"0px\";\n	\n		if ( footer ) {\n			divFooterTable[0].style.width = _fnStringToCss( iOuterWidth );\n			divFooterInner[0].style.width = _fnStringToCss( iOuterWidth );\n			divFooterInner[0].style[padding] = bScrolling ? barWidth+\"px\" : \"0px\";\n		}\n	\n		/* Adjust the position of the header in case we loose the y-scrollbar */\n		divBody.scroll();\n	\n		// If sorting or filtering has occurred, jump the scrolling back to the top\n		// only if we aren't holding the position\n		if ( (settings.bSorted || settings.bFiltered) && ! settings._drawHold ) {\n			divBodyEl.scrollTop = 0;\n		}\n	}\n	\n	\n	\n	/**\n	 * Apply a given function to the display child nodes of an element array (typically\n	 * TD children of TR rows\n	 *  @param {function} fn Method to apply to the objects\n	 *  @param array {nodes} an1 List of elements to look through for display children\n	 *  @param array {nodes} an2 Another list (identical structure to the first) - optional\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnApplyToChildren( fn, an1, an2 )\n	{\n		var index=0, i=0, iLen=an1.length;\n		var nNode1, nNode2;\n	\n		while ( i < iLen ) {\n			nNode1 = an1[i].firstChild;\n			nNode2 = an2 ? an2[i].firstChild : null;\n	\n			while ( nNode1 ) {\n				if ( nNode1.nodeType === 1 ) {\n					if ( an2 ) {\n						fn( nNode1, nNode2, index );\n					}\n					else {\n						fn( nNode1, index );\n					}\n	\n					index++;\n				}\n	\n				nNode1 = nNode1.nextSibling;\n				nNode2 = an2 ? nNode2.nextSibling : null;\n			}\n	\n			i++;\n		}\n	}\n	\n	\n	\n	var __re_html_remove = /<.*?>/g;\n	\n	\n	/**\n	 * Calculate the width of columns for the table\n	 *  @param {object} oSettings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnCalculateColumnWidths ( oSettings )\n	{\n		var\n			table = oSettings.nTable,\n			columns = oSettings.aoColumns,\n			scroll = oSettings.oScroll,\n			scrollY = scroll.sY,\n			scrollX = scroll.sX,\n			scrollXInner = scroll.sXInner,\n			columnCount = columns.length,\n			visibleColumns = _fnGetColumns( oSettings, 'bVisible' ),\n			headerCells = $('th', oSettings.nTHead),\n			tableWidthAttr = table.getAttribute('width'), // from DOM element\n			tableContainer = table.parentNode,\n			userInputs = false,\n			i, column, columnIdx, width, outerWidth,\n			browser = oSettings.oBrowser,\n			ie67 = browser.bScrollOversize;\n	\n		var styleWidth = table.style.width;\n		if ( styleWidth && styleWidth.indexOf('%') !== -1 ) {\n			tableWidthAttr = styleWidth;\n		}\n	\n		/* Convert any user input sizes into pixel sizes */\n		for ( i=0 ; i<visibleColumns.length ; i++ ) {\n			column = columns[ visibleColumns[i] ];\n	\n			if ( column.sWidth !== null ) {\n				column.sWidth = _fnConvertToWidth( column.sWidthOrig, tableContainer );\n	\n				userInputs = true;\n			}\n		}\n	\n		/* If the number of columns in the DOM equals the number that we have to\n		 * process in DataTables, then we can use the offsets that are created by\n		 * the web- browser. No custom sizes can be set in order for this to happen,\n		 * nor scrolling used\n		 */\n		if ( ie67 || ! userInputs && ! scrollX && ! scrollY &&\n		     columnCount == _fnVisbleColumns( oSettings ) &&\n		     columnCount == headerCells.length\n		) {\n			for ( i=0 ; i<columnCount ; i++ ) {\n				var colIdx = _fnVisibleToColumnIndex( oSettings, i );\n	\n				if ( colIdx !== null ) {\n					columns[ colIdx ].sWidth = _fnStringToCss( headerCells.eq(i).width() );\n				}\n			}\n		}\n		else\n		{\n			// Otherwise construct a single row, worst case, table with the widest\n			// node in the data, assign any user defined widths, then insert it into\n			// the DOM and allow the browser to do all the hard work of calculating\n			// table widths\n			var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table\n				.css( 'visibility', 'hidden' )\n				.removeAttr( 'id' );\n	\n			// Clean up the table body\n			tmpTable.find('tbody tr').remove();\n			var tr = $('<tr/>').appendTo( tmpTable.find('tbody') );\n	\n			// Clone the table header and footer - we can't use the header / footer\n			// from the cloned table, since if scrolling is active, the table's\n			// real header and footer are contained in different table tags\n			tmpTable.find('thead, tfoot').remove();\n			tmpTable\n				.append( $(oSettings.nTHead).clone() )\n				.append( $(oSettings.nTFoot).clone() );\n	\n			// Remove any assigned widths from the footer (from scrolling)\n			tmpTable.find('tfoot th, tfoot td').css('width', '');\n	\n			// Apply custom sizing to the cloned header\n			headerCells = _fnGetUniqueThs( oSettings, tmpTable.find('thead')[0] );\n	\n			for ( i=0 ; i<visibleColumns.length ; i++ ) {\n				column = columns[ visibleColumns[i] ];\n	\n				headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?\n					_fnStringToCss( column.sWidthOrig ) :\n					'';\n	\n				// For scrollX we need to force the column width otherwise the\n				// browser will collapse it. If this width is smaller than the\n				// width the column requires, then it will have no effect\n				if ( column.sWidthOrig && scrollX ) {\n					$( headerCells[i] ).append( $('<div/>').css( {\n						width: column.sWidthOrig,\n						margin: 0,\n						padding: 0,\n						border: 0,\n						height: 1\n					} ) );\n				}\n			}\n	\n			// Find the widest cell for each column and put it into the table\n			if ( oSettings.aoData.length ) {\n				for ( i=0 ; i<visibleColumns.length ; i++ ) {\n					columnIdx = visibleColumns[i];\n					column = columns[ columnIdx ];\n	\n					$( _fnGetWidestNode( oSettings, columnIdx ) )\n						.clone( false )\n						.append( column.sContentPadding )\n						.appendTo( tr );\n				}\n			}\n	\n			// Table has been built, attach to the document so we can work with it.\n			// A holding element is used, positioned at the top of the container\n			// with minimal height, so it has no effect on if the container scrolls\n			// or not. Otherwise it might trigger scrolling when it actually isn't\n			// needed\n			var holder = $('<div/>').css( scrollX || scrollY ?\n					{\n						position: 'absolute',\n						top: 0,\n						left: 0,\n						height: 1,\n						right: 0,\n						overflow: 'hidden'\n					} :\n					{}\n				)\n				.append( tmpTable )\n				.appendTo( tableContainer );\n	\n			// When scrolling (X or Y) we want to set the width of the table as \n			// appropriate. However, when not scrolling leave the table width as it\n			// is. This results in slightly different, but I think correct behaviour\n			if ( scrollX && scrollXInner ) {\n				tmpTable.width( scrollXInner );\n			}\n			else if ( scrollX ) {\n				tmpTable.css( 'width', 'auto' );\n				tmpTable.removeAttr('width');\n	\n				// If there is no width attribute or style, then allow the table to\n				// collapse\n				if ( tmpTable.width() < tableContainer.clientWidth && tableWidthAttr ) {\n					tmpTable.width( tableContainer.clientWidth );\n				}\n			}\n			else if ( scrollY ) {\n				tmpTable.width( tableContainer.clientWidth );\n			}\n			else if ( tableWidthAttr ) {\n				tmpTable.width( tableWidthAttr );\n			}\n	\n			// Get the width of each column in the constructed table - we need to\n			// know the inner width (so it can be assigned to the other table's\n			// cells) and the outer width so we can calculate the full width of the\n			// table. This is safe since DataTables requires a unique cell for each\n			// column, but if ever a header can span multiple columns, this will\n			// need to be modified.\n			var total = 0;\n			for ( i=0 ; i<visibleColumns.length ; i++ ) {\n				var cell = $(headerCells[i]);\n				var border = cell.outerWidth() - cell.width();\n	\n				// Use getBounding... where possible (not IE8-) because it can give\n				// sub-pixel accuracy, which we then want to round up!\n				var bounding = browser.bBounding ?\n					Math.ceil( headerCells[i].getBoundingClientRect().width ) :\n					cell.outerWidth();\n	\n				// Total is tracked to remove any sub-pixel errors as the outerWidth\n				// of the table might not equal the total given here (IE!).\n				total += bounding;\n	\n				// Width for each column to use\n				columns[ visibleColumns[i] ].sWidth = _fnStringToCss( bounding - border );\n			}\n	\n			table.style.width = _fnStringToCss( total );\n	\n			// Finished with the table - ditch it\n			holder.remove();\n		}\n	\n		// If there is a width attr, we want to attach an event listener which\n		// allows the table sizing to automatically adjust when the window is\n		// resized. Use the width attr rather than CSS, since we can't know if the\n		// CSS is a relative value or absolute - DOM read is always px.\n		if ( tableWidthAttr ) {\n			table.style.width = _fnStringToCss( tableWidthAttr );\n		}\n	\n		if ( (tableWidthAttr || scrollX) && ! oSettings._reszEvt ) {\n			var bindResize = function () {\n				$(window).bind('resize.DT-'+oSettings.sInstance, _fnThrottle( function () {\n					_fnAdjustColumnSizing( oSettings );\n				} ) );\n			};\n	\n			// IE6/7 will crash if we bind a resize event handler on page load.\n			// To be removed in 1.11 which drops IE6/7 support\n			if ( ie67 ) {\n				setTimeout( bindResize, 1000 );\n			}\n			else {\n				bindResize();\n			}\n	\n			oSettings._reszEvt = true;\n		}\n	}\n	\n	\n	/**\n	 * Throttle the calls to a function. Arguments and context are maintained for\n	 * the throttled function\n	 *  @param {function} fn Function to be called\n	 *  @param {int} [freq=200] call frequency in mS\n	 *  @returns {function} wrapped function\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnThrottle( fn, freq ) {\n		var\n			frequency = freq !== undefined ? freq : 200,\n			last,\n			timer;\n	\n		return function () {\n			var\n				that = this,\n				now  = +new Date(),\n				args = arguments;\n	\n			if ( last && now < last + frequency ) {\n				clearTimeout( timer );\n	\n				timer = setTimeout( function () {\n					last = undefined;\n					fn.apply( that, args );\n				}, frequency );\n			}\n			else {\n				last = now;\n				fn.apply( that, args );\n			}\n		};\n	}\n	\n	\n	/**\n	 * Convert a CSS unit width to pixels (e.g. 2em)\n	 *  @param {string} width width to be converted\n	 *  @param {node} parent parent to get the with for (required for relative widths) - optional\n	 *  @returns {int} width in pixels\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnConvertToWidth ( width, parent )\n	{\n		if ( ! width ) {\n			return 0;\n		}\n	\n		var n = $('<div/>')\n			.css( 'width', _fnStringToCss( width ) )\n			.appendTo( parent || document.body );\n	\n		var val = n[0].offsetWidth;\n		n.remove();\n	\n		return val;\n	}\n	\n	\n	/**\n	 * Get the widest node\n	 *  @param {object} settings dataTables settings object\n	 *  @param {int} colIdx column of interest\n	 *  @returns {node} widest table node\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnGetWidestNode( settings, colIdx )\n	{\n		var idx = _fnGetMaxLenString( settings, colIdx );\n		if ( idx < 0 ) {\n			return null;\n		}\n	\n		var data = settings.aoData[ idx ];\n		return ! data.nTr ? // Might not have been created when deferred rendering\n			$('<td/>').html( _fnGetCellData( settings, idx, colIdx, 'display' ) )[0] :\n			data.anCells[ colIdx ];\n	}\n	\n	\n	/**\n	 * Get the maximum strlen for each data column\n	 *  @param {object} settings dataTables settings object\n	 *  @param {int} colIdx column of interest\n	 *  @returns {string} max string length for each column\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnGetMaxLenString( settings, colIdx )\n	{\n		var s, max=-1, maxIdx = -1;\n	\n		for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {\n			s = _fnGetCellData( settings, i, colIdx, 'display' )+'';\n			s = s.replace( __re_html_remove, '' );\n			s = s.replace( /&nbsp;/g, ' ' );\n	\n			if ( s.length > max ) {\n				max = s.length;\n				maxIdx = i;\n			}\n		}\n	\n		return maxIdx;\n	}\n	\n	\n	/**\n	 * Append a CSS unit (only if required) to a string\n	 *  @param {string} value to css-ify\n	 *  @returns {string} value with css unit\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnStringToCss( s )\n	{\n		if ( s === null ) {\n			return '0px';\n		}\n	\n		if ( typeof s == 'number' ) {\n			return s < 0 ?\n				'0px' :\n				s+'px';\n		}\n	\n		// Check it has a unit character already\n		return s.match(/\\d$/) ?\n			s+'px' :\n			s;\n	}\n	\n	\n	\n	function _fnSortFlatten ( settings )\n	{\n		var\n			i, iLen, k, kLen,\n			aSort = [],\n			aiOrig = [],\n			aoColumns = settings.aoColumns,\n			aDataSort, iCol, sType, srcCol,\n			fixed = settings.aaSortingFixed,\n			fixedObj = $.isPlainObject( fixed ),\n			nestedSort = [],\n			add = function ( a ) {\n				if ( a.length && ! $.isArray( a[0] ) ) {\n					// 1D array\n					nestedSort.push( a );\n				}\n				else {\n					// 2D array\n					$.merge( nestedSort, a );\n				}\n			};\n	\n		// Build the sort array, with pre-fix and post-fix options if they have been\n		// specified\n		if ( $.isArray( fixed ) ) {\n			add( fixed );\n		}\n	\n		if ( fixedObj && fixed.pre ) {\n			add( fixed.pre );\n		}\n	\n		add( settings.aaSorting );\n	\n		if (fixedObj && fixed.post ) {\n			add( fixed.post );\n		}\n	\n		for ( i=0 ; i<nestedSort.length ; i++ )\n		{\n			srcCol = nestedSort[i][0];\n			aDataSort = aoColumns[ srcCol ].aDataSort;\n	\n			for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )\n			{\n				iCol = aDataSort[k];\n				sType = aoColumns[ iCol ].sType || 'string';\n	\n				if ( nestedSort[i]._idx === undefined ) {\n					nestedSort[i]._idx = $.inArray( nestedSort[i][1], aoColumns[iCol].asSorting );\n				}\n	\n				aSort.push( {\n					src:       srcCol,\n					col:       iCol,\n					dir:       nestedSort[i][1],\n					index:     nestedSort[i]._idx,\n					type:      sType,\n					formatter: DataTable.ext.type.order[ sType+\"-pre\" ]\n				} );\n			}\n		}\n	\n		return aSort;\n	}\n	\n	/**\n	 * Change the order of the table\n	 *  @param {object} oSettings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 *  @todo This really needs split up!\n	 */\n	function _fnSort ( oSettings )\n	{\n		var\n			i, ien, iLen, j, jLen, k, kLen,\n			sDataType, nTh,\n			aiOrig = [],\n			oExtSort = DataTable.ext.type.order,\n			aoData = oSettings.aoData,\n			aoColumns = oSettings.aoColumns,\n			aDataSort, data, iCol, sType, oSort,\n			formatters = 0,\n			sortCol,\n			displayMaster = oSettings.aiDisplayMaster,\n			aSort;\n	\n		// Resolve any column types that are unknown due to addition or invalidation\n		// @todo Can this be moved into a 'data-ready' handler which is called when\n		//   data is going to be used in the table?\n		_fnColumnTypes( oSettings );\n	\n		aSort = _fnSortFlatten( oSettings );\n	\n		for ( i=0, ien=aSort.length ; i<ien ; i++ ) {\n			sortCol = aSort[i];\n	\n			// Track if we can use the fast sort algorithm\n			if ( sortCol.formatter ) {\n				formatters++;\n			}\n	\n			// Load the data needed for the sort, for each cell\n			_fnSortData( oSettings, sortCol.col );\n		}\n	\n		/* No sorting required if server-side or no sorting array */\n		if ( _fnDataSource( oSettings ) != 'ssp' && aSort.length !== 0 )\n		{\n			// Create a value - key array of the current row positions such that we can use their\n			// current position during the sort, if values match, in order to perform stable sorting\n			for ( i=0, iLen=displayMaster.length ; i<iLen ; i++ ) {\n				aiOrig[ displayMaster[i] ] = i;\n			}\n	\n			/* Do the sort - here we want multi-column sorting based on a given data source (column)\n			 * and sorting function (from oSort) in a certain direction. It's reasonably complex to\n			 * follow on it's own, but this is what we want (example two column sorting):\n			 *  fnLocalSorting = function(a,b){\n			 *    var iTest;\n			 *    iTest = oSort['string-asc']('data11', 'data12');\n			 *      if (iTest !== 0)\n			 *        return iTest;\n			 *    iTest = oSort['numeric-desc']('data21', 'data22');\n			 *    if (iTest !== 0)\n			 *      return iTest;\n			 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );\n			 *  }\n			 * Basically we have a test for each sorting column, if the data in that column is equal,\n			 * test the next column. If all columns match, then we use a numeric sort on the row\n			 * positions in the original data array to provide a stable sort.\n			 *\n			 * Note - I know it seems excessive to have two sorting methods, but the first is around\n			 * 15% faster, so the second is only maintained for backwards compatibility with sorting\n			 * methods which do not have a pre-sort formatting function.\n			 */\n			if ( formatters === aSort.length ) {\n				// All sort types have formatting functions\n				displayMaster.sort( function ( a, b ) {\n					var\n						x, y, k, test, sort,\n						len=aSort.length,\n						dataA = aoData[a]._aSortData,\n						dataB = aoData[b]._aSortData;\n	\n					for ( k=0 ; k<len ; k++ ) {\n						sort = aSort[k];\n	\n						x = dataA[ sort.col ];\n						y = dataB[ sort.col ];\n	\n						test = x<y ? -1 : x>y ? 1 : 0;\n						if ( test !== 0 ) {\n							return sort.dir === 'asc' ? test : -test;\n						}\n					}\n	\n					x = aiOrig[a];\n					y = aiOrig[b];\n					return x<y ? -1 : x>y ? 1 : 0;\n				} );\n			}\n			else {\n				// Depreciated - remove in 1.11 (providing a plug-in option)\n				// Not all sort types have formatting methods, so we have to call their sorting\n				// methods.\n				displayMaster.sort( function ( a, b ) {\n					var\n						x, y, k, l, test, sort, fn,\n						len=aSort.length,\n						dataA = aoData[a]._aSortData,\n						dataB = aoData[b]._aSortData;\n	\n					for ( k=0 ; k<len ; k++ ) {\n						sort = aSort[k];\n	\n						x = dataA[ sort.col ];\n						y = dataB[ sort.col ];\n	\n						fn = oExtSort[ sort.type+\"-\"+sort.dir ] || oExtSort[ \"string-\"+sort.dir ];\n						test = fn( x, y );\n						if ( test !== 0 ) {\n							return test;\n						}\n					}\n	\n					x = aiOrig[a];\n					y = aiOrig[b];\n					return x<y ? -1 : x>y ? 1 : 0;\n				} );\n			}\n		}\n	\n		/* Tell the draw function that we have sorted the data */\n		oSettings.bSorted = true;\n	}\n	\n	\n	function _fnSortAria ( settings )\n	{\n		var label;\n		var nextSort;\n		var columns = settings.aoColumns;\n		var aSort = _fnSortFlatten( settings );\n		var oAria = settings.oLanguage.oAria;\n	\n		// ARIA attributes - need to loop all columns, to update all (removing old\n		// attributes as needed)\n		for ( var i=0, iLen=columns.length ; i<iLen ; i++ )\n		{\n			var col = columns[i];\n			var asSorting = col.asSorting;\n			var sTitle = col.sTitle.replace( /<.*?>/g, \"\" );\n			var th = col.nTh;\n	\n			// IE7 is throwing an error when setting these properties with jQuery's\n			// attr() and removeAttr() methods...\n			th.removeAttribute('aria-sort');\n	\n			/* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */\n			if ( col.bSortable ) {\n				if ( aSort.length > 0 && aSort[0].col == i ) {\n					th.setAttribute('aria-sort', aSort[0].dir==\"asc\" ? \"ascending\" : \"descending\" );\n					nextSort = asSorting[ aSort[0].index+1 ] || asSorting[0];\n				}\n				else {\n					nextSort = asSorting[0];\n				}\n	\n				label = sTitle + ( nextSort === \"asc\" ?\n					oAria.sSortAscending :\n					oAria.sSortDescending\n				);\n			}\n			else {\n				label = sTitle;\n			}\n	\n			th.setAttribute('aria-label', label);\n		}\n	}\n	\n	\n	/**\n	 * Function to run on user sort request\n	 *  @param {object} settings dataTables settings object\n	 *  @param {node} attachTo node to attach the handler to\n	 *  @param {int} colIdx column sorting index\n	 *  @param {boolean} [append=false] Append the requested sort to the existing\n	 *    sort if true (i.e. multi-column sort)\n	 *  @param {function} [callback] callback function\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnSortListener ( settings, colIdx, append, callback )\n	{\n		var col = settings.aoColumns[ colIdx ];\n		var sorting = settings.aaSorting;\n		var asSorting = col.asSorting;\n		var nextSortIdx;\n		var next = function ( a, overflow ) {\n			var idx = a._idx;\n			if ( idx === undefined ) {\n				idx = $.inArray( a[1], asSorting );\n			}\n	\n			return idx+1 < asSorting.length ?\n				idx+1 :\n				overflow ?\n					null :\n					0;\n		};\n	\n		// Convert to 2D array if needed\n		if ( typeof sorting[0] === 'number' ) {\n			sorting = settings.aaSorting = [ sorting ];\n		}\n	\n		// If appending the sort then we are multi-column sorting\n		if ( append && settings.oFeatures.bSortMulti ) {\n			// Are we already doing some kind of sort on this column?\n			var sortIdx = $.inArray( colIdx, _pluck(sorting, '0') );\n	\n			if ( sortIdx !== -1 ) {\n				// Yes, modify the sort\n				nextSortIdx = next( sorting[sortIdx], true );\n	\n				if ( nextSortIdx === null && sorting.length === 1 ) {\n					nextSortIdx = 0; // can't remove sorting completely\n				}\n	\n				if ( nextSortIdx === null ) {\n					sorting.splice( sortIdx, 1 );\n				}\n				else {\n					sorting[sortIdx][1] = asSorting[ nextSortIdx ];\n					sorting[sortIdx]._idx = nextSortIdx;\n				}\n			}\n			else {\n				// No sort on this column yet\n				sorting.push( [ colIdx, asSorting[0], 0 ] );\n				sorting[sorting.length-1]._idx = 0;\n			}\n		}\n		else if ( sorting.length && sorting[0][0] == colIdx ) {\n			// Single column - already sorting on this column, modify the sort\n			nextSortIdx = next( sorting[0] );\n	\n			sorting.length = 1;\n			sorting[0][1] = asSorting[ nextSortIdx ];\n			sorting[0]._idx = nextSortIdx;\n		}\n		else {\n			// Single column - sort only on this column\n			sorting.length = 0;\n			sorting.push( [ colIdx, asSorting[0] ] );\n			sorting[0]._idx = 0;\n		}\n	\n		// Run the sort by calling a full redraw\n		_fnReDraw( settings );\n	\n		// callback used for async user interaction\n		if ( typeof callback == 'function' ) {\n			callback( settings );\n		}\n	}\n	\n	\n	/**\n	 * Attach a sort handler (click) to a node\n	 *  @param {object} settings dataTables settings object\n	 *  @param {node} attachTo node to attach the handler to\n	 *  @param {int} colIdx column sorting index\n	 *  @param {function} [callback] callback function\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnSortAttachListener ( settings, attachTo, colIdx, callback )\n	{\n		var col = settings.aoColumns[ colIdx ];\n	\n		_fnBindAction( attachTo, {}, function (e) {\n			/* If the column is not sortable - don't to anything */\n			if ( col.bSortable === false ) {\n				return;\n			}\n	\n			// If processing is enabled use a timeout to allow the processing\n			// display to be shown - otherwise to it synchronously\n			if ( settings.oFeatures.bProcessing ) {\n				_fnProcessingDisplay( settings, true );\n	\n				setTimeout( function() {\n					_fnSortListener( settings, colIdx, e.shiftKey, callback );\n	\n					// In server-side processing, the draw callback will remove the\n					// processing display\n					if ( _fnDataSource( settings ) !== 'ssp' ) {\n						_fnProcessingDisplay( settings, false );\n					}\n				}, 0 );\n			}\n			else {\n				_fnSortListener( settings, colIdx, e.shiftKey, callback );\n			}\n		} );\n	}\n	\n	\n	/**\n	 * Set the sorting classes on table's body, Note: it is safe to call this function\n	 * when bSort and bSortClasses are false\n	 *  @param {object} oSettings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnSortingClasses( settings )\n	{\n		var oldSort = settings.aLastSort;\n		var sortClass = settings.oClasses.sSortColumn;\n		var sort = _fnSortFlatten( settings );\n		var features = settings.oFeatures;\n		var i, ien, colIdx;\n	\n		if ( features.bSort && features.bSortClasses ) {\n			// Remove old sorting classes\n			for ( i=0, ien=oldSort.length ; i<ien ; i++ ) {\n				colIdx = oldSort[i].src;\n	\n				// Remove column sorting\n				$( _pluck( settings.aoData, 'anCells', colIdx ) )\n					.removeClass( sortClass + (i<2 ? i+1 : 3) );\n			}\n	\n			// Add new column sorting\n			for ( i=0, ien=sort.length ; i<ien ; i++ ) {\n				colIdx = sort[i].src;\n	\n				$( _pluck( settings.aoData, 'anCells', colIdx ) )\n					.addClass( sortClass + (i<2 ? i+1 : 3) );\n			}\n		}\n	\n		settings.aLastSort = sort;\n	}\n	\n	\n	// Get the data to sort a column, be it from cache, fresh (populating the\n	// cache), or from a sort formatter\n	function _fnSortData( settings, idx )\n	{\n		// Custom sorting function - provided by the sort data type\n		var column = settings.aoColumns[ idx ];\n		var customSort = DataTable.ext.order[ column.sSortDataType ];\n		var customData;\n	\n		if ( customSort ) {\n			customData = customSort.call( settings.oInstance, settings, idx,\n				_fnColumnIndexToVisible( settings, idx )\n			);\n		}\n	\n		// Use / populate cache\n		var row, cellData;\n		var formatter = DataTable.ext.type.order[ column.sType+\"-pre\" ];\n	\n		for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {\n			row = settings.aoData[i];\n	\n			if ( ! row._aSortData ) {\n				row._aSortData = [];\n			}\n	\n			if ( ! row._aSortData[idx] || customSort ) {\n				cellData = customSort ?\n					customData[i] : // If there was a custom sort function, use data from there\n					_fnGetCellData( settings, i, idx, 'sort' );\n	\n				row._aSortData[ idx ] = formatter ?\n					formatter( cellData ) :\n					cellData;\n			}\n		}\n	}\n	\n	\n	\n	/**\n	 * Save the state of a table\n	 *  @param {object} oSettings dataTables settings object\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnSaveState ( settings )\n	{\n		if ( !settings.oFeatures.bStateSave || settings.bDestroying )\n		{\n			return;\n		}\n	\n		/* Store the interesting variables */\n		var state = {\n			time:    +new Date(),\n			start:   settings._iDisplayStart,\n			length:  settings._iDisplayLength,\n			order:   $.extend( true, [], settings.aaSorting ),\n			search:  _fnSearchToCamel( settings.oPreviousSearch ),\n			columns: $.map( settings.aoColumns, function ( col, i ) {\n				return {\n					visible: col.bVisible,\n					search: _fnSearchToCamel( settings.aoPreSearchCols[i] )\n				};\n			} )\n		};\n	\n		_fnCallbackFire( settings, \"aoStateSaveParams\", 'stateSaveParams', [settings, state] );\n	\n		settings.oSavedState = state;\n		settings.fnStateSaveCallback.call( settings.oInstance, settings, state );\n	}\n	\n	\n	/**\n	 * Attempt to load a saved table state\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {object} oInit DataTables init object so we can override settings\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnLoadState ( settings, oInit )\n	{\n		var i, ien;\n		var columns = settings.aoColumns;\n	\n		if ( ! settings.oFeatures.bStateSave ) {\n			return;\n		}\n	\n		var state = settings.fnStateLoadCallback.call( settings.oInstance, settings );\n		if ( ! state || ! state.time ) {\n			return;\n		}\n	\n		/* Allow custom and plug-in manipulation functions to alter the saved data set and\n		 * cancelling of loading by returning false\n		 */\n		var abStateLoad = _fnCallbackFire( settings, 'aoStateLoadParams', 'stateLoadParams', [settings, state] );\n		if ( $.inArray( false, abStateLoad ) !== -1 ) {\n			return;\n		}\n	\n		/* Reject old data */\n		var duration = settings.iStateDuration;\n		if ( duration > 0 && state.time < +new Date() - (duration*1000) ) {\n			return;\n		}\n	\n		// Number of columns have changed - all bets are off, no restore of settings\n		if ( columns.length !== state.columns.length ) {\n			return;\n		}\n	\n		// Store the saved state so it might be accessed at any time\n		settings.oLoadedState = $.extend( true, {}, state );\n	\n		// Restore key features - todo - for 1.11 this needs to be done by\n		// subscribed events\n		if ( state.start !== undefined ) {\n			settings._iDisplayStart    = state.start;\n			settings.iInitDisplayStart = state.start;\n		}\n		if ( state.length !== undefined ) {\n			settings._iDisplayLength   = state.length;\n		}\n	\n		// Order\n		if ( state.order !== undefined ) {\n			settings.aaSorting = [];\n			$.each( state.order, function ( i, col ) {\n				settings.aaSorting.push( col[0] >= columns.length ?\n					[ 0, col[1] ] :\n					col\n				);\n			} );\n		}\n	\n		// Search\n		if ( state.search !== undefined ) {\n			$.extend( settings.oPreviousSearch, _fnSearchToHung( state.search ) );\n		}\n	\n		// Columns\n		for ( i=0, ien=state.columns.length ; i<ien ; i++ ) {\n			var col = state.columns[i];\n	\n			// Visibility\n			if ( col.visible !== undefined ) {\n				columns[i].bVisible = col.visible;\n			}\n	\n			// Search\n			if ( col.search !== undefined ) {\n				$.extend( settings.aoPreSearchCols[i], _fnSearchToHung( col.search ) );\n			}\n		}\n	\n		_fnCallbackFire( settings, 'aoStateLoaded', 'stateLoaded', [settings, state] );\n	}\n	\n	\n	/**\n	 * Return the settings object for a particular table\n	 *  @param {node} table table we are using as a dataTable\n	 *  @returns {object} Settings object - or null if not found\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnSettingsFromNode ( table )\n	{\n		var settings = DataTable.settings;\n		var idx = $.inArray( table, _pluck( settings, 'nTable' ) );\n	\n		return idx !== -1 ?\n			settings[ idx ] :\n			null;\n	}\n	\n	\n	/**\n	 * Log an error message\n	 *  @param {object} settings dataTables settings object\n	 *  @param {int} level log error messages, or display them to the user\n	 *  @param {string} msg error message\n	 *  @param {int} tn Technical note id to get more information about the error.\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnLog( settings, level, msg, tn )\n	{\n		msg = 'DataTables warning: '+\n			(settings ? 'table id='+settings.sTableId+' - ' : '')+msg;\n	\n		if ( tn ) {\n			msg += '. For more information about this error, please see '+\n			'http://datatables.net/tn/'+tn;\n		}\n	\n		if ( ! level  ) {\n			// Backwards compatibility pre 1.10\n			var ext = DataTable.ext;\n			var type = ext.sErrMode || ext.errMode;\n	\n			if ( settings ) {\n				_fnCallbackFire( settings, null, 'error', [ settings, tn, msg ] );\n			}\n	\n			if ( type == 'alert' ) {\n				alert( msg );\n			}\n			else if ( type == 'throw' ) {\n				throw new Error(msg);\n			}\n			else if ( typeof type == 'function' ) {\n				type( settings, tn, msg );\n			}\n		}\n		else if ( window.console && console.log ) {\n			console.log( msg );\n		}\n	}\n	\n	\n	/**\n	 * See if a property is defined on one object, if so assign it to the other object\n	 *  @param {object} ret target object\n	 *  @param {object} src source object\n	 *  @param {string} name property\n	 *  @param {string} [mappedName] name to map too - optional, name used if not given\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnMap( ret, src, name, mappedName )\n	{\n		if ( $.isArray( name ) ) {\n			$.each( name, function (i, val) {\n				if ( $.isArray( val ) ) {\n					_fnMap( ret, src, val[0], val[1] );\n				}\n				else {\n					_fnMap( ret, src, val );\n				}\n			} );\n	\n			return;\n		}\n	\n		if ( mappedName === undefined ) {\n			mappedName = name;\n		}\n	\n		if ( src[name] !== undefined ) {\n			ret[mappedName] = src[name];\n		}\n	}\n	\n	\n	/**\n	 * Extend objects - very similar to jQuery.extend, but deep copy objects, and\n	 * shallow copy arrays. The reason we need to do this, is that we don't want to\n	 * deep copy array init values (such as aaSorting) since the dev wouldn't be\n	 * able to override them, but we do want to deep copy arrays.\n	 *  @param {object} out Object to extend\n	 *  @param {object} extender Object from which the properties will be applied to\n	 *      out\n	 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an\n	 *      independent copy with the exception of the `data` or `aaData` parameters\n	 *      if they are present. This is so you can pass in a collection to\n	 *      DataTables and have that used as your data source without breaking the\n	 *      references\n	 *  @returns {object} out Reference, just for convenience - out === the return.\n	 *  @memberof DataTable#oApi\n	 *  @todo This doesn't take account of arrays inside the deep copied objects.\n	 */\n	function _fnExtend( out, extender, breakRefs )\n	{\n		var val;\n	\n		for ( var prop in extender ) {\n			if ( extender.hasOwnProperty(prop) ) {\n				val = extender[prop];\n	\n				if ( $.isPlainObject( val ) ) {\n					if ( ! $.isPlainObject( out[prop] ) ) {\n						out[prop] = {};\n					}\n					$.extend( true, out[prop], val );\n				}\n				else if ( breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val) ) {\n					out[prop] = val.slice();\n				}\n				else {\n					out[prop] = val;\n				}\n			}\n		}\n	\n		return out;\n	}\n	\n	\n	/**\n	 * Bind an event handers to allow a click or return key to activate the callback.\n	 * This is good for accessibility since a return on the keyboard will have the\n	 * same effect as a click, if the element has focus.\n	 *  @param {element} n Element to bind the action to\n	 *  @param {object} oData Data object to pass to the triggered function\n	 *  @param {function} fn Callback function for when the event is triggered\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnBindAction( n, oData, fn )\n	{\n		$(n)\n			.bind( 'click.DT', oData, function (e) {\n					n.blur(); // Remove focus outline for mouse users\n					fn(e);\n				} )\n			.bind( 'keypress.DT', oData, function (e){\n					if ( e.which === 13 ) {\n						e.preventDefault();\n						fn(e);\n					}\n				} )\n			.bind( 'selectstart.DT', function () {\n					/* Take the brutal approach to cancelling text selection */\n					return false;\n				} );\n	}\n	\n	\n	/**\n	 * Register a callback function. Easily allows a callback function to be added to\n	 * an array store of callback functions that can then all be called together.\n	 *  @param {object} oSettings dataTables settings object\n	 *  @param {string} sStore Name of the array storage for the callbacks in oSettings\n	 *  @param {function} fn Function to be called back\n	 *  @param {string} sName Identifying name for the callback (i.e. a label)\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnCallbackReg( oSettings, sStore, fn, sName )\n	{\n		if ( fn )\n		{\n			oSettings[sStore].push( {\n				\"fn\": fn,\n				\"sName\": sName\n			} );\n		}\n	}\n	\n	\n	/**\n	 * Fire callback functions and trigger events. Note that the loop over the\n	 * callback array store is done backwards! Further note that you do not want to\n	 * fire off triggers in time sensitive applications (for example cell creation)\n	 * as its slow.\n	 *  @param {object} settings dataTables settings object\n	 *  @param {string} callbackArr Name of the array storage for the callbacks in\n	 *      oSettings\n	 *  @param {string} eventName Name of the jQuery custom event to trigger. If\n	 *      null no trigger is fired\n	 *  @param {array} args Array of arguments to pass to the callback function /\n	 *      trigger\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnCallbackFire( settings, callbackArr, eventName, args )\n	{\n		var ret = [];\n	\n		if ( callbackArr ) {\n			ret = $.map( settings[callbackArr].slice().reverse(), function (val, i) {\n				return val.fn.apply( settings.oInstance, args );\n			} );\n		}\n	\n		if ( eventName !== null ) {\n			var e = $.Event( eventName+'.dt' );\n	\n			$(settings.nTable).trigger( e, args );\n	\n			ret.push( e.result );\n		}\n	\n		return ret;\n	}\n	\n	\n	function _fnLengthOverflow ( settings )\n	{\n		var\n			start = settings._iDisplayStart,\n			end = settings.fnDisplayEnd(),\n			len = settings._iDisplayLength;\n	\n		/* If we have space to show extra rows (backing up from the end point - then do so */\n		if ( start >= end )\n		{\n			start = end - len;\n		}\n	\n		// Keep the start record on the current page\n		start -= (start % len);\n	\n		if ( len === -1 || start < 0 )\n		{\n			start = 0;\n		}\n	\n		settings._iDisplayStart = start;\n	}\n	\n	\n	function _fnRenderer( settings, type )\n	{\n		var renderer = settings.renderer;\n		var host = DataTable.ext.renderer[type];\n	\n		if ( $.isPlainObject( renderer ) && renderer[type] ) {\n			// Specific renderer for this type. If available use it, otherwise use\n			// the default.\n			return host[renderer[type]] || host._;\n		}\n		else if ( typeof renderer === 'string' ) {\n			// Common renderer - if there is one available for this type use it,\n			// otherwise use the default\n			return host[renderer] || host._;\n		}\n	\n		// Use the default\n		return host._;\n	}\n	\n	\n	/**\n	 * Detect the data source being used for the table. Used to simplify the code\n	 * a little (ajax) and to make it compress a little smaller.\n	 *\n	 *  @param {object} settings dataTables settings object\n	 *  @returns {string} Data source\n	 *  @memberof DataTable#oApi\n	 */\n	function _fnDataSource ( settings )\n	{\n		if ( settings.oFeatures.bServerSide ) {\n			return 'ssp';\n		}\n		else if ( settings.ajax || settings.sAjaxSource ) {\n			return 'ajax';\n		}\n		return 'dom';\n	}\n	\n\n	DataTable = function( options )\n	{\n		/**\n		 * Perform a jQuery selector action on the table's TR elements (from the tbody) and\n		 * return the resulting jQuery object.\n		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on\n		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included\n		 *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter\n		 *    criterion (\"applied\") or all TR elements (i.e. no filter).\n		 *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.\n		 *    Can be either 'current', whereby the current sorting of the table is used, or\n		 *    'original' whereby the original order the data was read into the table is used.\n		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page\n		 *    (\"current\") or not (\"all\"). If 'current' is given, then order is assumed to be\n		 *    'current' and filter is 'applied', regardless of what they might be given as.\n		 *  @returns {object} jQuery object, filtered by the given selector.\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *\n		 *      // Highlight every second row\n		 *      oTable.$('tr:odd').css('backgroundColor', 'blue');\n		 *    } );\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *\n		 *      // Filter to rows with 'Webkit' in them, add a background colour and then\n		 *      // remove the filter, thus highlighting the 'Webkit' rows only.\n		 *      oTable.fnFilter('Webkit');\n		 *      oTable.$('tr', {\"search\": \"applied\"}).css('backgroundColor', 'blue');\n		 *      oTable.fnFilter('');\n		 *    } );\n		 */\n		this.$ = function ( sSelector, oOpts )\n		{\n			return this.api(true).$( sSelector, oOpts );\n		};\n		\n		\n		/**\n		 * Almost identical to $ in operation, but in this case returns the data for the matched\n		 * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes\n		 * rather than any descendants, so the data can be obtained for the row/cell. If matching\n		 * rows are found, the data returned is the original data array/object that was used to\n		 * create the row (or a generated array if from a DOM source).\n		 *\n		 * This method is often useful in-combination with $ where both functions are given the\n		 * same parameters and the array indexes will match identically.\n		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on\n		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included\n		 *  @param {string} [oOpts.filter=none] Select elements that meet the current filter\n		 *    criterion (\"applied\") or all elements (i.e. no filter).\n		 *  @param {string} [oOpts.order=current] Order of the data in the processed array.\n		 *    Can be either 'current', whereby the current sorting of the table is used, or\n		 *    'original' whereby the original order the data was read into the table is used.\n		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page\n		 *    (\"current\") or not (\"all\"). If 'current' is given, then order is assumed to be\n		 *    'current' and filter is 'applied', regardless of what they might be given as.\n		 *  @returns {array} Data for the matched elements. If any elements, as a result of the\n		 *    selector, were not TR, TD or TH elements in the DataTable, they will have a null\n		 *    entry in the array.\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *\n		 *      // Get the data from the first row in the table\n		 *      var data = oTable._('tr:first');\n		 *\n		 *      // Do something useful with the data\n		 *      alert( \"First cell is: \"+data[0] );\n		 *    } );\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *\n		 *      // Filter to 'Webkit' and get all data for\n		 *      oTable.fnFilter('Webkit');\n		 *      var data = oTable._('tr', {\"search\": \"applied\"});\n		 *\n		 *      // Do something with the data\n		 *      alert( data.length+\" rows matched the search\" );\n		 *    } );\n		 */\n		this._ = function ( sSelector, oOpts )\n		{\n			return this.api(true).rows( sSelector, oOpts ).data();\n		};\n		\n		\n		/**\n		 * Create a DataTables Api instance, with the currently selected tables for\n		 * the Api's context.\n		 * @param {boolean} [traditional=false] Set the API instance's context to be\n		 *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was\n		 *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),\n		 *   or if all tables captured in the jQuery object should be used.\n		 * @return {DataTables.Api}\n		 */\n		this.api = function ( traditional )\n		{\n			return traditional ?\n				new _Api(\n					_fnSettingsFromNode( this[ _ext.iApiIndex ] )\n				) :\n				new _Api( this );\n		};\n		\n		\n		/**\n		 * Add a single new row or multiple rows of data to the table. Please note\n		 * that this is suitable for client-side processing only - if you are using\n		 * server-side processing (i.e. \"bServerSide\": true), then to add data, you\n		 * must add it to the data source, i.e. the server-side, through an Ajax call.\n		 *  @param {array|object} data The data to be added to the table. This can be:\n		 *    <ul>\n		 *      <li>1D array of data - add a single row with the data provided</li>\n		 *      <li>2D array of arrays - add multiple rows in a single call</li>\n		 *      <li>object - data object when using <i>mData</i></li>\n		 *      <li>array of objects - multiple data objects when using <i>mData</i></li>\n		 *    </ul>\n		 *  @param {bool} [redraw=true] redraw the table or not\n		 *  @returns {array} An array of integers, representing the list of indexes in\n		 *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to\n		 *    the table.\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    // Global var for counter\n		 *    var giCount = 2;\n		 *\n		 *    $(document).ready(function() {\n		 *      $('#example').dataTable();\n		 *    } );\n		 *\n		 *    function fnClickAddRow() {\n		 *      $('#example').dataTable().fnAddData( [\n		 *        giCount+\".1\",\n		 *        giCount+\".2\",\n		 *        giCount+\".3\",\n		 *        giCount+\".4\" ]\n		 *      );\n		 *\n		 *      giCount++;\n		 *    }\n		 */\n		this.fnAddData = function( data, redraw )\n		{\n			var api = this.api( true );\n		\n			/* Check if we want to add multiple rows or not */\n			var rows = $.isArray(data) && ( $.isArray(data[0]) || $.isPlainObject(data[0]) ) ?\n				api.rows.add( data ) :\n				api.row.add( data );\n		\n			if ( redraw === undefined || redraw ) {\n				api.draw();\n			}\n		\n			return rows.flatten().toArray();\n		};\n		\n		\n		/**\n		 * This function will make DataTables recalculate the column sizes, based on the data\n		 * contained in the table and the sizes applied to the columns (in the DOM, CSS or\n		 * through the sWidth parameter). This can be useful when the width of the table's\n		 * parent element changes (for example a window resize).\n		 *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable( {\n		 *        \"sScrollY\": \"200px\",\n		 *        \"bPaginate\": false\n		 *      } );\n		 *\n		 *      $(window).bind('resize', function () {\n		 *        oTable.fnAdjustColumnSizing();\n		 *      } );\n		 *    } );\n		 */\n		this.fnAdjustColumnSizing = function ( bRedraw )\n		{\n			var api = this.api( true ).columns.adjust();\n			var settings = api.settings()[0];\n			var scroll = settings.oScroll;\n		\n			if ( bRedraw === undefined || bRedraw ) {\n				api.draw( false );\n			}\n			else if ( scroll.sX !== \"\" || scroll.sY !== \"\" ) {\n				/* If not redrawing, but scrolling, we want to apply the new column sizes anyway */\n				_fnScrollDraw( settings );\n			}\n		};\n		\n		\n		/**\n		 * Quickly and simply clear a table\n		 *  @param {bool} [bRedraw=true] redraw the table or not\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *\n		 *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)\n		 *      oTable.fnClearTable();\n		 *    } );\n		 */\n		this.fnClearTable = function( bRedraw )\n		{\n			var api = this.api( true ).clear();\n		\n			if ( bRedraw === undefined || bRedraw ) {\n				api.draw();\n			}\n		};\n		\n		\n		/**\n		 * The exact opposite of 'opening' a row, this function will close any rows which\n		 * are currently 'open'.\n		 *  @param {node} nTr the table row to 'close'\n		 *  @returns {int} 0 on success, or 1 if failed (can't find the row)\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable;\n		 *\n		 *      // 'open' an information row when a row is clicked on\n		 *      $('#example tbody tr').click( function () {\n		 *        if ( oTable.fnIsOpen(this) ) {\n		 *          oTable.fnClose( this );\n		 *        } else {\n		 *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n		 *        }\n		 *      } );\n		 *\n		 *      oTable = $('#example').dataTable();\n		 *    } );\n		 */\n		this.fnClose = function( nTr )\n		{\n			this.api( true ).row( nTr ).child.hide();\n		};\n		\n		\n		/**\n		 * Remove a row for the table\n		 *  @param {mixed} target The index of the row from aoData to be deleted, or\n		 *    the TR element you want to delete\n		 *  @param {function|null} [callBack] Callback function\n		 *  @param {bool} [redraw=true] Redraw the table or not\n		 *  @returns {array} The row that was deleted\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *\n		 *      // Immediately remove the first row\n		 *      oTable.fnDeleteRow( 0 );\n		 *    } );\n		 */\n		this.fnDeleteRow = function( target, callback, redraw )\n		{\n			var api = this.api( true );\n			var rows = api.rows( target );\n			var settings = rows.settings()[0];\n			var data = settings.aoData[ rows[0][0] ];\n		\n			rows.remove();\n		\n			if ( callback ) {\n				callback.call( this, settings, data );\n			}\n		\n			if ( redraw === undefined || redraw ) {\n				api.draw();\n			}\n		\n			return data;\n		};\n		\n		\n		/**\n		 * Restore the table to it's original state in the DOM by removing all of DataTables\n		 * enhancements, alterations to the DOM structure of the table and event listeners.\n		 *  @param {boolean} [remove=false] Completely remove the table from the DOM\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used\n		 *      var oTable = $('#example').dataTable();\n		 *      oTable.fnDestroy();\n		 *    } );\n		 */\n		this.fnDestroy = function ( remove )\n		{\n			this.api( true ).destroy( remove );\n		};\n		\n		\n		/**\n		 * Redraw the table\n		 *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *\n		 *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)\n		 *      oTable.fnDraw();\n		 *    } );\n		 */\n		this.fnDraw = function( complete )\n		{\n			// Note that this isn't an exact match to the old call to _fnDraw - it takes\n			// into account the new data, but can hold position.\n			this.api( true ).draw( complete );\n		};\n		\n		\n		/**\n		 * Filter the input based on data\n		 *  @param {string} sInput String to filter the table on\n		 *  @param {int|null} [iColumn] Column to limit filtering to\n		 *  @param {bool} [bRegex=false] Treat as regular expression or not\n		 *  @param {bool} [bSmart=true] Perform smart filtering or not\n		 *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)\n		 *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *\n		 *      // Sometime later - filter...\n		 *      oTable.fnFilter( 'test string' );\n		 *    } );\n		 */\n		this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )\n		{\n			var api = this.api( true );\n		\n			if ( iColumn === null || iColumn === undefined ) {\n				api.search( sInput, bRegex, bSmart, bCaseInsensitive );\n			}\n			else {\n				api.column( iColumn ).search( sInput, bRegex, bSmart, bCaseInsensitive );\n			}\n		\n			api.draw();\n		};\n		\n		\n		/**\n		 * Get the data for the whole table, an individual row or an individual cell based on the\n		 * provided parameters.\n		 *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as\n		 *    a TR node then the data source for the whole row will be returned. If given as a\n		 *    TD/TH cell node then iCol will be automatically calculated and the data for the\n		 *    cell returned. If given as an integer, then this is treated as the aoData internal\n		 *    data index for the row (see fnGetPosition) and the data for that row used.\n		 *  @param {int} [col] Optional column index that you want the data of.\n		 *  @returns {array|object|string} If mRow is undefined, then the data for all rows is\n		 *    returned. If mRow is defined, just data for that row, and is iCol is\n		 *    defined, only data for the designated cell is returned.\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    // Row data\n		 *    $(document).ready(function() {\n		 *      oTable = $('#example').dataTable();\n		 *\n		 *      oTable.$('tr').click( function () {\n		 *        var data = oTable.fnGetData( this );\n		 *        // ... do something with the array / object of data for the row\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Individual cell data\n		 *    $(document).ready(function() {\n		 *      oTable = $('#example').dataTable();\n		 *\n		 *      oTable.$('td').click( function () {\n		 *        var sData = oTable.fnGetData( this );\n		 *        alert( 'The cell clicked on had the value of '+sData );\n		 *      } );\n		 *    } );\n		 */\n		this.fnGetData = function( src, col )\n		{\n			var api = this.api( true );\n		\n			if ( src !== undefined ) {\n				var type = src.nodeName ? src.nodeName.toLowerCase() : '';\n		\n				return col !== undefined || type == 'td' || type == 'th' ?\n					api.cell( src, col ).data() :\n					api.row( src ).data() || null;\n			}\n		\n			return api.data().toArray();\n		};\n		\n		\n		/**\n		 * Get an array of the TR nodes that are used in the table's body. Note that you will\n		 * typically want to use the '$' API method in preference to this as it is more\n		 * flexible.\n		 *  @param {int} [iRow] Optional row index for the TR element you want\n		 *  @returns {array|node} If iRow is undefined, returns an array of all TR elements\n		 *    in the table's body, or iRow is defined, just the TR element requested.\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *\n		 *      // Get the nodes from the table\n		 *      var nNodes = oTable.fnGetNodes( );\n		 *    } );\n		 */\n		this.fnGetNodes = function( iRow )\n		{\n			var api = this.api( true );\n		\n			return iRow !== undefined ?\n				api.row( iRow ).node() :\n				api.rows().nodes().flatten().toArray();\n		};\n		\n		\n		/**\n		 * Get the array indexes of a particular cell from it's DOM element\n		 * and column index including hidden columns\n		 *  @param {node} node this can either be a TR, TD or TH in the table's body\n		 *  @returns {int} If nNode is given as a TR, then a single index is returned, or\n		 *    if given as a cell, an array of [row index, column index (visible),\n		 *    column index (all)] is given.\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      $('#example tbody td').click( function () {\n		 *        // Get the position of the current data from the node\n		 *        var aPos = oTable.fnGetPosition( this );\n		 *\n		 *        // Get the data array for this row\n		 *        var aData = oTable.fnGetData( aPos[0] );\n		 *\n		 *        // Update the data array and return the value\n		 *        aData[ aPos[1] ] = 'clicked';\n		 *        this.innerHTML = 'clicked';\n		 *      } );\n		 *\n		 *      // Init DataTables\n		 *      oTable = $('#example').dataTable();\n		 *    } );\n		 */\n		this.fnGetPosition = function( node )\n		{\n			var api = this.api( true );\n			var nodeName = node.nodeName.toUpperCase();\n		\n			if ( nodeName == 'TR' ) {\n				return api.row( node ).index();\n			}\n			else if ( nodeName == 'TD' || nodeName == 'TH' ) {\n				var cell = api.cell( node ).index();\n		\n				return [\n					cell.row,\n					cell.columnVisible,\n					cell.column\n				];\n			}\n			return null;\n		};\n		\n		\n		/**\n		 * Check to see if a row is 'open' or not.\n		 *  @param {node} nTr the table row to check\n		 *  @returns {boolean} true if the row is currently open, false otherwise\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable;\n		 *\n		 *      // 'open' an information row when a row is clicked on\n		 *      $('#example tbody tr').click( function () {\n		 *        if ( oTable.fnIsOpen(this) ) {\n		 *          oTable.fnClose( this );\n		 *        } else {\n		 *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n		 *        }\n		 *      } );\n		 *\n		 *      oTable = $('#example').dataTable();\n		 *    } );\n		 */\n		this.fnIsOpen = function( nTr )\n		{\n			return this.api( true ).row( nTr ).child.isShown();\n		};\n		\n		\n		/**\n		 * This function will place a new row directly after a row which is currently\n		 * on display on the page, with the HTML contents that is passed into the\n		 * function. This can be used, for example, to ask for confirmation that a\n		 * particular record should be deleted.\n		 *  @param {node} nTr The table row to 'open'\n		 *  @param {string|node|jQuery} mHtml The HTML to put into the row\n		 *  @param {string} sClass Class to give the new TD cell\n		 *  @returns {node} The row opened. Note that if the table row passed in as the\n		 *    first parameter, is not found in the table, this method will silently\n		 *    return.\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable;\n		 *\n		 *      // 'open' an information row when a row is clicked on\n		 *      $('#example tbody tr').click( function () {\n		 *        if ( oTable.fnIsOpen(this) ) {\n		 *          oTable.fnClose( this );\n		 *        } else {\n		 *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n		 *        }\n		 *      } );\n		 *\n		 *      oTable = $('#example').dataTable();\n		 *    } );\n		 */\n		this.fnOpen = function( nTr, mHtml, sClass )\n		{\n			return this.api( true )\n				.row( nTr )\n				.child( mHtml, sClass )\n				.show()\n				.child()[0];\n		};\n		\n		\n		/**\n		 * Change the pagination - provides the internal logic for pagination in a simple API\n		 * function. With this function you can have a DataTables table go to the next,\n		 * previous, first or last pages.\n		 *  @param {string|int} mAction Paging action to take: \"first\", \"previous\", \"next\" or \"last\"\n		 *    or page number to jump to (integer), note that page 0 is the first page.\n		 *  @param {bool} [bRedraw=true] Redraw the table or not\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *      oTable.fnPageChange( 'next' );\n		 *    } );\n		 */\n		this.fnPageChange = function ( mAction, bRedraw )\n		{\n			var api = this.api( true ).page( mAction );\n		\n			if ( bRedraw === undefined || bRedraw ) {\n				api.draw(false);\n			}\n		};\n		\n		\n		/**\n		 * Show a particular column\n		 *  @param {int} iCol The column whose display should be changed\n		 *  @param {bool} bShow Show (true) or hide (false) the column\n		 *  @param {bool} [bRedraw=true] Redraw the table or not\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *\n		 *      // Hide the second column after initialisation\n		 *      oTable.fnSetColumnVis( 1, false );\n		 *    } );\n		 */\n		this.fnSetColumnVis = function ( iCol, bShow, bRedraw )\n		{\n			var api = this.api( true ).column( iCol ).visible( bShow );\n		\n			if ( bRedraw === undefined || bRedraw ) {\n				api.columns.adjust().draw();\n			}\n		};\n		\n		\n		/**\n		 * Get the settings for a particular table for external manipulation\n		 *  @returns {object} DataTables settings object. See\n		 *    {@link DataTable.models.oSettings}\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *      var oSettings = oTable.fnSettings();\n		 *\n		 *      // Show an example parameter from the settings\n		 *      alert( oSettings._iDisplayStart );\n		 *    } );\n		 */\n		this.fnSettings = function()\n		{\n			return _fnSettingsFromNode( this[_ext.iApiIndex] );\n		};\n		\n		\n		/**\n		 * Sort the table by a particular column\n		 *  @param {int} iCol the data index to sort on. Note that this will not match the\n		 *    'display index' if you have hidden data entries\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *\n		 *      // Sort immediately with columns 0 and 1\n		 *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );\n		 *    } );\n		 */\n		this.fnSort = function( aaSort )\n		{\n			this.api( true ).order( aaSort ).draw();\n		};\n		\n		\n		/**\n		 * Attach a sort listener to an element for a given column\n		 *  @param {node} nNode the element to attach the sort listener to\n		 *  @param {int} iColumn the column that a click on this node will sort on\n		 *  @param {function} [fnCallback] callback function when sort is run\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *\n		 *      // Sort on column 1, when 'sorter' is clicked on\n		 *      oTable.fnSortListener( document.getElementById('sorter'), 1 );\n		 *    } );\n		 */\n		this.fnSortListener = function( nNode, iColumn, fnCallback )\n		{\n			this.api( true ).order.listener( nNode, iColumn, fnCallback );\n		};\n		\n		\n		/**\n		 * Update a table cell or row - this method will accept either a single value to\n		 * update the cell with, an array of values with one element for each column or\n		 * an object in the same format as the original data source. The function is\n		 * self-referencing in order to make the multi column updates easier.\n		 *  @param {object|array|string} mData Data to update the cell/row with\n		 *  @param {node|int} mRow TR element you want to update or the aoData index\n		 *  @param {int} [iColumn] The column to update, give as null or undefined to\n		 *    update a whole row.\n		 *  @param {bool} [bRedraw=true] Redraw the table or not\n		 *  @param {bool} [bAction=true] Perform pre-draw actions or not\n		 *  @returns {int} 0 on success, 1 on error\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell\n		 *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row\n		 *    } );\n		 */\n		this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )\n		{\n			var api = this.api( true );\n		\n			if ( iColumn === undefined || iColumn === null ) {\n				api.row( mRow ).data( mData );\n			}\n			else {\n				api.cell( mRow, iColumn ).data( mData );\n			}\n		\n			if ( bAction === undefined || bAction ) {\n				api.columns.adjust();\n			}\n		\n			if ( bRedraw === undefined || bRedraw ) {\n				api.draw();\n			}\n			return 0;\n		};\n		\n		\n		/**\n		 * Provide a common method for plug-ins to check the version of DataTables being used, in order\n		 * to ensure compatibility.\n		 *  @param {string} sVersion Version string to check for, in the format \"X.Y.Z\". Note that the\n		 *    formats \"X\" and \"X.Y\" are also acceptable.\n		 *  @returns {boolean} true if this version of DataTables is greater or equal to the required\n		 *    version, or false if this version of DataTales is not suitable\n		 *  @method\n		 *  @dtopt API\n		 *  @deprecated Since v1.10\n		 *\n		 *  @example\n		 *    $(document).ready(function() {\n		 *      var oTable = $('#example').dataTable();\n		 *      alert( oTable.fnVersionCheck( '1.9.0' ) );\n		 *    } );\n		 */\n		this.fnVersionCheck = _ext.fnVersionCheck;\n		\n\n		var _that = this;\n		var emptyInit = options === undefined;\n		var len = this.length;\n\n		if ( emptyInit ) {\n			options = {};\n		}\n\n		this.oApi = this.internal = _ext.internal;\n\n		// Extend with old style plug-in API methods\n		for ( var fn in DataTable.ext.internal ) {\n			if ( fn ) {\n				this[fn] = _fnExternApiFunc(fn);\n			}\n		}\n\n		this.each(function() {\n			// For each initialisation we want to give it a clean initialisation\n			// object that can be bashed around\n			var o = {};\n			var oInit = len > 1 ? // optimisation for single table case\n				_fnExtend( o, options, true ) :\n				options;\n\n			/*global oInit,_that,emptyInit*/\n			var i=0, iLen, j, jLen, k, kLen;\n			var sId = this.getAttribute( 'id' );\n			var bInitHandedOff = false;\n			var defaults = DataTable.defaults;\n			var $this = $(this);\n			\n			\n			/* Sanity check */\n			if ( this.nodeName.toLowerCase() != 'table' )\n			{\n				_fnLog( null, 0, 'Non-table node initialisation ('+this.nodeName+')', 2 );\n				return;\n			}\n			\n			/* Backwards compatibility for the defaults */\n			_fnCompatOpts( defaults );\n			_fnCompatCols( defaults.column );\n			\n			/* Convert the camel-case defaults to Hungarian */\n			_fnCamelToHungarian( defaults, defaults, true );\n			_fnCamelToHungarian( defaults.column, defaults.column, true );\n			\n			/* Setting up the initialisation object */\n			_fnCamelToHungarian( defaults, $.extend( oInit, $this.data() ) );\n			\n			\n			\n			/* Check to see if we are re-initialising a table */\n			var allSettings = DataTable.settings;\n			for ( i=0, iLen=allSettings.length ; i<iLen ; i++ )\n			{\n				var s = allSettings[i];\n			\n				/* Base check on table node */\n				if ( s.nTable == this || s.nTHead.parentNode == this || (s.nTFoot && s.nTFoot.parentNode == this) )\n				{\n					var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;\n					var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;\n			\n					if ( emptyInit || bRetrieve )\n					{\n						return s.oInstance;\n					}\n					else if ( bDestroy )\n					{\n						s.oInstance.fnDestroy();\n						break;\n					}\n					else\n					{\n						_fnLog( s, 0, 'Cannot reinitialise DataTable', 3 );\n						return;\n					}\n				}\n			\n				/* If the element we are initialising has the same ID as a table which was previously\n				 * initialised, but the table nodes don't match (from before) then we destroy the old\n				 * instance by simply deleting it. This is under the assumption that the table has been\n				 * destroyed by other methods. Anyone using non-id selectors will need to do this manually\n				 */\n				if ( s.sTableId == this.id )\n				{\n					allSettings.splice( i, 1 );\n					break;\n				}\n			}\n			\n			/* Ensure the table has an ID - required for accessibility */\n			if ( sId === null || sId === \"\" )\n			{\n				sId = \"DataTables_Table_\"+(DataTable.ext._unique++);\n				this.id = sId;\n			}\n			\n			/* Create the settings object for this table and set some of the default parameters */\n			var oSettings = $.extend( true, {}, DataTable.models.oSettings, {\n				\"sDestroyWidth\": $this[0].style.width,\n				\"sInstance\":     sId,\n				\"sTableId\":      sId\n			} );\n			oSettings.nTable = this;\n			oSettings.oApi   = _that.internal;\n			oSettings.oInit  = oInit;\n			\n			allSettings.push( oSettings );\n			\n			// Need to add the instance after the instance after the settings object has been added\n			// to the settings array, so we can self reference the table instance if more than one\n			oSettings.oInstance = (_that.length===1) ? _that : $this.dataTable();\n			\n			// Backwards compatibility, before we apply all the defaults\n			_fnCompatOpts( oInit );\n			\n			if ( oInit.oLanguage )\n			{\n				_fnLanguageCompat( oInit.oLanguage );\n			}\n			\n			// If the length menu is given, but the init display length is not, use the length menu\n			if ( oInit.aLengthMenu && ! oInit.iDisplayLength )\n			{\n				oInit.iDisplayLength = $.isArray( oInit.aLengthMenu[0] ) ?\n					oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];\n			}\n			\n			// Apply the defaults and init options to make a single init object will all\n			// options defined from defaults and instance options.\n			oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );\n			\n			\n			// Map the initialisation options onto the settings object\n			_fnMap( oSettings.oFeatures, oInit, [\n				\"bPaginate\",\n				\"bLengthChange\",\n				\"bFilter\",\n				\"bSort\",\n				\"bSortMulti\",\n				\"bInfo\",\n				\"bProcessing\",\n				\"bAutoWidth\",\n				\"bSortClasses\",\n				\"bServerSide\",\n				\"bDeferRender\"\n			] );\n			_fnMap( oSettings, oInit, [\n				\"asStripeClasses\",\n				\"ajax\",\n				\"fnServerData\",\n				\"fnFormatNumber\",\n				\"sServerMethod\",\n				\"aaSorting\",\n				\"aaSortingFixed\",\n				\"aLengthMenu\",\n				\"sPaginationType\",\n				\"sAjaxSource\",\n				\"sAjaxDataProp\",\n				\"iStateDuration\",\n				\"sDom\",\n				\"bSortCellsTop\",\n				\"iTabIndex\",\n				\"fnStateLoadCallback\",\n				\"fnStateSaveCallback\",\n				\"renderer\",\n				\"searchDelay\",\n				\"rowId\",\n				[ \"iCookieDuration\", \"iStateDuration\" ], // backwards compat\n				[ \"oSearch\", \"oPreviousSearch\" ],\n				[ \"aoSearchCols\", \"aoPreSearchCols\" ],\n				[ \"iDisplayLength\", \"_iDisplayLength\" ],\n				[ \"bJQueryUI\", \"bJUI\" ]\n			] );\n			_fnMap( oSettings.oScroll, oInit, [\n				[ \"sScrollX\", \"sX\" ],\n				[ \"sScrollXInner\", \"sXInner\" ],\n				[ \"sScrollY\", \"sY\" ],\n				[ \"bScrollCollapse\", \"bCollapse\" ]\n			] );\n			_fnMap( oSettings.oLanguage, oInit, \"fnInfoCallback\" );\n			\n			/* Callback functions which are array driven */\n			_fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback,      'user' );\n			_fnCallbackReg( oSettings, 'aoServerParams',       oInit.fnServerParams,      'user' );\n			_fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams,   'user' );\n			_fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams,   'user' );\n			_fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded,       'user' );\n			_fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback,       'user' );\n			_fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow,        'user' );\n			_fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback,    'user' );\n			_fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback,    'user' );\n			_fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete,      'user' );\n			_fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback,   'user' );\n			\n			oSettings.rowIdFn = _fnGetObjectDataFn( oInit.rowId );\n			\n			/* Browser support detection */\n			_fnBrowserDetect( oSettings );\n			\n			var oClasses = oSettings.oClasses;\n			\n			// @todo Remove in 1.11\n			if ( oInit.bJQueryUI )\n			{\n				/* Use the JUI classes object for display. You could clone the oStdClasses object if\n				 * you want to have multiple tables with multiple independent classes\n				 */\n				$.extend( oClasses, DataTable.ext.oJUIClasses, oInit.oClasses );\n			\n				if ( oInit.sDom === defaults.sDom && defaults.sDom === \"lfrtip\" )\n				{\n					/* Set the DOM to use a layout suitable for jQuery UI's theming */\n					oSettings.sDom = '<\"H\"lfr>t<\"F\"ip>';\n				}\n			\n				if ( ! oSettings.renderer ) {\n					oSettings.renderer = 'jqueryui';\n				}\n				else if ( $.isPlainObject( oSettings.renderer ) && ! oSettings.renderer.header ) {\n					oSettings.renderer.header = 'jqueryui';\n				}\n			}\n			else\n			{\n				$.extend( oClasses, DataTable.ext.classes, oInit.oClasses );\n			}\n			$this.addClass( oClasses.sTable );\n			\n			\n			if ( oSettings.iInitDisplayStart === undefined )\n			{\n				/* Display start point, taking into account the save saving */\n				oSettings.iInitDisplayStart = oInit.iDisplayStart;\n				oSettings._iDisplayStart = oInit.iDisplayStart;\n			}\n			\n			if ( oInit.iDeferLoading !== null )\n			{\n				oSettings.bDeferLoading = true;\n				var tmp = $.isArray( oInit.iDeferLoading );\n				oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;\n				oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;\n			}\n			\n			/* Language definitions */\n			var oLanguage = oSettings.oLanguage;\n			$.extend( true, oLanguage, oInit.oLanguage );\n			\n			if ( oLanguage.sUrl !== \"\" )\n			{\n				/* Get the language definitions from a file - because this Ajax call makes the language\n				 * get async to the remainder of this function we use bInitHandedOff to indicate that\n				 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor\n				 */\n				$.ajax( {\n					dataType: 'json',\n					url: oLanguage.sUrl,\n					success: function ( json ) {\n						_fnLanguageCompat( json );\n						_fnCamelToHungarian( defaults.oLanguage, json );\n						$.extend( true, oLanguage, json );\n						_fnInitialise( oSettings );\n					},\n					error: function () {\n						// Error occurred loading language file, continue on as best we can\n						_fnInitialise( oSettings );\n					}\n				} );\n				bInitHandedOff = true;\n			}\n			\n			/*\n			 * Stripes\n			 */\n			if ( oInit.asStripeClasses === null )\n			{\n				oSettings.asStripeClasses =[\n					oClasses.sStripeOdd,\n					oClasses.sStripeEven\n				];\n			}\n			\n			/* Remove row stripe classes if they are already on the table row */\n			var stripeClasses = oSettings.asStripeClasses;\n			var rowOne = $this.children('tbody').find('tr').eq(0);\n			if ( $.inArray( true, $.map( stripeClasses, function(el, i) {\n				return rowOne.hasClass(el);\n			} ) ) !== -1 ) {\n				$('tbody tr', this).removeClass( stripeClasses.join(' ') );\n				oSettings.asDestroyStripes = stripeClasses.slice();\n			}\n			\n			/*\n			 * Columns\n			 * See if we should load columns automatically or use defined ones\n			 */\n			var anThs = [];\n			var aoColumnsInit;\n			var nThead = this.getElementsByTagName('thead');\n			if ( nThead.length !== 0 )\n			{\n				_fnDetectHeader( oSettings.aoHeader, nThead[0] );\n				anThs = _fnGetUniqueThs( oSettings );\n			}\n			\n			/* If not given a column array, generate one with nulls */\n			if ( oInit.aoColumns === null )\n			{\n				aoColumnsInit = [];\n				for ( i=0, iLen=anThs.length ; i<iLen ; i++ )\n				{\n					aoColumnsInit.push( null );\n				}\n			}\n			else\n			{\n				aoColumnsInit = oInit.aoColumns;\n			}\n			\n			/* Add the columns */\n			for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )\n			{\n				_fnAddColumn( oSettings, anThs ? anThs[i] : null );\n			}\n			\n			/* Apply the column definitions */\n			_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {\n				_fnColumnOptions( oSettings, iCol, oDef );\n			} );\n			\n			/* HTML5 attribute detection - build an mData object automatically if the\n			 * attributes are found\n			 */\n			if ( rowOne.length ) {\n				var a = function ( cell, name ) {\n					return cell.getAttribute( 'data-'+name ) !== null ? name : null;\n				};\n			\n				$( rowOne[0] ).children('th, td').each( function (i, cell) {\n					var col = oSettings.aoColumns[i];\n			\n					if ( col.mData === i ) {\n						var sort = a( cell, 'sort' ) || a( cell, 'order' );\n						var filter = a( cell, 'filter' ) || a( cell, 'search' );\n			\n						if ( sort !== null || filter !== null ) {\n							col.mData = {\n								_:      i+'.display',\n								sort:   sort !== null   ? i+'.@data-'+sort   : undefined,\n								type:   sort !== null   ? i+'.@data-'+sort   : undefined,\n								filter: filter !== null ? i+'.@data-'+filter : undefined\n							};\n			\n							_fnColumnOptions( oSettings, i );\n						}\n					}\n				} );\n			}\n			\n			var features = oSettings.oFeatures;\n			\n			/* Must be done after everything which can be overridden by the state saving! */\n			if ( oInit.bStateSave )\n			{\n				features.bStateSave = true;\n				_fnLoadState( oSettings, oInit );\n				_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState, 'state_save' );\n			}\n			\n			\n			/*\n			 * Sorting\n			 * @todo For modularisation (1.11) this needs to do into a sort start up handler\n			 */\n			\n			// If aaSorting is not defined, then we use the first indicator in asSorting\n			// in case that has been altered, so the default sort reflects that option\n			if ( oInit.aaSorting === undefined )\n			{\n				var sorting = oSettings.aaSorting;\n				for ( i=0, iLen=sorting.length ; i<iLen ; i++ )\n				{\n					sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];\n				}\n			}\n			\n			/* Do a first pass on the sorting classes (allows any size changes to be taken into\n			 * account, and also will apply sorting disabled classes if disabled\n			 */\n			_fnSortingClasses( oSettings );\n			\n			if ( features.bSort )\n			{\n				_fnCallbackReg( oSettings, 'aoDrawCallback', function () {\n					if ( oSettings.bSorted ) {\n						var aSort = _fnSortFlatten( oSettings );\n						var sortedColumns = {};\n			\n						$.each( aSort, function (i, val) {\n							sortedColumns[ val.src ] = val.dir;\n						} );\n			\n						_fnCallbackFire( oSettings, null, 'order', [oSettings, aSort, sortedColumns] );\n						_fnSortAria( oSettings );\n					}\n				} );\n			}\n			\n			_fnCallbackReg( oSettings, 'aoDrawCallback', function () {\n				if ( oSettings.bSorted || _fnDataSource( oSettings ) === 'ssp' || features.bDeferRender ) {\n					_fnSortingClasses( oSettings );\n				}\n			}, 'sc' );\n			\n			\n			/*\n			 * Final init\n			 * Cache the header, body and footer as required, creating them if needed\n			 */\n			\n			// Work around for Webkit bug 83867 - store the caption-side before removing from doc\n			var captions = $this.children('caption').each( function () {\n				this._captionSide = $this.css('caption-side');\n			} );\n			\n			var thead = $this.children('thead');\n			if ( thead.length === 0 )\n			{\n				thead = $('<thead/>').appendTo(this);\n			}\n			oSettings.nTHead = thead[0];\n			\n			var tbody = $this.children('tbody');\n			if ( tbody.length === 0 )\n			{\n				tbody = $('<tbody/>').appendTo(this);\n			}\n			oSettings.nTBody = tbody[0];\n			\n			var tfoot = $this.children('tfoot');\n			if ( tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== \"\" || oSettings.oScroll.sY !== \"\") )\n			{\n				// If we are a scrolling table, and no footer has been given, then we need to create\n				// a tfoot element for the caption element to be appended to\n				tfoot = $('<tfoot/>').appendTo(this);\n			}\n			\n			if ( tfoot.length === 0 || tfoot.children().length === 0 ) {\n				$this.addClass( oClasses.sNoFooter );\n			}\n			else if ( tfoot.length > 0 ) {\n				oSettings.nTFoot = tfoot[0];\n				_fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );\n			}\n			\n			/* Check if there is data passing into the constructor */\n			if ( oInit.aaData )\n			{\n				for ( i=0 ; i<oInit.aaData.length ; i++ )\n				{\n					_fnAddData( oSettings, oInit.aaData[ i ] );\n				}\n			}\n			else if ( oSettings.bDeferLoading || _fnDataSource( oSettings ) == 'dom' )\n			{\n				/* Grab the data from the page - only do this when deferred loading or no Ajax\n				 * source since there is no point in reading the DOM data if we are then going\n				 * to replace it with Ajax data\n				 */\n				_fnAddTr( oSettings, $(oSettings.nTBody).children('tr') );\n			}\n			\n			/* Copy the data index array */\n			oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();\n			\n			/* Initialisation complete - table can be drawn */\n			oSettings.bInitialised = true;\n			\n			/* Check if we need to initialise the table (it might not have been handed off to the\n			 * language processor)\n			 */\n			if ( bInitHandedOff === false )\n			{\n				_fnInitialise( oSettings );\n			}\n		} );\n		_that = null;\n		return this;\n	};\n\n	\n	\n	/**\n	 * Computed structure of the DataTables API, defined by the options passed to\n	 * `DataTable.Api.register()` when building the API.\n	 *\n	 * The structure is built in order to speed creation and extension of the Api\n	 * objects since the extensions are effectively pre-parsed.\n	 *\n	 * The array is an array of objects with the following structure, where this\n	 * base array represents the Api prototype base:\n	 *\n	 *     [\n	 *       {\n	 *         name:      'data'                -- string   - Property name\n	 *         val:       function () {},       -- function - Api method (or undefined if just an object\n	 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\n	 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\n	 *       },\n	 *       {\n	 *         name:     'row'\n	 *         val:       {},\n	 *         methodExt: [ ... ],\n	 *         propExt:   [\n	 *           {\n	 *             name:      'data'\n	 *             val:       function () {},\n	 *             methodExt: [ ... ],\n	 *             propExt:   [ ... ]\n	 *           },\n	 *           ...\n	 *         ]\n	 *       }\n	 *     ]\n	 *\n	 * @type {Array}\n	 * @ignore\n	 */\n	var __apiStruct = [];\n	\n	\n	/**\n	 * `Array.prototype` reference.\n	 *\n	 * @type object\n	 * @ignore\n	 */\n	var __arrayProto = Array.prototype;\n	\n	\n	/**\n	 * Abstraction for `context` parameter of the `Api` constructor to allow it to\n	 * take several different forms for ease of use.\n	 *\n	 * Each of the input parameter types will be converted to a DataTables settings\n	 * object where possible.\n	 *\n	 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one\n	 *   of:\n	 *\n	 *   * `string` - jQuery selector. Any DataTables' matching the given selector\n	 *     with be found and used.\n	 *   * `node` - `TABLE` node which has already been formed into a DataTable.\n	 *   * `jQuery` - A jQuery object of `TABLE` nodes.\n	 *   * `object` - DataTables settings object\n	 *   * `DataTables.Api` - API instance\n	 * @return {array|null} Matching DataTables settings objects. `null` or\n	 *   `undefined` is returned if no matching DataTable is found.\n	 * @ignore\n	 */\n	var _toSettings = function ( mixed )\n	{\n		var idx, jq;\n		var settings = DataTable.settings;\n		var tables = $.map( settings, function (el, i) {\n			return el.nTable;\n		} );\n	\n		if ( ! mixed ) {\n			return [];\n		}\n		else if ( mixed.nTable && mixed.oApi ) {\n			// DataTables settings object\n			return [ mixed ];\n		}\n		else if ( mixed.nodeName && mixed.nodeName.toLowerCase() === 'table' ) {\n			// Table node\n			idx = $.inArray( mixed, tables );\n			return idx !== -1 ? [ settings[idx] ] : null;\n		}\n		else if ( mixed && typeof mixed.settings === 'function' ) {\n			return mixed.settings().toArray();\n		}\n		else if ( typeof mixed === 'string' ) {\n			// jQuery selector\n			jq = $(mixed);\n		}\n		else if ( mixed instanceof $ ) {\n			// jQuery object (also DataTables instance)\n			jq = mixed;\n		}\n	\n		if ( jq ) {\n			return jq.map( function(i) {\n				idx = $.inArray( this, tables );\n				return idx !== -1 ? settings[idx] : null;\n			} ).toArray();\n		}\n	};\n	\n	\n	/**\n	 * DataTables API class - used to control and interface with  one or more\n	 * DataTables enhanced tables.\n	 *\n	 * The API class is heavily based on jQuery, presenting a chainable interface\n	 * that you can use to interact with tables. Each instance of the API class has\n	 * a \"context\" - i.e. the tables that it will operate on. This could be a single\n	 * table, all tables on a page or a sub-set thereof.\n	 *\n	 * Additionally the API is designed to allow you to easily work with the data in\n	 * the tables, retrieving and manipulating it as required. This is done by\n	 * presenting the API class as an array like interface. The contents of the\n	 * array depend upon the actions requested by each method (for example\n	 * `rows().nodes()` will return an array of nodes, while `rows().data()` will\n	 * return an array of objects or arrays depending upon your table's\n	 * configuration). The API object has a number of array like methods (`push`,\n	 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,\n	 * `unique` etc) to assist your working with the data held in a table.\n	 *\n	 * Most methods (those which return an Api instance) are chainable, which means\n	 * the return from a method call also has all of the methods available that the\n	 * top level object had. For example, these two calls are equivalent:\n	 *\n	 *     // Not chained\n	 *     api.row.add( {...} );\n	 *     api.draw();\n	 *\n	 *     // Chained\n	 *     api.row.add( {...} ).draw();\n	 *\n	 * @class DataTable.Api\n	 * @param {array|object|string|jQuery} context DataTable identifier. This is\n	 *   used to define which DataTables enhanced tables this API will operate on.\n	 *   Can be one of:\n	 *\n	 *   * `string` - jQuery selector. Any DataTables' matching the given selector\n	 *     with be found and used.\n	 *   * `node` - `TABLE` node which has already been formed into a DataTable.\n	 *   * `jQuery` - A jQuery object of `TABLE` nodes.\n	 *   * `object` - DataTables settings object\n	 * @param {array} [data] Data to initialise the Api instance with.\n	 *\n	 * @example\n	 *   // Direct initialisation during DataTables construction\n	 *   var api = $('#example').DataTable();\n	 *\n	 * @example\n	 *   // Initialisation using a DataTables jQuery object\n	 *   var api = $('#example').dataTable().api();\n	 *\n	 * @example\n	 *   // Initialisation as a constructor\n	 *   var api = new $.fn.DataTable.Api( 'table.dataTable' );\n	 */\n	_Api = function ( context, data )\n	{\n		if ( ! (this instanceof _Api) ) {\n			return new _Api( context, data );\n		}\n	\n		var settings = [];\n		var ctxSettings = function ( o ) {\n			var a = _toSettings( o );\n			if ( a ) {\n				settings = settings.concat( a );\n			}\n		};\n	\n		if ( $.isArray( context ) ) {\n			for ( var i=0, ien=context.length ; i<ien ; i++ ) {\n				ctxSettings( context[i] );\n			}\n		}\n		else {\n			ctxSettings( context );\n		}\n	\n		// Remove duplicates\n		this.context = _unique( settings );\n	\n		// Initial data\n		if ( data ) {\n			$.merge( this, data );\n		}\n	\n		// selector\n		this.selector = {\n			rows: null,\n			cols: null,\n			opts: null\n		};\n	\n		_Api.extend( this, this, __apiStruct );\n	};\n	\n	DataTable.Api = _Api;\n	\n	// Don't destroy the existing prototype, just extend it. Required for jQuery 2's\n	// isPlainObject.\n	$.extend( _Api.prototype, {\n		any: function ()\n		{\n			return this.count() !== 0;\n		},\n	\n	\n		concat:  __arrayProto.concat,\n	\n	\n		context: [], // array of table settings objects\n	\n	\n		count: function ()\n		{\n			return this.flatten().length;\n		},\n	\n	\n		each: function ( fn )\n		{\n			for ( var i=0, ien=this.length ; i<ien; i++ ) {\n				fn.call( this, this[i], i, this );\n			}\n	\n			return this;\n		},\n	\n	\n		eq: function ( idx )\n		{\n			var ctx = this.context;\n	\n			return ctx.length > idx ?\n				new _Api( ctx[idx], this[idx] ) :\n				null;\n		},\n	\n	\n		filter: function ( fn )\n		{\n			var a = [];\n	\n			if ( __arrayProto.filter ) {\n				a = __arrayProto.filter.call( this, fn, this );\n			}\n			else {\n				// Compatibility for browsers without EMCA-252-5 (JS 1.6)\n				for ( var i=0, ien=this.length ; i<ien ; i++ ) {\n					if ( fn.call( this, this[i], i, this ) ) {\n						a.push( this[i] );\n					}\n				}\n			}\n	\n			return new _Api( this.context, a );\n		},\n	\n	\n		flatten: function ()\n		{\n			var a = [];\n			return new _Api( this.context, a.concat.apply( a, this.toArray() ) );\n		},\n	\n	\n		join:    __arrayProto.join,\n	\n	\n		indexOf: __arrayProto.indexOf || function (obj, start)\n		{\n			for ( var i=(start || 0), ien=this.length ; i<ien ; i++ ) {\n				if ( this[i] === obj ) {\n					return i;\n				}\n			}\n			return -1;\n		},\n	\n		iterator: function ( flatten, type, fn, alwaysNew ) {\n			var\n				a = [], ret,\n				i, ien, j, jen,\n				context = this.context,\n				rows, items, item,\n				selector = this.selector;\n	\n			// Argument shifting\n			if ( typeof flatten === 'string' ) {\n				alwaysNew = fn;\n				fn = type;\n				type = flatten;\n				flatten = false;\n			}\n	\n			for ( i=0, ien=context.length ; i<ien ; i++ ) {\n				var apiInst = new _Api( context[i] );\n	\n				if ( type === 'table' ) {\n					ret = fn.call( apiInst, context[i], i );\n	\n					if ( ret !== undefined ) {\n						a.push( ret );\n					}\n				}\n				else if ( type === 'columns' || type === 'rows' ) {\n					// this has same length as context - one entry for each table\n					ret = fn.call( apiInst, context[i], this[i], i );\n	\n					if ( ret !== undefined ) {\n						a.push( ret );\n					}\n				}\n				else if ( type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell' ) {\n					// columns and rows share the same structure.\n					// 'this' is an array of column indexes for each context\n					items = this[i];\n	\n					if ( type === 'column-rows' ) {\n						rows = _selector_row_indexes( context[i], selector.opts );\n					}\n	\n					for ( j=0, jen=items.length ; j<jen ; j++ ) {\n						item = items[j];\n	\n						if ( type === 'cell' ) {\n							ret = fn.call( apiInst, context[i], item.row, item.column, i, j );\n						}\n						else {\n							ret = fn.call( apiInst, context[i], item, i, j, rows );\n						}\n	\n						if ( ret !== undefined ) {\n							a.push( ret );\n						}\n					}\n				}\n			}\n	\n			if ( a.length || alwaysNew ) {\n				var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );\n				var apiSelector = api.selector;\n				apiSelector.rows = selector.rows;\n				apiSelector.cols = selector.cols;\n				apiSelector.opts = selector.opts;\n				return api;\n			}\n			return this;\n		},\n	\n	\n		lastIndexOf: __arrayProto.lastIndexOf || function (obj, start)\n		{\n			// Bit cheeky...\n			return this.indexOf.apply( this.toArray.reverse(), arguments );\n		},\n	\n	\n		length:  0,\n	\n	\n		map: function ( fn )\n		{\n			var a = [];\n	\n			if ( __arrayProto.map ) {\n				a = __arrayProto.map.call( this, fn, this );\n			}\n			else {\n				// Compatibility for browsers without EMCA-252-5 (JS 1.6)\n				for ( var i=0, ien=this.length ; i<ien ; i++ ) {\n					a.push( fn.call( this, this[i], i ) );\n				}\n			}\n	\n			return new _Api( this.context, a );\n		},\n	\n	\n		pluck: function ( prop )\n		{\n			return this.map( function ( el ) {\n				return el[ prop ];\n			} );\n		},\n	\n		pop:     __arrayProto.pop,\n	\n	\n		push:    __arrayProto.push,\n	\n	\n		// Does not return an API instance\n		reduce: __arrayProto.reduce || function ( fn, init )\n		{\n			return _fnReduce( this, fn, init, 0, this.length, 1 );\n		},\n	\n	\n		reduceRight: __arrayProto.reduceRight || function ( fn, init )\n		{\n			return _fnReduce( this, fn, init, this.length-1, -1, -1 );\n		},\n	\n	\n		reverse: __arrayProto.reverse,\n	\n	\n		// Object with rows, columns and opts\n		selector: null,\n	\n	\n		shift:   __arrayProto.shift,\n	\n	\n		sort:    __arrayProto.sort, // ? name - order?\n	\n	\n		splice:  __arrayProto.splice,\n	\n	\n		toArray: function ()\n		{\n			return __arrayProto.slice.call( this );\n		},\n	\n	\n		to$: function ()\n		{\n			return $( this );\n		},\n	\n	\n		toJQuery: function ()\n		{\n			return $( this );\n		},\n	\n	\n		unique: function ()\n		{\n			return new _Api( this.context, _unique(this) );\n		},\n	\n	\n		unshift: __arrayProto.unshift\n	} );\n	\n	\n	_Api.extend = function ( scope, obj, ext )\n	{\n		// Only extend API instances and static properties of the API\n		if ( ! ext.length || ! obj || ( ! (obj instanceof _Api) && ! obj.__dt_wrapper ) ) {\n			return;\n		}\n	\n		var\n			i, ien,\n			j, jen,\n			struct, inner,\n			methodScoping = function ( scope, fn, struc ) {\n				return function () {\n					var ret = fn.apply( scope, arguments );\n	\n					// Method extension\n					_Api.extend( ret, ret, struc.methodExt );\n					return ret;\n				};\n			};\n	\n		for ( i=0, ien=ext.length ; i<ien ; i++ ) {\n			struct = ext[i];\n	\n			// Value\n			obj[ struct.name ] = typeof struct.val === 'function' ?\n				methodScoping( scope, struct.val, struct ) :\n				$.isPlainObject( struct.val ) ?\n					{} :\n					struct.val;\n	\n			obj[ struct.name ].__dt_wrapper = true;\n	\n			// Property extension\n			_Api.extend( scope, obj[ struct.name ], struct.propExt );\n		}\n	};\n	\n	\n	// @todo - Is there need for an augment function?\n	// _Api.augment = function ( inst, name )\n	// {\n	// 	// Find src object in the structure from the name\n	// 	var parts = name.split('.');\n	\n	// 	_Api.extend( inst, obj );\n	// };\n	\n	\n	//     [\n	//       {\n	//         name:      'data'                -- string   - Property name\n	//         val:       function () {},       -- function - Api method (or undefined if just an object\n	//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\n	//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\n	//       },\n	//       {\n	//         name:     'row'\n	//         val:       {},\n	//         methodExt: [ ... ],\n	//         propExt:   [\n	//           {\n	//             name:      'data'\n	//             val:       function () {},\n	//             methodExt: [ ... ],\n	//             propExt:   [ ... ]\n	//           },\n	//           ...\n	//         ]\n	//       }\n	//     ]\n	\n	_Api.register = _api_register = function ( name, val )\n	{\n		if ( $.isArray( name ) ) {\n			for ( var j=0, jen=name.length ; j<jen ; j++ ) {\n				_Api.register( name[j], val );\n			}\n			return;\n		}\n	\n		var\n			i, ien,\n			heir = name.split('.'),\n			struct = __apiStruct,\n			key, method;\n	\n		var find = function ( src, name ) {\n			for ( var i=0, ien=src.length ; i<ien ; i++ ) {\n				if ( src[i].name === name ) {\n					return src[i];\n				}\n			}\n			return null;\n		};\n	\n		for ( i=0, ien=heir.length ; i<ien ; i++ ) {\n			method = heir[i].indexOf('()') !== -1;\n			key = method ?\n				heir[i].replace('()', '') :\n				heir[i];\n	\n			var src = find( struct, key );\n			if ( ! src ) {\n				src = {\n					name:      key,\n					val:       {},\n					methodExt: [],\n					propExt:   []\n				};\n				struct.push( src );\n			}\n	\n			if ( i === ien-1 ) {\n				src.val = val;\n			}\n			else {\n				struct = method ?\n					src.methodExt :\n					src.propExt;\n			}\n		}\n	};\n	\n	\n	_Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {\n		_Api.register( pluralName, val );\n	\n		_Api.register( singularName, function () {\n			var ret = val.apply( this, arguments );\n	\n			if ( ret === this ) {\n				// Returned item is the API instance that was passed in, return it\n				return this;\n			}\n			else if ( ret instanceof _Api ) {\n				// New API instance returned, want the value from the first item\n				// in the returned array for the singular result.\n				return ret.length ?\n					$.isArray( ret[0] ) ?\n						new _Api( ret.context, ret[0] ) : // Array results are 'enhanced'\n						ret[0] :\n					undefined;\n			}\n	\n			// Non-API return - just fire it back\n			return ret;\n		} );\n	};\n	\n	\n	/**\n	 * Selector for HTML tables. Apply the given selector to the give array of\n	 * DataTables settings objects.\n	 *\n	 * @param {string|integer} [selector] jQuery selector string or integer\n	 * @param  {array} Array of DataTables settings objects to be filtered\n	 * @return {array}\n	 * @ignore\n	 */\n	var __table_selector = function ( selector, a )\n	{\n		// Integer is used to pick out a table by index\n		if ( typeof selector === 'number' ) {\n			return [ a[ selector ] ];\n		}\n	\n		// Perform a jQuery selector on the table nodes\n		var nodes = $.map( a, function (el, i) {\n			return el.nTable;\n		} );\n	\n		return $(nodes)\n			.filter( selector )\n			.map( function (i) {\n				// Need to translate back from the table node to the settings\n				var idx = $.inArray( this, nodes );\n				return a[ idx ];\n			} )\n			.toArray();\n	};\n	\n	\n	\n	/**\n	 * Context selector for the API's context (i.e. the tables the API instance\n	 * refers to.\n	 *\n	 * @name    DataTable.Api#tables\n	 * @param {string|integer} [selector] Selector to pick which tables the iterator\n	 *   should operate on. If not given, all tables in the current context are\n	 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to\n	 *   select multiple tables or as an integer to select a single table.\n	 * @returns {DataTable.Api} Returns a new API instance if a selector is given.\n	 */\n	_api_register( 'tables()', function ( selector ) {\n		// A new instance is created if there was a selector specified\n		return selector ?\n			new _Api( __table_selector( selector, this.context ) ) :\n			this;\n	} );\n	\n	\n	_api_register( 'table()', function ( selector ) {\n		var tables = this.tables( selector );\n		var ctx = tables.context;\n	\n		// Truncate to the first matched table\n		return ctx.length ?\n			new _Api( ctx[0] ) :\n			tables;\n	} );\n	\n	\n	_api_registerPlural( 'tables().nodes()', 'table().node()' , function () {\n		return this.iterator( 'table', function ( ctx ) {\n			return ctx.nTable;\n		}, 1 );\n	} );\n	\n	\n	_api_registerPlural( 'tables().body()', 'table().body()' , function () {\n		return this.iterator( 'table', function ( ctx ) {\n			return ctx.nTBody;\n		}, 1 );\n	} );\n	\n	\n	_api_registerPlural( 'tables().header()', 'table().header()' , function () {\n		return this.iterator( 'table', function ( ctx ) {\n			return ctx.nTHead;\n		}, 1 );\n	} );\n	\n	\n	_api_registerPlural( 'tables().footer()', 'table().footer()' , function () {\n		return this.iterator( 'table', function ( ctx ) {\n			return ctx.nTFoot;\n		}, 1 );\n	} );\n	\n	\n	_api_registerPlural( 'tables().containers()', 'table().container()' , function () {\n		return this.iterator( 'table', function ( ctx ) {\n			return ctx.nTableWrapper;\n		}, 1 );\n	} );\n	\n	\n	\n	/**\n	 * Redraw the tables in the current context.\n	 */\n	_api_register( 'draw()', function ( paging ) {\n		return this.iterator( 'table', function ( settings ) {\n			if ( paging === 'page' ) {\n				_fnDraw( settings );\n			}\n			else {\n				if ( typeof paging === 'string' ) {\n					paging = paging === 'full-hold' ?\n						false :\n						true;\n				}\n	\n				_fnReDraw( settings, paging===false );\n			}\n		} );\n	} );\n	\n	\n	\n	/**\n	 * Get the current page index.\n	 *\n	 * @return {integer} Current page index (zero based)\n	 *//**\n	 * Set the current page.\n	 *\n	 * Note that if you attempt to show a page which does not exist, DataTables will\n	 * not throw an error, but rather reset the paging.\n	 *\n	 * @param {integer|string} action The paging action to take. This can be one of:\n	 *  * `integer` - The page index to jump to\n	 *  * `string` - An action to take:\n	 *    * `first` - Jump to first page.\n	 *    * `next` - Jump to the next page\n	 *    * `previous` - Jump to previous page\n	 *    * `last` - Jump to the last page.\n	 * @returns {DataTables.Api} this\n	 */\n	_api_register( 'page()', function ( action ) {\n		if ( action === undefined ) {\n			return this.page.info().page; // not an expensive call\n		}\n	\n		// else, have an action to take on all tables\n		return this.iterator( 'table', function ( settings ) {\n			_fnPageChange( settings, action );\n		} );\n	} );\n	\n	\n	/**\n	 * Paging information for the first table in the current context.\n	 *\n	 * If you require paging information for another table, use the `table()` method\n	 * with a suitable selector.\n	 *\n	 * @return {object} Object with the following properties set:\n	 *  * `page` - Current page index (zero based - i.e. the first page is `0`)\n	 *  * `pages` - Total number of pages\n	 *  * `start` - Display index for the first record shown on the current page\n	 *  * `end` - Display index for the last record shown on the current page\n	 *  * `length` - Display length (number of records). Note that generally `start\n	 *    + length = end`, but this is not always true, for example if there are\n	 *    only 2 records to show on the final page, with a length of 10.\n	 *  * `recordsTotal` - Full data set length\n	 *  * `recordsDisplay` - Data set length once the current filtering criterion\n	 *    are applied.\n	 */\n	_api_register( 'page.info()', function ( action ) {\n		if ( this.context.length === 0 ) {\n			return undefined;\n		}\n	\n		var\n			settings   = this.context[0],\n			start      = settings._iDisplayStart,\n			len        = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,\n			visRecords = settings.fnRecordsDisplay(),\n			all        = len === -1;\n	\n		return {\n			\"page\":           all ? 0 : Math.floor( start / len ),\n			\"pages\":          all ? 1 : Math.ceil( visRecords / len ),\n			\"start\":          start,\n			\"end\":            settings.fnDisplayEnd(),\n			\"length\":         len,\n			\"recordsTotal\":   settings.fnRecordsTotal(),\n			\"recordsDisplay\": visRecords,\n			\"serverSide\":     _fnDataSource( settings ) === 'ssp'\n		};\n	} );\n	\n	\n	/**\n	 * Get the current page length.\n	 *\n	 * @return {integer} Current page length. Note `-1` indicates that all records\n	 *   are to be shown.\n	 *//**\n	 * Set the current page length.\n	 *\n	 * @param {integer} Page length to set. Use `-1` to show all records.\n	 * @returns {DataTables.Api} this\n	 */\n	_api_register( 'page.len()', function ( len ) {\n		// Note that we can't call this function 'length()' because `length`\n		// is a Javascript property of functions which defines how many arguments\n		// the function expects.\n		if ( len === undefined ) {\n			return this.context.length !== 0 ?\n				this.context[0]._iDisplayLength :\n				undefined;\n		}\n	\n		// else, set the page length\n		return this.iterator( 'table', function ( settings ) {\n			_fnLengthChange( settings, len );\n		} );\n	} );\n	\n	\n	\n	var __reload = function ( settings, holdPosition, callback ) {\n		// Use the draw event to trigger a callback\n		if ( callback ) {\n			var api = new _Api( settings );\n	\n			api.one( 'draw', function () {\n				callback( api.ajax.json() );\n			} );\n		}\n	\n		if ( _fnDataSource( settings ) == 'ssp' ) {\n			_fnReDraw( settings, holdPosition );\n		}\n		else {\n			_fnProcessingDisplay( settings, true );\n	\n			// Cancel an existing request\n			var xhr = settings.jqXHR;\n			if ( xhr && xhr.readyState !== 4 ) {\n				xhr.abort();\n			}\n	\n			// Trigger xhr\n			_fnBuildAjax( settings, [], function( json ) {\n				_fnClearTable( settings );\n	\n				var data = _fnAjaxDataSrc( settings, json );\n				for ( var i=0, ien=data.length ; i<ien ; i++ ) {\n					_fnAddData( settings, data[i] );\n				}\n	\n				_fnReDraw( settings, holdPosition );\n				_fnProcessingDisplay( settings, false );\n			} );\n		}\n	};\n	\n	\n	/**\n	 * Get the JSON response from the last Ajax request that DataTables made to the\n	 * server. Note that this returns the JSON from the first table in the current\n	 * context.\n	 *\n	 * @return {object} JSON received from the server.\n	 */\n	_api_register( 'ajax.json()', function () {\n		var ctx = this.context;\n	\n		if ( ctx.length > 0 ) {\n			return ctx[0].json;\n		}\n	\n		// else return undefined;\n	} );\n	\n	\n	/**\n	 * Get the data submitted in the last Ajax request\n	 */\n	_api_register( 'ajax.params()', function () {\n		var ctx = this.context;\n	\n		if ( ctx.length > 0 ) {\n			return ctx[0].oAjaxData;\n		}\n	\n		// else return undefined;\n	} );\n	\n	\n	/**\n	 * Reload tables from the Ajax data source. Note that this function will\n	 * automatically re-draw the table when the remote data has been loaded.\n	 *\n	 * @param {boolean} [reset=true] Reset (default) or hold the current paging\n	 *   position. A full re-sort and re-filter is performed when this method is\n	 *   called, which is why the pagination reset is the default action.\n	 * @returns {DataTables.Api} this\n	 */\n	_api_register( 'ajax.reload()', function ( callback, resetPaging ) {\n		return this.iterator( 'table', function (settings) {\n			__reload( settings, resetPaging===false, callback );\n		} );\n	} );\n	\n	\n	/**\n	 * Get the current Ajax URL. Note that this returns the URL from the first\n	 * table in the current context.\n	 *\n	 * @return {string} Current Ajax source URL\n	 *//**\n	 * Set the Ajax URL. Note that this will set the URL for all tables in the\n	 * current context.\n	 *\n	 * @param {string} url URL to set.\n	 * @returns {DataTables.Api} this\n	 */\n	_api_register( 'ajax.url()', function ( url ) {\n		var ctx = this.context;\n	\n		if ( url === undefined ) {\n			// get\n			if ( ctx.length === 0 ) {\n				return undefined;\n			}\n			ctx = ctx[0];\n	\n			return ctx.ajax ?\n				$.isPlainObject( ctx.ajax ) ?\n					ctx.ajax.url :\n					ctx.ajax :\n				ctx.sAjaxSource;\n		}\n	\n		// set\n		return this.iterator( 'table', function ( settings ) {\n			if ( $.isPlainObject( settings.ajax ) ) {\n				settings.ajax.url = url;\n			}\n			else {\n				settings.ajax = url;\n			}\n			// No need to consider sAjaxSource here since DataTables gives priority\n			// to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any\n			// value of `sAjaxSource` redundant.\n		} );\n	} );\n	\n	\n	/**\n	 * Load data from the newly set Ajax URL. Note that this method is only\n	 * available when `ajax.url()` is used to set a URL. Additionally, this method\n	 * has the same effect as calling `ajax.reload()` but is provided for\n	 * convenience when setting a new URL. Like `ajax.reload()` it will\n	 * automatically redraw the table once the remote data has been loaded.\n	 *\n	 * @returns {DataTables.Api} this\n	 */\n	_api_register( 'ajax.url().load()', function ( callback, resetPaging ) {\n		// Same as a reload, but makes sense to present it for easy access after a\n		// url change\n		return this.iterator( 'table', function ( ctx ) {\n			__reload( ctx, resetPaging===false, callback );\n		} );\n	} );\n	\n	\n	\n	\n	var _selector_run = function ( type, selector, selectFn, settings, opts )\n	{\n		var\n			out = [], res,\n			a, i, ien, j, jen,\n			selectorType = typeof selector;\n	\n		// Can't just check for isArray here, as an API or jQuery instance might be\n		// given with their array like look\n		if ( ! selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined ) {\n			selector = [ selector ];\n		}\n	\n		for ( i=0, ien=selector.length ; i<ien ; i++ ) {\n			a = selector[i] && selector[i].split ?\n				selector[i].split(',') :\n				[ selector[i] ];\n	\n			for ( j=0, jen=a.length ; j<jen ; j++ ) {\n				res = selectFn( typeof a[j] === 'string' ? $.trim(a[j]) : a[j] );\n	\n				if ( res && res.length ) {\n					out = out.concat( res );\n				}\n			}\n		}\n	\n		// selector extensions\n		var ext = _ext.selector[ type ];\n		if ( ext.length ) {\n			for ( i=0, ien=ext.length ; i<ien ; i++ ) {\n				out = ext[i]( settings, opts, out );\n			}\n		}\n	\n		return _unique( out );\n	};\n	\n	\n	var _selector_opts = function ( opts )\n	{\n		if ( ! opts ) {\n			opts = {};\n		}\n	\n		// Backwards compatibility for 1.9- which used the terminology filter rather\n		// than search\n		if ( opts.filter && opts.search === undefined ) {\n			opts.search = opts.filter;\n		}\n	\n		return $.extend( {\n			search: 'none',\n			order: 'current',\n			page: 'all'\n		}, opts );\n	};\n	\n	\n	var _selector_first = function ( inst )\n	{\n		// Reduce the API instance to the first item found\n		for ( var i=0, ien=inst.length ; i<ien ; i++ ) {\n			if ( inst[i].length > 0 ) {\n				// Assign the first element to the first item in the instance\n				// and truncate the instance and context\n				inst[0] = inst[i];\n				inst[0].length = 1;\n				inst.length = 1;\n				inst.context = [ inst.context[i] ];\n	\n				return inst;\n			}\n		}\n	\n		// Not found - return an empty instance\n		inst.length = 0;\n		return inst;\n	};\n	\n	\n	var _selector_row_indexes = function ( settings, opts )\n	{\n		var\n			i, ien, tmp, a=[],\n			displayFiltered = settings.aiDisplay,\n			displayMaster = settings.aiDisplayMaster;\n	\n		var\n			search = opts.search,  // none, applied, removed\n			order  = opts.order,   // applied, current, index (original - compatibility with 1.9)\n			page   = opts.page;    // all, current\n	\n		if ( _fnDataSource( settings ) == 'ssp' ) {\n			// In server-side processing mode, most options are irrelevant since\n			// rows not shown don't exist and the index order is the applied order\n			// Removed is a special case - for consistency just return an empty\n			// array\n			return search === 'removed' ?\n				[] :\n				_range( 0, displayMaster.length );\n		}\n		else if ( page == 'current' ) {\n			// Current page implies that order=current and fitler=applied, since it is\n			// fairly senseless otherwise, regardless of what order and search actually\n			// are\n			for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i<ien ; i++ ) {\n				a.push( displayFiltered[i] );\n			}\n		}\n		else if ( order == 'current' || order == 'applied' ) {\n			a = search == 'none' ?\n				displayMaster.slice() :                      // no search\n				search == 'applied' ?\n					displayFiltered.slice() :                // applied search\n					$.map( displayMaster, function (el, i) { // removed search\n						return $.inArray( el, displayFiltered ) === -1 ? el : null;\n					} );\n		}\n		else if ( order == 'index' || order == 'original' ) {\n			for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {\n				if ( search == 'none' ) {\n					a.push( i );\n				}\n				else { // applied | removed\n					tmp = $.inArray( i, displayFiltered );\n	\n					if ((tmp === -1 && search == 'removed') ||\n						(tmp >= 0   && search == 'applied') )\n					{\n						a.push( i );\n					}\n				}\n			}\n		}\n	\n		return a;\n	};\n	\n	\n	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n	 * Rows\n	 *\n	 * {}          - no selector - use all available rows\n	 * {integer}   - row aoData index\n	 * {node}      - TR node\n	 * {string}    - jQuery selector to apply to the TR elements\n	 * {array}     - jQuery array of nodes, or simply an array of TR nodes\n	 *\n	 */\n	\n	\n	var __row_selector = function ( settings, selector, opts )\n	{\n		var run = function ( sel ) {\n			var selInt = _intVal( sel );\n			var i, ien;\n	\n			// Short cut - selector is a number and no options provided (default is\n			// all records, so no need to check if the index is in there, since it\n			// must be - dev error if the index doesn't exist).\n			if ( selInt !== null && ! opts ) {\n				return [ selInt ];\n			}\n	\n			var rows = _selector_row_indexes( settings, opts );\n	\n			if ( selInt !== null && $.inArray( selInt, rows ) !== -1 ) {\n				// Selector - integer\n				return [ selInt ];\n			}\n			else if ( ! sel ) {\n				// Selector - none\n				return rows;\n			}\n	\n			// Selector - function\n			if ( typeof sel === 'function' ) {\n				return $.map( rows, function (idx) {\n					var row = settings.aoData[ idx ];\n					return sel( idx, row._aData, row.nTr ) ? idx : null;\n				} );\n			}\n	\n			// Get nodes in the order from the `rows` array with null values removed\n			var nodes = _removeEmpty(\n				_pluck_order( settings.aoData, rows, 'nTr' )\n			);\n	\n			// Selector - node\n			if ( sel.nodeName ) {\n				if ( $.inArray( sel, nodes ) !== -1 ) {\n					return [ sel._DT_RowIndex ]; // sel is a TR node that is in the table\n					                             // and DataTables adds a prop for fast lookup\n				}\n			}\n	\n			// ID selector. Want to always be able to select rows by id, regardless\n			// of if the tr element has been created or not, so can't rely upon\n			// jQuery here - hence a custom implementation. This does not match\n			// Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,\n			// but to select it using a CSS selector engine (like Sizzle or\n			// querySelect) it would need to need to be escaped for some characters.\n			// DataTables simplifies this for row selectors since you can select\n			// only a row. A # indicates an id any anything that follows is the id -\n			// unescaped.\n			if ( typeof sel === 'string' && sel.charAt(0) === '#' ) {\n				// get row index from id\n				var rowObj = settings.aIds[ sel.replace( /^#/, '' ) ];\n				if ( rowObj !== undefined ) {\n					return [ rowObj.idx ];\n				}\n	\n				// need to fall through to jQuery in case there is DOM id that\n				// matches\n			}\n	\n			// Selector - jQuery selector string, array of nodes or jQuery object/\n			// As jQuery's .filter() allows jQuery objects to be passed in filter,\n			// it also allows arrays, so this will cope with all three options\n			return $(nodes)\n				.filter( sel )\n				.map( function () {\n					return this._DT_RowIndex;\n				} )\n				.toArray();\n		};\n	\n		return _selector_run( 'row', selector, run, settings, opts );\n	};\n	\n	\n	_api_register( 'rows()', function ( selector, opts ) {\n		// argument shifting\n		if ( selector === undefined ) {\n			selector = '';\n		}\n		else if ( $.isPlainObject( selector ) ) {\n			opts = selector;\n			selector = '';\n		}\n	\n		opts = _selector_opts( opts );\n	\n		var inst = this.iterator( 'table', function ( settings ) {\n			return __row_selector( settings, selector, opts );\n		}, 1 );\n	\n		// Want argument shifting here and in __row_selector?\n		inst.selector.rows = selector;\n		inst.selector.opts = opts;\n	\n		return inst;\n	} );\n	\n	_api_register( 'rows().nodes()', function () {\n		return this.iterator( 'row', function ( settings, row ) {\n			return settings.aoData[ row ].nTr || undefined;\n		}, 1 );\n	} );\n	\n	_api_register( 'rows().data()', function () {\n		return this.iterator( true, 'rows', function ( settings, rows ) {\n			return _pluck_order( settings.aoData, rows, '_aData' );\n		}, 1 );\n	} );\n	\n	_api_registerPlural( 'rows().cache()', 'row().cache()', function ( type ) {\n		return this.iterator( 'row', function ( settings, row ) {\n			var r = settings.aoData[ row ];\n			return type === 'search' ? r._aFilterData : r._aSortData;\n		}, 1 );\n	} );\n	\n	_api_registerPlural( 'rows().invalidate()', 'row().invalidate()', function ( src ) {\n		return this.iterator( 'row', function ( settings, row ) {\n			_fnInvalidate( settings, row, src );\n		} );\n	} );\n	\n	_api_registerPlural( 'rows().indexes()', 'row().index()', function () {\n		return this.iterator( 'row', function ( settings, row ) {\n			return row;\n		}, 1 );\n	} );\n	\n	_api_registerPlural( 'rows().ids()', 'row().id()', function ( hash ) {\n		var a = [];\n		var context = this.context;\n	\n		// `iterator` will drop undefined values, but in this case we want them\n		for ( var i=0, ien=context.length ; i<ien ; i++ ) {\n			for ( var j=0, jen=this[i].length ; j<jen ; j++ ) {\n				var id = context[i].rowIdFn( context[i].aoData[ this[i][j] ]._aData );\n				a.push( (hash === true ? '#' : '' )+ id );\n			}\n		}\n	\n		return new _Api( context, a );\n	} );\n	\n	_api_registerPlural( 'rows().remove()', 'row().remove()', function () {\n		var that = this;\n	\n		this.iterator( 'row', function ( settings, row, thatIdx ) {\n			var data = settings.aoData;\n			var rowData = data[ row ];\n			var i, ien, j, jen;\n			var loopRow, loopCells;\n	\n			data.splice( row, 1 );\n	\n			// Update the cached indexes\n			for ( i=0, ien=data.length ; i<ien ; i++ ) {\n				loopRow = data[i];\n				loopCells = loopRow.anCells;\n	\n				// Rows\n				if ( loopRow.nTr !== null ) {\n					loopRow.nTr._DT_RowIndex = i;\n				}\n	\n				// Cells\n				if ( loopCells !== null ) {\n					for ( j=0, jen=loopCells.length ; j<jen ; j++ ) {\n						loopCells[j]._DT_CellIndex.row = i;\n					}\n				}\n			}\n	\n			// Delete from the display arrays\n			_fnDeleteIndex( settings.aiDisplayMaster, row );\n			_fnDeleteIndex( settings.aiDisplay, row );\n			_fnDeleteIndex( that[ thatIdx ], row, false ); // maintain local indexes\n	\n			// Check for an 'overflow' they case for displaying the table\n			_fnLengthOverflow( settings );\n	\n			// Remove the row's ID reference if there is one\n			var id = settings.rowIdFn( rowData._aData );\n			if ( id !== undefined ) {\n				delete settings.aIds[ id ];\n			}\n		} );\n	\n		this.iterator( 'table', function ( settings ) {\n			for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {\n				settings.aoData[i].idx = i;\n			}\n		} );\n	\n		return this;\n	} );\n	\n	\n	_api_register( 'rows.add()', function ( rows ) {\n		var newRows = this.iterator( 'table', function ( settings ) {\n				var row, i, ien;\n				var out = [];\n	\n				for ( i=0, ien=rows.length ; i<ien ; i++ ) {\n					row = rows[i];\n	\n					if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {\n						out.push( _fnAddTr( settings, row )[0] );\n					}\n					else {\n						out.push( _fnAddData( settings, row ) );\n					}\n				}\n	\n				return out;\n			}, 1 );\n	\n		// Return an Api.rows() extended instance, so rows().nodes() etc can be used\n		var modRows = this.rows( -1 );\n		modRows.pop();\n		$.merge( modRows, newRows );\n	\n		return modRows;\n	} );\n	\n	\n	\n	\n	\n	/**\n	 *\n	 */\n	_api_register( 'row()', function ( selector, opts ) {\n		return _selector_first( this.rows( selector, opts ) );\n	} );\n	\n	\n	_api_register( 'row().data()', function ( data ) {\n		var ctx = this.context;\n	\n		if ( data === undefined ) {\n			// Get\n			return ctx.length && this.length ?\n				ctx[0].aoData[ this[0] ]._aData :\n				undefined;\n		}\n	\n		// Set\n		ctx[0].aoData[ this[0] ]._aData = data;\n	\n		// Automatically invalidate\n		_fnInvalidate( ctx[0], this[0], 'data' );\n	\n		return this;\n	} );\n	\n	\n	_api_register( 'row().node()', function () {\n		var ctx = this.context;\n	\n		return ctx.length && this.length ?\n			ctx[0].aoData[ this[0] ].nTr || null :\n			null;\n	} );\n	\n	\n	_api_register( 'row.add()', function ( row ) {\n		// Allow a jQuery object to be passed in - only a single row is added from\n		// it though - the first element in the set\n		if ( row instanceof $ && row.length ) {\n			row = row[0];\n		}\n	\n		var rows = this.iterator( 'table', function ( settings ) {\n			if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {\n				return _fnAddTr( settings, row )[0];\n			}\n			return _fnAddData( settings, row );\n		} );\n	\n		// Return an Api.rows() extended instance, with the newly added row selected\n		return this.row( rows[0] );\n	} );\n	\n	\n	\n	var __details_add = function ( ctx, row, data, klass )\n	{\n		// Convert to array of TR elements\n		var rows = [];\n		var addRow = function ( r, k ) {\n			// Recursion to allow for arrays of jQuery objects\n			if ( $.isArray( r ) || r instanceof $ ) {\n				for ( var i=0, ien=r.length ; i<ien ; i++ ) {\n					addRow( r[i], k );\n				}\n				return;\n			}\n	\n			// If we get a TR element, then just add it directly - up to the dev\n			// to add the correct number of columns etc\n			if ( r.nodeName && r.nodeName.toLowerCase() === 'tr' ) {\n				rows.push( r );\n			}\n			else {\n				// Otherwise create a row with a wrapper\n				var created = $('<tr><td/></tr>').addClass( k );\n				$('td', created)\n					.addClass( k )\n					.html( r )\n					[0].colSpan = _fnVisbleColumns( ctx );\n	\n				rows.push( created[0] );\n			}\n		};\n	\n		addRow( data, klass );\n	\n		if ( row._details ) {\n			row._details.remove();\n		}\n	\n		row._details = $(rows);\n	\n		// If the children were already shown, that state should be retained\n		if ( row._detailsShow ) {\n			row._details.insertAfter( row.nTr );\n		}\n	};\n	\n	\n	var __details_remove = function ( api, idx )\n	{\n		var ctx = api.context;\n	\n		if ( ctx.length ) {\n			var row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];\n	\n			if ( row && row._details ) {\n				row._details.remove();\n	\n				row._detailsShow = undefined;\n				row._details = undefined;\n			}\n		}\n	};\n	\n	\n	var __details_display = function ( api, show ) {\n		var ctx = api.context;\n	\n		if ( ctx.length && api.length ) {\n			var row = ctx[0].aoData[ api[0] ];\n	\n			if ( row._details ) {\n				row._detailsShow = show;\n	\n				if ( show ) {\n					row._details.insertAfter( row.nTr );\n				}\n				else {\n					row._details.detach();\n				}\n	\n				__details_events( ctx[0] );\n			}\n		}\n	};\n	\n	\n	var __details_events = function ( settings )\n	{\n		var api = new _Api( settings );\n		var namespace = '.dt.DT_details';\n		var drawEvent = 'draw'+namespace;\n		var colvisEvent = 'column-visibility'+namespace;\n		var destroyEvent = 'destroy'+namespace;\n		var data = settings.aoData;\n	\n		api.off( drawEvent +' '+ colvisEvent +' '+ destroyEvent );\n	\n		if ( _pluck( data, '_details' ).length > 0 ) {\n			// On each draw, insert the required elements into the document\n			api.on( drawEvent, function ( e, ctx ) {\n				if ( settings !== ctx ) {\n					return;\n				}\n	\n				api.rows( {page:'current'} ).eq(0).each( function (idx) {\n					// Internal data grab\n					var row = data[ idx ];\n	\n					if ( row._detailsShow ) {\n						row._details.insertAfter( row.nTr );\n					}\n				} );\n			} );\n	\n			// Column visibility change - update the colspan\n			api.on( colvisEvent, function ( e, ctx, idx, vis ) {\n				if ( settings !== ctx ) {\n					return;\n				}\n	\n				// Update the colspan for the details rows (note, only if it already has\n				// a colspan)\n				var row, visible = _fnVisbleColumns( ctx );\n	\n				for ( var i=0, ien=data.length ; i<ien ; i++ ) {\n					row = data[i];\n	\n					if ( row._details ) {\n						row._details.children('td[colspan]').attr('colspan', visible );\n					}\n				}\n			} );\n	\n			// Table destroyed - nuke any child rows\n			api.on( destroyEvent, function ( e, ctx ) {\n				if ( settings !== ctx ) {\n					return;\n				}\n	\n				for ( var i=0, ien=data.length ; i<ien ; i++ ) {\n					if ( data[i]._details ) {\n						__details_remove( api, i );\n					}\n				}\n			} );\n		}\n	};\n	\n	// Strings for the method names to help minification\n	var _emp = '';\n	var _child_obj = _emp+'row().child';\n	var _child_mth = _child_obj+'()';\n	\n	// data can be:\n	//  tr\n	//  string\n	//  jQuery or array of any of the above\n	_api_register( _child_mth, function ( data, klass ) {\n		var ctx = this.context;\n	\n		if ( data === undefined ) {\n			// get\n			return ctx.length && this.length ?\n				ctx[0].aoData[ this[0] ]._details :\n				undefined;\n		}\n		else if ( data === true ) {\n			// show\n			this.child.show();\n		}\n		else if ( data === false ) {\n			// remove\n			__details_remove( this );\n		}\n		else if ( ctx.length && this.length ) {\n			// set\n			__details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );\n		}\n	\n		return this;\n	} );\n	\n	\n	_api_register( [\n		_child_obj+'.show()',\n		_child_mth+'.show()' // only when `child()` was called with parameters (without\n	], function ( show ) {   // it returns an object and this method is not executed)\n		__details_display( this, true );\n		return this;\n	} );\n	\n	\n	_api_register( [\n		_child_obj+'.hide()',\n		_child_mth+'.hide()' // only when `child()` was called with parameters (without\n	], function () {         // it returns an object and this method is not executed)\n		__details_display( this, false );\n		return this;\n	} );\n	\n	\n	_api_register( [\n		_child_obj+'.remove()',\n		_child_mth+'.remove()' // only when `child()` was called with parameters (without\n	], function () {           // it returns an object and this method is not executed)\n		__details_remove( this );\n		return this;\n	} );\n	\n	\n	_api_register( _child_obj+'.isShown()', function () {\n		var ctx = this.context;\n	\n		if ( ctx.length && this.length ) {\n			// _detailsShown as false or undefined will fall through to return false\n			return ctx[0].aoData[ this[0] ]._detailsShow || false;\n		}\n		return false;\n	} );\n	\n	\n	\n	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n	 * Columns\n	 *\n	 * {integer}           - column index (>=0 count from left, <0 count from right)\n	 * \"{integer}:visIdx\"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)\n	 * \"{integer}:visible\" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)\n	 * \"{string}:name\"     - column name\n	 * \"{string}\"          - jQuery selector on column header nodes\n	 *\n	 */\n	\n	// can be an array of these items, comma separated list, or an array of comma\n	// separated lists\n	\n	var __re_column_selector = /^(.+):(name|visIdx|visible)$/;\n	\n	\n	// r1 and r2 are redundant - but it means that the parameters match for the\n	// iterator callback in columns().data()\n	var __columnData = function ( settings, column, r1, r2, rows ) {\n		var a = [];\n		for ( var row=0, ien=rows.length ; row<ien ; row++ ) {\n			a.push( _fnGetCellData( settings, rows[row], column ) );\n		}\n		return a;\n	};\n	\n	\n	var __column_selector = function ( settings, selector, opts )\n	{\n		var\n			columns = settings.aoColumns,\n			names = _pluck( columns, 'sName' ),\n			nodes = _pluck( columns, 'nTh' );\n	\n		var run = function ( s ) {\n			var selInt = _intVal( s );\n	\n			// Selector - all\n			if ( s === '' ) {\n				return _range( columns.length );\n			}\n			\n			// Selector - index\n			if ( selInt !== null ) {\n				return [ selInt >= 0 ?\n					selInt : // Count from left\n					columns.length + selInt // Count from right (+ because its a negative value)\n				];\n			}\n			\n			// Selector = function\n			if ( typeof s === 'function' ) {\n				var rows = _selector_row_indexes( settings, opts );\n	\n				return $.map( columns, function (col, idx) {\n					return s(\n							idx,\n							__columnData( settings, idx, 0, 0, rows ),\n							nodes[ idx ]\n						) ? idx : null;\n				} );\n			}\n	\n			// jQuery or string selector\n			var match = typeof s === 'string' ?\n				s.match( __re_column_selector ) :\n				'';\n	\n			if ( match ) {\n				switch( match[2] ) {\n					case 'visIdx':\n					case 'visible':\n						var idx = parseInt( match[1], 10 );\n						// Visible index given, convert to column index\n						if ( idx < 0 ) {\n							// Counting from the right\n							var visColumns = $.map( columns, function (col,i) {\n								return col.bVisible ? i : null;\n							} );\n							return [ visColumns[ visColumns.length + idx ] ];\n						}\n						// Counting from the left\n						return [ _fnVisibleToColumnIndex( settings, idx ) ];\n	\n					case 'name':\n						// match by name. `names` is column index complete and in order\n						return $.map( names, function (name, i) {\n							return name === match[1] ? i : null;\n						} );\n				}\n			}\n			else {\n				// jQuery selector on the TH elements for the columns\n				return $( nodes )\n					.filter( s )\n					.map( function () {\n						return $.inArray( this, nodes ); // `nodes` is column index complete and in order\n					} )\n					.toArray();\n			}\n		};\n	\n		return _selector_run( 'column', selector, run, settings, opts );\n	};\n	\n	\n	var __setColumnVis = function ( settings, column, vis, recalc ) {\n		var\n			cols = settings.aoColumns,\n			col  = cols[ column ],\n			data = settings.aoData,\n			row, cells, i, ien, tr;\n	\n		// Get\n		if ( vis === undefined ) {\n			return col.bVisible;\n		}\n	\n		// Set\n		// No change\n		if ( col.bVisible === vis ) {\n			return;\n		}\n	\n		if ( vis ) {\n			// Insert column\n			// Need to decide if we should use appendChild or insertBefore\n			var insertBefore = $.inArray( true, _pluck(cols, 'bVisible'), column+1 );\n	\n			for ( i=0, ien=data.length ; i<ien ; i++ ) {\n				tr = data[i].nTr;\n				cells = data[i].anCells;\n	\n				if ( tr ) {\n					// insertBefore can act like appendChild if 2nd arg is null\n					tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );\n				}\n			}\n		}\n		else {\n			// Remove column\n			$( _pluck( settings.aoData, 'anCells', column ) ).detach();\n		}\n	\n		// Common actions\n		col.bVisible = vis;\n		_fnDrawHead( settings, settings.aoHeader );\n		_fnDrawHead( settings, settings.aoFooter );\n	\n		if ( recalc === undefined || recalc ) {\n			// Automatically adjust column sizing\n			_fnAdjustColumnSizing( settings );\n	\n			// Realign columns for scrolling\n			if ( settings.oScroll.sX || settings.oScroll.sY ) {\n				_fnScrollDraw( settings );\n			}\n		}\n	\n		_fnCallbackFire( settings, null, 'column-visibility', [settings, column, vis, recalc] );\n	\n		_fnSaveState( settings );\n	};\n	\n	\n	_api_register( 'columns()', function ( selector, opts ) {\n		// argument shifting\n		if ( selector === undefined ) {\n			selector = '';\n		}\n		else if ( $.isPlainObject( selector ) ) {\n			opts = selector;\n			selector = '';\n		}\n	\n		opts = _selector_opts( opts );\n	\n		var inst = this.iterator( 'table', function ( settings ) {\n			return __column_selector( settings, selector, opts );\n		}, 1 );\n	\n		// Want argument shifting here and in _row_selector?\n		inst.selector.cols = selector;\n		inst.selector.opts = opts;\n	\n		return inst;\n	} );\n	\n	_api_registerPlural( 'columns().header()', 'column().header()', function ( selector, opts ) {\n		return this.iterator( 'column', function ( settings, column ) {\n			return settings.aoColumns[column].nTh;\n		}, 1 );\n	} );\n	\n	_api_registerPlural( 'columns().footer()', 'column().footer()', function ( selector, opts ) {\n		return this.iterator( 'column', function ( settings, column ) {\n			return settings.aoColumns[column].nTf;\n		}, 1 );\n	} );\n	\n	_api_registerPlural( 'columns().data()', 'column().data()', function () {\n		return this.iterator( 'column-rows', __columnData, 1 );\n	} );\n	\n	_api_registerPlural( 'columns().dataSrc()', 'column().dataSrc()', function () {\n		return this.iterator( 'column', function ( settings, column ) {\n			return settings.aoColumns[column].mData;\n		}, 1 );\n	} );\n	\n	_api_registerPlural( 'columns().cache()', 'column().cache()', function ( type ) {\n		return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {\n			return _pluck_order( settings.aoData, rows,\n				type === 'search' ? '_aFilterData' : '_aSortData', column\n			);\n		}, 1 );\n	} );\n	\n	_api_registerPlural( 'columns().nodes()', 'column().nodes()', function () {\n		return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {\n			return _pluck_order( settings.aoData, rows, 'anCells', column ) ;\n		}, 1 );\n	} );\n	\n	_api_registerPlural( 'columns().visible()', 'column().visible()', function ( vis, calc ) {\n		return this.iterator( 'column', function ( settings, column ) {\n			if ( vis === undefined ) {\n				return settings.aoColumns[ column ].bVisible;\n			} // else\n			__setColumnVis( settings, column, vis, calc );\n		} );\n	} );\n	\n	_api_registerPlural( 'columns().indexes()', 'column().index()', function ( type ) {\n		return this.iterator( 'column', function ( settings, column ) {\n			return type === 'visible' ?\n				_fnColumnIndexToVisible( settings, column ) :\n				column;\n		}, 1 );\n	} );\n	\n	_api_register( 'columns.adjust()', function () {\n		return this.iterator( 'table', function ( settings ) {\n			_fnAdjustColumnSizing( settings );\n		}, 1 );\n	} );\n	\n	_api_register( 'column.index()', function ( type, idx ) {\n		if ( this.context.length !== 0 ) {\n			var ctx = this.context[0];\n	\n			if ( type === 'fromVisible' || type === 'toData' ) {\n				return _fnVisibleToColumnIndex( ctx, idx );\n			}\n			else if ( type === 'fromData' || type === 'toVisible' ) {\n				return _fnColumnIndexToVisible( ctx, idx );\n			}\n		}\n	} );\n	\n	_api_register( 'column()', function ( selector, opts ) {\n		return _selector_first( this.columns( selector, opts ) );\n	} );\n	\n	\n	\n	\n	var __cell_selector = function ( settings, selector, opts )\n	{\n		var data = settings.aoData;\n		var rows = _selector_row_indexes( settings, opts );\n		var cells = _removeEmpty( _pluck_order( data, rows, 'anCells' ) );\n		var allCells = $( [].concat.apply([], cells) );\n		var row;\n		var columns = settings.aoColumns.length;\n		var a, i, ien, j, o, host;\n	\n		var run = function ( s ) {\n			var fnSelector = typeof s === 'function';\n	\n			if ( s === null || s === undefined || fnSelector ) {\n				// All cells and function selectors\n				a = [];\n	\n				for ( i=0, ien=rows.length ; i<ien ; i++ ) {\n					row = rows[i];\n	\n					for ( j=0 ; j<columns ; j++ ) {\n						o = {\n							row: row,\n							column: j\n						};\n	\n						if ( fnSelector ) {\n							// Selector - function\n							host = data[ row ];\n	\n							if ( s( o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null ) ) {\n								a.push( o );\n							}\n						}\n						else {\n							// Selector - all\n							a.push( o );\n						}\n					}\n				}\n	\n				return a;\n			}\n			\n			// Selector - index\n			if ( $.isPlainObject( s ) ) {\n				return [s];\n			}\n	\n			// Selector - jQuery filtered cells\n			return allCells\n				.filter( s )\n				.map( function (i, el) {\n					return { // use a new object, in case someone changes the values\n						row:    el._DT_CellIndex.row,\n						column: el._DT_CellIndex.column\n	 				};\n				} )\n				.toArray();\n		};\n	\n		return _selector_run( 'cell', selector, run, settings, opts );\n	};\n	\n	\n	\n	\n	_api_register( 'cells()', function ( rowSelector, columnSelector, opts ) {\n		// Argument shifting\n		if ( $.isPlainObject( rowSelector ) ) {\n			// Indexes\n			if ( rowSelector.row === undefined ) {\n				// Selector options in first parameter\n				opts = rowSelector;\n				rowSelector = null;\n			}\n			else {\n				// Cell index objects in first parameter\n				opts = columnSelector;\n				columnSelector = null;\n			}\n		}\n		if ( $.isPlainObject( columnSelector ) ) {\n			opts = columnSelector;\n			columnSelector = null;\n		}\n	\n		// Cell selector\n		if ( columnSelector === null || columnSelector === undefined ) {\n			return this.iterator( 'table', function ( settings ) {\n				return __cell_selector( settings, rowSelector, _selector_opts( opts ) );\n			} );\n		}\n	\n		// Row + column selector\n		var columns = this.columns( columnSelector, opts );\n		var rows = this.rows( rowSelector, opts );\n		var a, i, ien, j, jen;\n	\n		var cells = this.iterator( 'table', function ( settings, idx ) {\n			a = [];\n	\n			for ( i=0, ien=rows[idx].length ; i<ien ; i++ ) {\n				for ( j=0, jen=columns[idx].length ; j<jen ; j++ ) {\n					a.push( {\n						row:    rows[idx][i],\n						column: columns[idx][j]\n					} );\n				}\n			}\n	\n			return a;\n		}, 1 );\n	\n		$.extend( cells.selector, {\n			cols: columnSelector,\n			rows: rowSelector,\n			opts: opts\n		} );\n	\n		return cells;\n	} );\n	\n	\n	_api_registerPlural( 'cells().nodes()', 'cell().node()', function () {\n		return this.iterator( 'cell', function ( settings, row, column ) {\n			var cells = settings.aoData[ row ].anCells;\n			return cells ?\n				cells[ column ] :\n				undefined;\n		}, 1 );\n	} );\n	\n	\n	_api_register( 'cells().data()', function () {\n		return this.iterator( 'cell', function ( settings, row, column ) {\n			return _fnGetCellData( settings, row, column );\n		}, 1 );\n	} );\n	\n	\n	_api_registerPlural( 'cells().cache()', 'cell().cache()', function ( type ) {\n		type = type === 'search' ? '_aFilterData' : '_aSortData';\n	\n		return this.iterator( 'cell', function ( settings, row, column ) {\n			return settings.aoData[ row ][ type ][ column ];\n		}, 1 );\n	} );\n	\n	\n	_api_registerPlural( 'cells().render()', 'cell().render()', function ( type ) {\n		return this.iterator( 'cell', function ( settings, row, column ) {\n			return _fnGetCellData( settings, row, column, type );\n		}, 1 );\n	} );\n	\n	\n	_api_registerPlural( 'cells().indexes()', 'cell().index()', function () {\n		return this.iterator( 'cell', function ( settings, row, column ) {\n			return {\n				row: row,\n				column: column,\n				columnVisible: _fnColumnIndexToVisible( settings, column )\n			};\n		}, 1 );\n	} );\n	\n	\n	_api_registerPlural( 'cells().invalidate()', 'cell().invalidate()', function ( src ) {\n		return this.iterator( 'cell', function ( settings, row, column ) {\n			_fnInvalidate( settings, row, src, column );\n		} );\n	} );\n	\n	\n	\n	_api_register( 'cell()', function ( rowSelector, columnSelector, opts ) {\n		return _selector_first( this.cells( rowSelector, columnSelector, opts ) );\n	} );\n	\n	\n	_api_register( 'cell().data()', function ( data ) {\n		var ctx = this.context;\n		var cell = this[0];\n	\n		if ( data === undefined ) {\n			// Get\n			return ctx.length && cell.length ?\n				_fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :\n				undefined;\n		}\n	\n		// Set\n		_fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );\n		_fnInvalidate( ctx[0], cell[0].row, 'data', cell[0].column );\n	\n		return this;\n	} );\n	\n	\n	\n	/**\n	 * Get current ordering (sorting) that has been applied to the table.\n	 *\n	 * @returns {array} 2D array containing the sorting information for the first\n	 *   table in the current context. Each element in the parent array represents\n	 *   a column being sorted upon (i.e. multi-sorting with two columns would have\n	 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is\n	 *   the column index that the sorting condition applies to, the second is the\n	 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the\n	 *   index of the sorting order from the `column.sorting` initialisation array.\n	 *//**\n	 * Set the ordering for the table.\n	 *\n	 * @param {integer} order Column index to sort upon.\n	 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)\n	 * @returns {DataTables.Api} this\n	 *//**\n	 * Set the ordering for the table.\n	 *\n	 * @param {array} order 1D array of sorting information to be applied.\n	 * @param {array} [...] Optional additional sorting conditions\n	 * @returns {DataTables.Api} this\n	 *//**\n	 * Set the ordering for the table.\n	 *\n	 * @param {array} order 2D array of sorting information to be applied.\n	 * @returns {DataTables.Api} this\n	 */\n	_api_register( 'order()', function ( order, dir ) {\n		var ctx = this.context;\n	\n		if ( order === undefined ) {\n			// get\n			return ctx.length !== 0 ?\n				ctx[0].aaSorting :\n				undefined;\n		}\n	\n		// set\n		if ( typeof order === 'number' ) {\n			// Simple column / direction passed in\n			order = [ [ order, dir ] ];\n		}\n		else if ( ! $.isArray( order[0] ) ) {\n			// Arguments passed in (list of 1D arrays)\n			order = Array.prototype.slice.call( arguments );\n		}\n		// otherwise a 2D array was passed in\n	\n		return this.iterator( 'table', function ( settings ) {\n			settings.aaSorting = order.slice();\n		} );\n	} );\n	\n	\n	/**\n	 * Attach a sort listener to an element for a given column\n	 *\n	 * @param {node|jQuery|string} node Identifier for the element(s) to attach the\n	 *   listener to. This can take the form of a single DOM node, a jQuery\n	 *   collection of nodes or a jQuery selector which will identify the node(s).\n	 * @param {integer} column the column that a click on this node will sort on\n	 * @param {function} [callback] callback function when sort is run\n	 * @returns {DataTables.Api} this\n	 */\n	_api_register( 'order.listener()', function ( node, column, callback ) {\n		return this.iterator( 'table', function ( settings ) {\n			_fnSortAttachListener( settings, node, column, callback );\n		} );\n	} );\n	\n	\n	_api_register( 'order.fixed()', function ( set ) {\n		if ( ! set ) {\n			var ctx = this.context;\n			var fixed = ctx.length ?\n				ctx[0].aaSortingFixed :\n				undefined;\n	\n			return $.isArray( fixed ) ?\n				{ pre: fixed } :\n				fixed;\n		}\n	\n		return this.iterator( 'table', function ( settings ) {\n			settings.aaSortingFixed = $.extend( true, {}, set );\n		} );\n	} );\n	\n	\n	// Order by the selected column(s)\n	_api_register( [\n		'columns().order()',\n		'column().order()'\n	], function ( dir ) {\n		var that = this;\n	\n		return this.iterator( 'table', function ( settings, i ) {\n			var sort = [];\n	\n			$.each( that[i], function (j, col) {\n				sort.push( [ col, dir ] );\n			} );\n	\n			settings.aaSorting = sort;\n		} );\n	} );\n	\n	\n	\n	_api_register( 'search()', function ( input, regex, smart, caseInsen ) {\n		var ctx = this.context;\n	\n		if ( input === undefined ) {\n			// get\n			return ctx.length !== 0 ?\n				ctx[0].oPreviousSearch.sSearch :\n				undefined;\n		}\n	\n		// set\n		return this.iterator( 'table', function ( settings ) {\n			if ( ! settings.oFeatures.bFilter ) {\n				return;\n			}\n	\n			_fnFilterComplete( settings, $.extend( {}, settings.oPreviousSearch, {\n				\"sSearch\": input+\"\",\n				\"bRegex\":  regex === null ? false : regex,\n				\"bSmart\":  smart === null ? true  : smart,\n				\"bCaseInsensitive\": caseInsen === null ? true : caseInsen\n			} ), 1 );\n		} );\n	} );\n	\n	\n	_api_registerPlural(\n		'columns().search()',\n		'column().search()',\n		function ( input, regex, smart, caseInsen ) {\n			return this.iterator( 'column', function ( settings, column ) {\n				var preSearch = settings.aoPreSearchCols;\n	\n				if ( input === undefined ) {\n					// get\n					return preSearch[ column ].sSearch;\n				}\n	\n				// set\n				if ( ! settings.oFeatures.bFilter ) {\n					return;\n				}\n	\n				$.extend( preSearch[ column ], {\n					\"sSearch\": input+\"\",\n					\"bRegex\":  regex === null ? false : regex,\n					\"bSmart\":  smart === null ? true  : smart,\n					\"bCaseInsensitive\": caseInsen === null ? true : caseInsen\n				} );\n	\n				_fnFilterComplete( settings, settings.oPreviousSearch, 1 );\n			} );\n		}\n	);\n	\n	/*\n	 * State API methods\n	 */\n	\n	_api_register( 'state()', function () {\n		return this.context.length ?\n			this.context[0].oSavedState :\n			null;\n	} );\n	\n	\n	_api_register( 'state.clear()', function () {\n		return this.iterator( 'table', function ( settings ) {\n			// Save an empty object\n			settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );\n		} );\n	} );\n	\n	\n	_api_register( 'state.loaded()', function () {\n		return this.context.length ?\n			this.context[0].oLoadedState :\n			null;\n	} );\n	\n	\n	_api_register( 'state.save()', function () {\n		return this.iterator( 'table', function ( settings ) {\n			_fnSaveState( settings );\n		} );\n	} );\n	\n	\n	\n	/**\n	 * Provide a common method for plug-ins to check the version of DataTables being\n	 * used, in order to ensure compatibility.\n	 *\n	 *  @param {string} version Version string to check for, in the format \"X.Y.Z\".\n	 *    Note that the formats \"X\" and \"X.Y\" are also acceptable.\n	 *  @returns {boolean} true if this version of DataTables is greater or equal to\n	 *    the required version, or false if this version of DataTales is not\n	 *    suitable\n	 *  @static\n	 *  @dtopt API-Static\n	 *\n	 *  @example\n	 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );\n	 */\n	DataTable.versionCheck = DataTable.fnVersionCheck = function( version )\n	{\n		var aThis = DataTable.version.split('.');\n		var aThat = version.split('.');\n		var iThis, iThat;\n	\n		for ( var i=0, iLen=aThat.length ; i<iLen ; i++ ) {\n			iThis = parseInt( aThis[i], 10 ) || 0;\n			iThat = parseInt( aThat[i], 10 ) || 0;\n	\n			// Parts are the same, keep comparing\n			if (iThis === iThat) {\n				continue;\n			}\n	\n			// Parts are different, return immediately\n			return iThis > iThat;\n		}\n	\n		return true;\n	};\n	\n	\n	/**\n	 * Check if a `<table>` node is a DataTable table already or not.\n	 *\n	 *  @param {node|jquery|string} table Table node, jQuery object or jQuery\n	 *      selector for the table to test. Note that if more than more than one\n	 *      table is passed on, only the first will be checked\n	 *  @returns {boolean} true the table given is a DataTable, or false otherwise\n	 *  @static\n	 *  @dtopt API-Static\n	 *\n	 *  @example\n	 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {\n	 *      $('#example').dataTable();\n	 *    }\n	 */\n	DataTable.isDataTable = DataTable.fnIsDataTable = function ( table )\n	{\n		var t = $(table).get(0);\n		var is = false;\n	\n		$.each( DataTable.settings, function (i, o) {\n			var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;\n			var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;\n	\n			if ( o.nTable === t || head === t || foot === t ) {\n				is = true;\n			}\n		} );\n	\n		return is;\n	};\n	\n	\n	/**\n	 * Get all DataTable tables that have been initialised - optionally you can\n	 * select to get only currently visible tables.\n	 *\n	 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)\n	 *    or visible tables only.\n	 *  @returns {array} Array of `table` nodes (not DataTable instances) which are\n	 *    DataTables\n	 *  @static\n	 *  @dtopt API-Static\n	 *\n	 *  @example\n	 *    $.each( $.fn.dataTable.tables(true), function () {\n	 *      $(table).DataTable().columns.adjust();\n	 *    } );\n	 */\n	DataTable.tables = DataTable.fnTables = function ( visible )\n	{\n		var api = false;\n	\n		if ( $.isPlainObject( visible ) ) {\n			api = visible.api;\n			visible = visible.visible;\n		}\n	\n		var a = $.map( DataTable.settings, function (o) {\n			if ( !visible || (visible && $(o.nTable).is(':visible')) ) {\n				return o.nTable;\n			}\n		} );\n	\n		return api ?\n			new _Api( a ) :\n			a;\n	};\n	\n	\n	/**\n	 * DataTables utility methods\n	 * \n	 * This namespace provides helper methods that DataTables uses internally to\n	 * create a DataTable, but which are not exclusively used only for DataTables.\n	 * These methods can be used by extension authors to save the duplication of\n	 * code.\n	 *\n	 *  @namespace\n	 */\n	DataTable.util = {\n		/**\n		 * Throttle the calls to a function. Arguments and context are maintained\n		 * for the throttled function.\n		 *\n		 * @param {function} fn Function to be called\n		 * @param {integer} freq Call frequency in mS\n		 * @return {function} Wrapped function\n		 */\n		throttle: _fnThrottle,\n	\n	\n		/**\n		 * Escape a string such that it can be used in a regular expression\n		 *\n		 *  @param {string} sVal string to escape\n		 *  @returns {string} escaped string\n		 */\n		escapeRegex: _fnEscapeRegex\n	};\n	\n	\n	/**\n	 * Convert from camel case parameters to Hungarian notation. This is made public\n	 * for the extensions to provide the same ability as DataTables core to accept\n	 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase\n	 * parameters.\n	 *\n	 *  @param {object} src The model object which holds all parameters that can be\n	 *    mapped.\n	 *  @param {object} user The object to convert from camel case to Hungarian.\n	 *  @param {boolean} force When set to `true`, properties which already have a\n	 *    Hungarian value in the `user` object will be overwritten. Otherwise they\n	 *    won't be.\n	 */\n	DataTable.camelToHungarian = _fnCamelToHungarian;\n	\n	\n	\n	/**\n	 *\n	 */\n	_api_register( '$()', function ( selector, opts ) {\n		var\n			rows   = this.rows( opts ).nodes(), // Get all rows\n			jqRows = $(rows);\n	\n		return $( [].concat(\n			jqRows.filter( selector ).toArray(),\n			jqRows.find( selector ).toArray()\n		) );\n	} );\n	\n	\n	// jQuery functions to operate on the tables\n	$.each( [ 'on', 'one', 'off' ], function (i, key) {\n		_api_register( key+'()', function ( /* event, handler */ ) {\n			var args = Array.prototype.slice.call(arguments);\n	\n			// Add the `dt` namespace automatically if it isn't already present\n			if ( ! args[0].match(/\\.dt\\b/) ) {\n				args[0] += '.dt';\n			}\n	\n			var inst = $( this.tables().nodes() );\n			inst[key].apply( inst, args );\n			return this;\n		} );\n	} );\n	\n	\n	_api_register( 'clear()', function () {\n		return this.iterator( 'table', function ( settings ) {\n			_fnClearTable( settings );\n		} );\n	} );\n	\n	\n	_api_register( 'settings()', function () {\n		return new _Api( this.context, this.context );\n	} );\n	\n	\n	_api_register( 'init()', function () {\n		var ctx = this.context;\n		return ctx.length ? ctx[0].oInit : null;\n	} );\n	\n	\n	_api_register( 'data()', function () {\n		return this.iterator( 'table', function ( settings ) {\n			return _pluck( settings.aoData, '_aData' );\n		} ).flatten();\n	} );\n	\n	\n	_api_register( 'destroy()', function ( remove ) {\n		remove = remove || false;\n	\n		return this.iterator( 'table', function ( settings ) {\n			var orig      = settings.nTableWrapper.parentNode;\n			var classes   = settings.oClasses;\n			var table     = settings.nTable;\n			var tbody     = settings.nTBody;\n			var thead     = settings.nTHead;\n			var tfoot     = settings.nTFoot;\n			var jqTable   = $(table);\n			var jqTbody   = $(tbody);\n			var jqWrapper = $(settings.nTableWrapper);\n			var rows      = $.map( settings.aoData, function (r) { return r.nTr; } );\n			var i, ien;\n	\n			// Flag to note that the table is currently being destroyed - no action\n			// should be taken\n			settings.bDestroying = true;\n	\n			// Fire off the destroy callbacks for plug-ins etc\n			_fnCallbackFire( settings, \"aoDestroyCallback\", \"destroy\", [settings] );\n	\n			// If not being removed from the document, make all columns visible\n			if ( ! remove ) {\n				new _Api( settings ).columns().visible( true );\n			}\n	\n			// Blitz all `DT` namespaced events (these are internal events, the\n			// lowercase, `dt` events are user subscribed and they are responsible\n			// for removing them\n			jqWrapper.unbind('.DT').find(':not(tbody *)').unbind('.DT');\n			$(window).unbind('.DT-'+settings.sInstance);\n	\n			// When scrolling we had to break the table up - restore it\n			if ( table != thead.parentNode ) {\n				jqTable.children('thead').detach();\n				jqTable.append( thead );\n			}\n	\n			if ( tfoot && table != tfoot.parentNode ) {\n				jqTable.children('tfoot').detach();\n				jqTable.append( tfoot );\n			}\n	\n			settings.aaSorting = [];\n			settings.aaSortingFixed = [];\n			_fnSortingClasses( settings );\n	\n			$( rows ).removeClass( settings.asStripeClasses.join(' ') );\n	\n			$('th, td', thead).removeClass( classes.sSortable+' '+\n				classes.sSortableAsc+' '+classes.sSortableDesc+' '+classes.sSortableNone\n			);\n	\n			if ( settings.bJUI ) {\n				$('th span.'+classes.sSortIcon+ ', td span.'+classes.sSortIcon, thead).detach();\n				$('th, td', thead).each( function () {\n					var wrapper = $('div.'+classes.sSortJUIWrapper, this);\n					$(this).append( wrapper.contents() );\n					wrapper.detach();\n				} );\n			}\n	\n			// Add the TR elements back into the table in their original order\n			jqTbody.children().detach();\n			jqTbody.append( rows );\n	\n			// Remove the DataTables generated nodes, events and classes\n			var removedMethod = remove ? 'remove' : 'detach';\n			jqTable[ removedMethod ]();\n			jqWrapper[ removedMethod ]();\n	\n			// If we need to reattach the table to the document\n			if ( ! remove && orig ) {\n				// insertBefore acts like appendChild if !arg[1]\n				orig.insertBefore( table, settings.nTableReinsertBefore );\n	\n				// Restore the width of the original table - was read from the style property,\n				// so we can restore directly to that\n				jqTable\n					.css( 'width', settings.sDestroyWidth )\n					.removeClass( classes.sTable );\n	\n				// If the were originally stripe classes - then we add them back here.\n				// Note this is not fool proof (for example if not all rows had stripe\n				// classes - but it's a good effort without getting carried away\n				ien = settings.asDestroyStripes.length;\n	\n				if ( ien ) {\n					jqTbody.children().each( function (i) {\n						$(this).addClass( settings.asDestroyStripes[i % ien] );\n					} );\n				}\n			}\n	\n			/* Remove the settings object from the settings array */\n			var idx = $.inArray( settings, DataTable.settings );\n			if ( idx !== -1 ) {\n				DataTable.settings.splice( idx, 1 );\n			}\n		} );\n	} );\n	\n	\n	// Add the `every()` method for rows, columns and cells in a compact form\n	$.each( [ 'column', 'row', 'cell' ], function ( i, type ) {\n		_api_register( type+'s().every()', function ( fn ) {\n			var opts = this.selector.opts;\n			var api = this;\n	\n			return this.iterator( type, function ( settings, arg1, arg2, arg3, arg4 ) {\n				// Rows and columns:\n				//  arg1 - index\n				//  arg2 - table counter\n				//  arg3 - loop counter\n				//  arg4 - undefined\n				// Cells:\n				//  arg1 - row index\n				//  arg2 - column index\n				//  arg3 - table counter\n				//  arg4 - loop counter\n				fn.call(\n					api[ type ](\n						arg1,\n						type==='cell' ? arg2 : opts,\n						type==='cell' ? opts : undefined\n					),\n					arg1, arg2, arg3, arg4\n				);\n			} );\n		} );\n	} );\n	\n	\n	// i18n method for extensions to be able to use the language object from the\n	// DataTable\n	_api_register( 'i18n()', function ( token, def, plural ) {\n		var ctx = this.context[0];\n		var resolved = _fnGetObjectDataFn( token )( ctx.oLanguage );\n	\n		if ( resolved === undefined ) {\n			resolved = def;\n		}\n	\n		if ( plural !== undefined && $.isPlainObject( resolved ) ) {\n			resolved = resolved[ plural ] !== undefined ?\n				resolved[ plural ] :\n				resolved._;\n		}\n	\n		return resolved.replace( '%d', plural ); // nb: plural might be undefined,\n	} );\n	/**\n	 * Version string for plug-ins to check compatibility. Allowed format is\n	 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used\n	 * only for non-release builds. See http://semver.org/ for more information.\n	 *  @member\n	 *  @type string\n	 *  @default Version number\n	 */\n	DataTable.version = \"1.10.10\";\n\n	/**\n	 * Private data store, containing all of the settings objects that are\n	 * created for the tables on a given page.\n	 *\n	 * Note that the `DataTable.settings` object is aliased to\n	 * `jQuery.fn.dataTableExt` through which it may be accessed and\n	 * manipulated, or `jQuery.fn.dataTable.settings`.\n	 *  @member\n	 *  @type array\n	 *  @default []\n	 *  @private\n	 */\n	DataTable.settings = [];\n\n	/**\n	 * Object models container, for the various models that DataTables has\n	 * available to it. These models define the objects that are used to hold\n	 * the active state and configuration of the table.\n	 *  @namespace\n	 */\n	DataTable.models = {};\n	\n	\n	\n	/**\n	 * Template object for the way in which DataTables holds information about\n	 * search information for the global filter and individual column filters.\n	 *  @namespace\n	 */\n	DataTable.models.oSearch = {\n		/**\n		 * Flag to indicate if the filtering should be case insensitive or not\n		 *  @type boolean\n		 *  @default true\n		 */\n		\"bCaseInsensitive\": true,\n	\n		/**\n		 * Applied search term\n		 *  @type string\n		 *  @default <i>Empty string</i>\n		 */\n		\"sSearch\": \"\",\n	\n		/**\n		 * Flag to indicate if the search term should be interpreted as a\n		 * regular expression (true) or not (false) and therefore and special\n		 * regex characters escaped.\n		 *  @type boolean\n		 *  @default false\n		 */\n		\"bRegex\": false,\n	\n		/**\n		 * Flag to indicate if DataTables is to use its smart filtering or not.\n		 *  @type boolean\n		 *  @default true\n		 */\n		\"bSmart\": true\n	};\n	\n	\n	\n	\n	/**\n	 * Template object for the way in which DataTables holds information about\n	 * each individual row. This is the object format used for the settings\n	 * aoData array.\n	 *  @namespace\n	 */\n	DataTable.models.oRow = {\n		/**\n		 * TR element for the row\n		 *  @type node\n		 *  @default null\n		 */\n		\"nTr\": null,\n	\n		/**\n		 * Array of TD elements for each row. This is null until the row has been\n		 * created.\n		 *  @type array nodes\n		 *  @default []\n		 */\n		\"anCells\": null,\n	\n		/**\n		 * Data object from the original data source for the row. This is either\n		 * an array if using the traditional form of DataTables, or an object if\n		 * using mData options. The exact type will depend on the passed in\n		 * data from the data source, or will be an array if using DOM a data\n		 * source.\n		 *  @type array|object\n		 *  @default []\n		 */\n		\"_aData\": [],\n	\n		/**\n		 * Sorting data cache - this array is ostensibly the same length as the\n		 * number of columns (although each index is generated only as it is\n		 * needed), and holds the data that is used for sorting each column in the\n		 * row. We do this cache generation at the start of the sort in order that\n		 * the formatting of the sort data need be done only once for each cell\n		 * per sort. This array should not be read from or written to by anything\n		 * other than the master sorting methods.\n		 *  @type array\n		 *  @default null\n		 *  @private\n		 */\n		\"_aSortData\": null,\n	\n		/**\n		 * Per cell filtering data cache. As per the sort data cache, used to\n		 * increase the performance of the filtering in DataTables\n		 *  @type array\n		 *  @default null\n		 *  @private\n		 */\n		\"_aFilterData\": null,\n	\n		/**\n		 * Filtering data cache. This is the same as the cell filtering cache, but\n		 * in this case a string rather than an array. This is easily computed with\n		 * a join on `_aFilterData`, but is provided as a cache so the join isn't\n		 * needed on every search (memory traded for performance)\n		 *  @type array\n		 *  @default null\n		 *  @private\n		 */\n		\"_sFilterRow\": null,\n	\n		/**\n		 * Cache of the class name that DataTables has applied to the row, so we\n		 * can quickly look at this variable rather than needing to do a DOM check\n		 * on className for the nTr property.\n		 *  @type string\n		 *  @default <i>Empty string</i>\n		 *  @private\n		 */\n		\"_sRowStripe\": \"\",\n	\n		/**\n		 * Denote if the original data source was from the DOM, or the data source\n		 * object. This is used for invalidating data, so DataTables can\n		 * automatically read data from the original source, unless uninstructed\n		 * otherwise.\n		 *  @type string\n		 *  @default null\n		 *  @private\n		 */\n		\"src\": null,\n	\n		/**\n		 * Index in the aoData array. This saves an indexOf lookup when we have the\n		 * object, but want to know the index\n		 *  @type integer\n		 *  @default -1\n		 *  @private\n		 */\n		\"idx\": -1\n	};\n	\n	\n	/**\n	 * Template object for the column information object in DataTables. This object\n	 * is held in the settings aoColumns array and contains all the information that\n	 * DataTables needs about each individual column.\n	 *\n	 * Note that this object is related to {@link DataTable.defaults.column}\n	 * but this one is the internal data store for DataTables's cache of columns.\n	 * It should NOT be manipulated outside of DataTables. Any configuration should\n	 * be done through the initialisation options.\n	 *  @namespace\n	 */\n	DataTable.models.oColumn = {\n		/**\n		 * Column index. This could be worked out on-the-fly with $.inArray, but it\n		 * is faster to just hold it as a variable\n		 *  @type integer\n		 *  @default null\n		 */\n		\"idx\": null,\n	\n		/**\n		 * A list of the columns that sorting should occur on when this column\n		 * is sorted. That this property is an array allows multi-column sorting\n		 * to be defined for a column (for example first name / last name columns\n		 * would benefit from this). The values are integers pointing to the\n		 * columns to be sorted on (typically it will be a single integer pointing\n		 * at itself, but that doesn't need to be the case).\n		 *  @type array\n		 */\n		\"aDataSort\": null,\n	\n		/**\n		 * Define the sorting directions that are applied to the column, in sequence\n		 * as the column is repeatedly sorted upon - i.e. the first value is used\n		 * as the sorting direction when the column if first sorted (clicked on).\n		 * Sort it again (click again) and it will move on to the next index.\n		 * Repeat until loop.\n		 *  @type array\n		 */\n		\"asSorting\": null,\n	\n		/**\n		 * Flag to indicate if the column is searchable, and thus should be included\n		 * in the filtering or not.\n		 *  @type boolean\n		 */\n		\"bSearchable\": null,\n	\n		/**\n		 * Flag to indicate if the column is sortable or not.\n		 *  @type boolean\n		 */\n		\"bSortable\": null,\n	\n		/**\n		 * Flag to indicate if the column is currently visible in the table or not\n		 *  @type boolean\n		 */\n		\"bVisible\": null,\n	\n		/**\n		 * Store for manual type assignment using the `column.type` option. This\n		 * is held in store so we can manipulate the column's `sType` property.\n		 *  @type string\n		 *  @default null\n		 *  @private\n		 */\n		\"_sManualType\": null,\n	\n		/**\n		 * Flag to indicate if HTML5 data attributes should be used as the data\n		 * source for filtering or sorting. True is either are.\n		 *  @type boolean\n		 *  @default false\n		 *  @private\n		 */\n		\"_bAttrSrc\": false,\n	\n		/**\n		 * Developer definable function that is called whenever a cell is created (Ajax source,\n		 * etc) or processed for input (DOM source). This can be used as a compliment to mRender\n		 * allowing you to modify the DOM element (add background colour for example) when the\n		 * element is available.\n		 *  @type function\n		 *  @param {element} nTd The TD node that has been created\n		 *  @param {*} sData The Data for the cell\n		 *  @param {array|object} oData The data for the whole row\n		 *  @param {int} iRow The row index for the aoData data store\n		 *  @default null\n		 */\n		\"fnCreatedCell\": null,\n	\n		/**\n		 * Function to get data from a cell in a column. You should <b>never</b>\n		 * access data directly through _aData internally in DataTables - always use\n		 * the method attached to this property. It allows mData to function as\n		 * required. This function is automatically assigned by the column\n		 * initialisation method\n		 *  @type function\n		 *  @param {array|object} oData The data array/object for the array\n		 *    (i.e. aoData[]._aData)\n		 *  @param {string} sSpecific The specific data type you want to get -\n		 *    'display', 'type' 'filter' 'sort'\n		 *  @returns {*} The data for the cell from the given row's data\n		 *  @default null\n		 */\n		\"fnGetData\": null,\n	\n		/**\n		 * Function to set data for a cell in the column. You should <b>never</b>\n		 * set the data directly to _aData internally in DataTables - always use\n		 * this method. It allows mData to function as required. This function\n		 * is automatically assigned by the column initialisation method\n		 *  @type function\n		 *  @param {array|object} oData The data array/object for the array\n		 *    (i.e. aoData[]._aData)\n		 *  @param {*} sValue Value to set\n		 *  @default null\n		 */\n		\"fnSetData\": null,\n	\n		/**\n		 * Property to read the value for the cells in the column from the data\n		 * source array / object. If null, then the default content is used, if a\n		 * function is given then the return from the function is used.\n		 *  @type function|int|string|null\n		 *  @default null\n		 */\n		\"mData\": null,\n	\n		/**\n		 * Partner property to mData which is used (only when defined) to get\n		 * the data - i.e. it is basically the same as mData, but without the\n		 * 'set' option, and also the data fed to it is the result from mData.\n		 * This is the rendering method to match the data method of mData.\n		 *  @type function|int|string|null\n		 *  @default null\n		 */\n		\"mRender\": null,\n	\n		/**\n		 * Unique header TH/TD element for this column - this is what the sorting\n		 * listener is attached to (if sorting is enabled.)\n		 *  @type node\n		 *  @default null\n		 */\n		\"nTh\": null,\n	\n		/**\n		 * Unique footer TH/TD element for this column (if there is one). Not used\n		 * in DataTables as such, but can be used for plug-ins to reference the\n		 * footer for each column.\n		 *  @type node\n		 *  @default null\n		 */\n		\"nTf\": null,\n	\n		/**\n		 * The class to apply to all TD elements in the table's TBODY for the column\n		 *  @type string\n		 *  @default null\n		 */\n		\"sClass\": null,\n	\n		/**\n		 * When DataTables calculates the column widths to assign to each column,\n		 * it finds the longest string in each column and then constructs a\n		 * temporary table and reads the widths from that. The problem with this\n		 * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\n		 * string - thus the calculation can go wrong (doing it properly and putting\n		 * it into an DOM object and measuring that is horribly(!) slow). Thus as\n		 * a \"work around\" we provide this option. It will append its value to the\n		 * text that is found to be the longest string for the column - i.e. padding.\n		 *  @type string\n		 */\n		\"sContentPadding\": null,\n	\n		/**\n		 * Allows a default value to be given for a column's data, and will be used\n		 * whenever a null data source is encountered (this can be because mData\n		 * is set to null, or because the data source itself is null).\n		 *  @type string\n		 *  @default null\n		 */\n		\"sDefaultContent\": null,\n	\n		/**\n		 * Name for the column, allowing reference to the column by name as well as\n		 * by index (needs a lookup to work by name).\n		 *  @type string\n		 */\n		\"sName\": null,\n	\n		/**\n		 * Custom sorting data type - defines which of the available plug-ins in\n		 * afnSortData the custom sorting will use - if any is defined.\n		 *  @type string\n		 *  @default std\n		 */\n		\"sSortDataType\": 'std',\n	\n		/**\n		 * Class to be applied to the header element when sorting on this column\n		 *  @type string\n		 *  @default null\n		 */\n		\"sSortingClass\": null,\n	\n		/**\n		 * Class to be applied to the header element when sorting on this column -\n		 * when jQuery UI theming is used.\n		 *  @type string\n		 *  @default null\n		 */\n		\"sSortingClassJUI\": null,\n	\n		/**\n		 * Title of the column - what is seen in the TH element (nTh).\n		 *  @type string\n		 */\n		\"sTitle\": null,\n	\n		/**\n		 * Column sorting and filtering type\n		 *  @type string\n		 *  @default null\n		 */\n		\"sType\": null,\n	\n		/**\n		 * Width of the column\n		 *  @type string\n		 *  @default null\n		 */\n		\"sWidth\": null,\n	\n		/**\n		 * Width of the column when it was first \"encountered\"\n		 *  @type string\n		 *  @default null\n		 */\n		\"sWidthOrig\": null\n	};\n	\n	\n	/*\n	 * Developer note: The properties of the object below are given in Hungarian\n	 * notation, that was used as the interface for DataTables prior to v1.10, however\n	 * from v1.10 onwards the primary interface is camel case. In order to avoid\n	 * breaking backwards compatibility utterly with this change, the Hungarian\n	 * version is still, internally the primary interface, but is is not documented\n	 * - hence the @name tags in each doc comment. This allows a Javascript function\n	 * to create a map from Hungarian notation to camel case (going the other direction\n	 * would require each property to be listed, which would at around 3K to the size\n	 * of DataTables, while this method is about a 0.5K hit.\n	 *\n	 * Ultimately this does pave the way for Hungarian notation to be dropped\n	 * completely, but that is a massive amount of work and will break current\n	 * installs (therefore is on-hold until v2).\n	 */\n	\n	/**\n	 * Initialisation options that can be given to DataTables at initialisation\n	 * time.\n	 *  @namespace\n	 */\n	DataTable.defaults = {\n		/**\n		 * An array of data to use for the table, passed in at initialisation which\n		 * will be used in preference to any data which is already in the DOM. This is\n		 * particularly useful for constructing tables purely in Javascript, for\n		 * example with a custom Ajax call.\n		 *  @type array\n		 *  @default null\n		 *\n		 *  @dtopt Option\n		 *  @name DataTable.defaults.data\n		 *\n		 *  @example\n		 *    // Using a 2D array data source\n		 *    $(document).ready( function () {\n		 *      $('#example').dataTable( {\n		 *        \"data\": [\n		 *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],\n		 *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],\n		 *        ],\n		 *        \"columns\": [\n		 *          { \"title\": \"Engine\" },\n		 *          { \"title\": \"Browser\" },\n		 *          { \"title\": \"Platform\" },\n		 *          { \"title\": \"Version\" },\n		 *          { \"title\": \"Grade\" }\n		 *        ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using an array of objects as a data source (`data`)\n		 *    $(document).ready( function () {\n		 *      $('#example').dataTable( {\n		 *        \"data\": [\n		 *          {\n		 *            \"engine\":   \"Trident\",\n		 *            \"browser\":  \"Internet Explorer 4.0\",\n		 *            \"platform\": \"Win 95+\",\n		 *            \"version\":  4,\n		 *            \"grade\":    \"X\"\n		 *          },\n		 *          {\n		 *            \"engine\":   \"Trident\",\n		 *            \"browser\":  \"Internet Explorer 5.0\",\n		 *            \"platform\": \"Win 95+\",\n		 *            \"version\":  5,\n		 *            \"grade\":    \"C\"\n		 *          }\n		 *        ],\n		 *        \"columns\": [\n		 *          { \"title\": \"Engine\",   \"data\": \"engine\" },\n		 *          { \"title\": \"Browser\",  \"data\": \"browser\" },\n		 *          { \"title\": \"Platform\", \"data\": \"platform\" },\n		 *          { \"title\": \"Version\",  \"data\": \"version\" },\n		 *          { \"title\": \"Grade\",    \"data\": \"grade\" }\n		 *        ]\n		 *      } );\n		 *    } );\n		 */\n		\"aaData\": null,\n	\n	\n		/**\n		 * If ordering is enabled, then DataTables will perform a first pass sort on\n		 * initialisation. You can define which column(s) the sort is performed\n		 * upon, and the sorting direction, with this variable. The `sorting` array\n		 * should contain an array for each column to be sorted initially containing\n		 * the column's index and a direction string ('asc' or 'desc').\n		 *  @type array\n		 *  @default [[0,'asc']]\n		 *\n		 *  @dtopt Option\n		 *  @name DataTable.defaults.order\n		 *\n		 *  @example\n		 *    // Sort by 3rd column first, and then 4th column\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"order\": [[2,'asc'], [3,'desc']]\n		 *      } );\n		 *    } );\n		 *\n		 *    // No initial sorting\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"order\": []\n		 *      } );\n		 *    } );\n		 */\n		\"aaSorting\": [[0,'asc']],\n	\n	\n		/**\n		 * This parameter is basically identical to the `sorting` parameter, but\n		 * cannot be overridden by user interaction with the table. What this means\n		 * is that you could have a column (visible or hidden) which the sorting\n		 * will always be forced on first - any sorting after that (from the user)\n		 * will then be performed as required. This can be useful for grouping rows\n		 * together.\n		 *  @type array\n		 *  @default null\n		 *\n		 *  @dtopt Option\n		 *  @name DataTable.defaults.orderFixed\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"orderFixed\": [[0,'asc']]\n		 *      } );\n		 *    } )\n		 */\n		\"aaSortingFixed\": [],\n	\n	\n		/**\n		 * DataTables can be instructed to load data to display in the table from a\n		 * Ajax source. This option defines how that Ajax call is made and where to.\n		 *\n		 * The `ajax` property has three different modes of operation, depending on\n		 * how it is defined. These are:\n		 *\n		 * * `string` - Set the URL from where the data should be loaded from.\n		 * * `object` - Define properties for `jQuery.ajax`.\n		 * * `function` - Custom data get function\n		 *\n		 * `string`\n		 * --------\n		 *\n		 * As a string, the `ajax` property simply defines the URL from which\n		 * DataTables will load data.\n		 *\n		 * `object`\n		 * --------\n		 *\n		 * As an object, the parameters in the object are passed to\n		 * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control\n		 * of the Ajax request. DataTables has a number of default parameters which\n		 * you can override using this option. Please refer to the jQuery\n		 * documentation for a full description of the options available, although\n		 * the following parameters provide additional options in DataTables or\n		 * require special consideration:\n		 *\n		 * * `data` - As with jQuery, `data` can be provided as an object, but it\n		 *   can also be used as a function to manipulate the data DataTables sends\n		 *   to the server. The function takes a single parameter, an object of\n		 *   parameters with the values that DataTables has readied for sending. An\n		 *   object may be returned which will be merged into the DataTables\n		 *   defaults, or you can add the items to the object that was passed in and\n		 *   not return anything from the function. This supersedes `fnServerParams`\n		 *   from DataTables 1.9-.\n		 *\n		 * * `dataSrc` - By default DataTables will look for the property `data` (or\n		 *   `aaData` for compatibility with DataTables 1.9-) when obtaining data\n		 *   from an Ajax source or for server-side processing - this parameter\n		 *   allows that property to be changed. You can use Javascript dotted\n		 *   object notation to get a data source for multiple levels of nesting, or\n		 *   it my be used as a function. As a function it takes a single parameter,\n		 *   the JSON returned from the server, which can be manipulated as\n		 *   required, with the returned value being that used by DataTables as the\n		 *   data source for the table. This supersedes `sAjaxDataProp` from\n		 *   DataTables 1.9-.\n		 *\n		 * * `success` - Should not be overridden it is used internally in\n		 *   DataTables. To manipulate / transform the data returned by the server\n		 *   use `ajax.dataSrc`, or use `ajax` as a function (see below).\n		 *\n		 * `function`\n		 * ----------\n		 *\n		 * As a function, making the Ajax call is left up to yourself allowing\n		 * complete control of the Ajax request. Indeed, if desired, a method other\n		 * than Ajax could be used to obtain the required data, such as Web storage\n		 * or an AIR database.\n		 *\n		 * The function is given four parameters and no return is required. The\n		 * parameters are:\n		 *\n		 * 1. _object_ - Data to send to the server\n		 * 2. _function_ - Callback function that must be executed when the required\n		 *    data has been obtained. That data should be passed into the callback\n		 *    as the only parameter\n		 * 3. _object_ - DataTables settings object for the table\n		 *\n		 * Note that this supersedes `fnServerData` from DataTables 1.9-.\n		 *\n		 *  @type string|object|function\n		 *  @default null\n		 *\n		 *  @dtopt Option\n		 *  @name DataTable.defaults.ajax\n		 *  @since 1.10.0\n		 *\n		 * @example\n		 *   // Get JSON data from a file via Ajax.\n		 *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).\n		 *   $('#example').dataTable( {\n		 *     \"ajax\": \"data.json\"\n		 *   } );\n		 *\n		 * @example\n		 *   // Get JSON data from a file via Ajax, using `dataSrc` to change\n		 *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)\n		 *   $('#example').dataTable( {\n		 *     \"ajax\": {\n		 *       \"url\": \"data.json\",\n		 *       \"dataSrc\": \"tableData\"\n		 *     }\n		 *   } );\n		 *\n		 * @example\n		 *   // Get JSON data from a file via Ajax, using `dataSrc` to read data\n		 *   // from a plain array rather than an array in an object\n		 *   $('#example').dataTable( {\n		 *     \"ajax\": {\n		 *       \"url\": \"data.json\",\n		 *       \"dataSrc\": \"\"\n		 *     }\n		 *   } );\n		 *\n		 * @example\n		 *   // Manipulate the data returned from the server - add a link to data\n		 *   // (note this can, should, be done using `render` for the column - this\n		 *   // is just a simple example of how the data can be manipulated).\n		 *   $('#example').dataTable( {\n		 *     \"ajax\": {\n		 *       \"url\": \"data.json\",\n		 *       \"dataSrc\": function ( json ) {\n		 *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {\n		 *           json[i][0] = '<a href=\"/message/'+json[i][0]+'>View message</a>';\n		 *         }\n		 *         return json;\n		 *       }\n		 *     }\n		 *   } );\n		 *\n		 * @example\n		 *   // Add data to the request\n		 *   $('#example').dataTable( {\n		 *     \"ajax\": {\n		 *       \"url\": \"data.json\",\n		 *       \"data\": function ( d ) {\n		 *         return {\n		 *           \"extra_search\": $('#extra').val()\n		 *         };\n		 *       }\n		 *     }\n		 *   } );\n		 *\n		 * @example\n		 *   // Send request as POST\n		 *   $('#example').dataTable( {\n		 *     \"ajax\": {\n		 *       \"url\": \"data.json\",\n		 *       \"type\": \"POST\"\n		 *     }\n		 *   } );\n		 *\n		 * @example\n		 *   // Get the data from localStorage (could interface with a form for\n		 *   // adding, editing and removing rows).\n		 *   $('#example').dataTable( {\n		 *     \"ajax\": function (data, callback, settings) {\n		 *       callback(\n		 *         JSON.parse( localStorage.getItem('dataTablesData') )\n		 *       );\n		 *     }\n		 *   } );\n		 */\n		\"ajax\": null,\n	\n	\n		/**\n		 * This parameter allows you to readily specify the entries in the length drop\n		 * down menu that DataTables shows when pagination is enabled. It can be\n		 * either a 1D array of options which will be used for both the displayed\n		 * option and the value, or a 2D array which will use the array in the first\n		 * position as the value, and the array in the second position as the\n		 * displayed options (useful for language strings such as 'All').\n		 *\n		 * Note that the `pageLength` property will be automatically set to the\n		 * first value given in this array, unless `pageLength` is also provided.\n		 *  @type array\n		 *  @default [ 10, 25, 50, 100 ]\n		 *\n		 *  @dtopt Option\n		 *  @name DataTable.defaults.lengthMenu\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"lengthMenu\": [[10, 25, 50, -1], [10, 25, 50, \"All\"]]\n		 *      } );\n		 *    } );\n		 */\n		\"aLengthMenu\": [ 10, 25, 50, 100 ],\n	\n	\n		/**\n		 * The `columns` option in the initialisation parameter allows you to define\n		 * details about the way individual columns behave. For a full list of\n		 * column options that can be set, please see\n		 * {@link DataTable.defaults.column}. Note that if you use `columns` to\n		 * define your columns, you must have an entry in the array for every single\n		 * column that you have in your table (these can be null if you don't which\n		 * to specify any options).\n		 *  @member\n		 *\n		 *  @name DataTable.defaults.column\n		 */\n		\"aoColumns\": null,\n	\n		/**\n		 * Very similar to `columns`, `columnDefs` allows you to target a specific\n		 * column, multiple columns, or all columns, using the `targets` property of\n		 * each object in the array. This allows great flexibility when creating\n		 * tables, as the `columnDefs` arrays can be of any length, targeting the\n		 * columns you specifically want. `columnDefs` may use any of the column\n		 * options available: {@link DataTable.defaults.column}, but it _must_\n		 * have `targets` defined in each object in the array. Values in the `targets`\n		 * array may be:\n		 *   <ul>\n		 *     <li>a string - class name will be matched on the TH for the column</li>\n		 *     <li>0 or a positive integer - column index counting from the left</li>\n		 *     <li>a negative integer - column index counting from the right</li>\n		 *     <li>the string \"_all\" - all columns (i.e. assign a default)</li>\n		 *   </ul>\n		 *  @member\n		 *\n		 *  @name DataTable.defaults.columnDefs\n		 */\n		\"aoColumnDefs\": null,\n	\n	\n		/**\n		 * Basically the same as `search`, this parameter defines the individual column\n		 * filtering state at initialisation time. The array must be of the same size\n		 * as the number of columns, and each element be an object with the parameters\n		 * `search` and `escapeRegex` (the latter is optional). 'null' is also\n		 * accepted and the default will be used.\n		 *  @type array\n		 *  @default []\n		 *\n		 *  @dtopt Option\n		 *  @name DataTable.defaults.searchCols\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"searchCols\": [\n		 *          null,\n		 *          { \"search\": \"My filter\" },\n		 *          null,\n		 *          { \"search\": \"^[0-9]\", \"escapeRegex\": false }\n		 *        ]\n		 *      } );\n		 *    } )\n		 */\n		\"aoSearchCols\": [],\n	\n	\n		/**\n		 * An array of CSS classes that should be applied to displayed rows. This\n		 * array may be of any length, and DataTables will apply each class\n		 * sequentially, looping when required.\n		 *  @type array\n		 *  @default null <i>Will take the values determined by the `oClasses.stripe*`\n		 *    options</i>\n		 *\n		 *  @dtopt Option\n		 *  @name DataTable.defaults.stripeClasses\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"stripeClasses\": [ 'strip1', 'strip2', 'strip3' ]\n		 *      } );\n		 *    } )\n		 */\n		\"asStripeClasses\": null,\n	\n	\n		/**\n		 * Enable or disable automatic column width calculation. This can be disabled\n		 * as an optimisation (it takes some time to calculate the widths) if the\n		 * tables widths are passed in using `columns`.\n		 *  @type boolean\n		 *  @default true\n		 *\n		 *  @dtopt Features\n		 *  @name DataTable.defaults.autoWidth\n		 *\n		 *  @example\n		 *    $(document).ready( function () {\n		 *      $('#example').dataTable( {\n		 *        \"autoWidth\": false\n		 *      } );\n		 *    } );\n		 */\n		\"bAutoWidth\": true,\n	\n	\n		/**\n		 * Deferred rendering can provide DataTables with a huge speed boost when you\n		 * are using an Ajax or JS data source for the table. This option, when set to\n		 * true, will cause DataTables to defer the creation of the table elements for\n		 * each row until they are needed for a draw - saving a significant amount of\n		 * time.\n		 *  @type boolean\n		 *  @default false\n		 *\n		 *  @dtopt Features\n		 *  @name DataTable.defaults.deferRender\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"ajax\": \"sources/arrays.txt\",\n		 *        \"deferRender\": true\n		 *      } );\n		 *    } );\n		 */\n		\"bDeferRender\": false,\n	\n	\n		/**\n		 * Replace a DataTable which matches the given selector and replace it with\n		 * one which has the properties of the new initialisation object passed. If no\n		 * table matches the selector, then the new DataTable will be constructed as\n		 * per normal.\n		 *  @type boolean\n		 *  @default false\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.destroy\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"srollY\": \"200px\",\n		 *        \"paginate\": false\n		 *      } );\n		 *\n		 *      // Some time later....\n		 *      $('#example').dataTable( {\n		 *        \"filter\": false,\n		 *        \"destroy\": true\n		 *      } );\n		 *    } );\n		 */\n		\"bDestroy\": false,\n	\n	\n		/**\n		 * Enable or disable filtering of data. Filtering in DataTables is \"smart\" in\n		 * that it allows the end user to input multiple words (space separated) and\n		 * will match a row containing those words, even if not in the order that was\n		 * specified (this allow matching across multiple columns). Note that if you\n		 * wish to use filtering in DataTables this must remain 'true' - to remove the\n		 * default filtering input box and retain filtering abilities, please use\n		 * {@link DataTable.defaults.dom}.\n		 *  @type boolean\n		 *  @default true\n		 *\n		 *  @dtopt Features\n		 *  @name DataTable.defaults.searching\n		 *\n		 *  @example\n		 *    $(document).ready( function () {\n		 *      $('#example').dataTable( {\n		 *        \"searching\": false\n		 *      } );\n		 *    } );\n		 */\n		\"bFilter\": true,\n	\n	\n		/**\n		 * Enable or disable the table information display. This shows information\n		 * about the data that is currently visible on the page, including information\n		 * about filtered data if that action is being performed.\n		 *  @type boolean\n		 *  @default true\n		 *\n		 *  @dtopt Features\n		 *  @name DataTable.defaults.info\n		 *\n		 *  @example\n		 *    $(document).ready( function () {\n		 *      $('#example').dataTable( {\n		 *        \"info\": false\n		 *      } );\n		 *    } );\n		 */\n		\"bInfo\": true,\n	\n	\n		/**\n		 * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some\n		 * slightly different and additional mark-up from what DataTables has\n		 * traditionally used).\n		 *  @type boolean\n		 *  @default false\n		 *\n		 *  @dtopt Features\n		 *  @name DataTable.defaults.jQueryUI\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"jQueryUI\": true\n		 *      } );\n		 *    } );\n		 */\n		\"bJQueryUI\": false,\n	\n	\n		/**\n		 * Allows the end user to select the size of a formatted page from a select\n		 * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).\n		 *  @type boolean\n		 *  @default true\n		 *\n		 *  @dtopt Features\n		 *  @name DataTable.defaults.lengthChange\n		 *\n		 *  @example\n		 *    $(document).ready( function () {\n		 *      $('#example').dataTable( {\n		 *        \"lengthChange\": false\n		 *      } );\n		 *    } );\n		 */\n		\"bLengthChange\": true,\n	\n	\n		/**\n		 * Enable or disable pagination.\n		 *  @type boolean\n		 *  @default true\n		 *\n		 *  @dtopt Features\n		 *  @name DataTable.defaults.paging\n		 *\n		 *  @example\n		 *    $(document).ready( function () {\n		 *      $('#example').dataTable( {\n		 *        \"paging\": false\n		 *      } );\n		 *    } );\n		 */\n		\"bPaginate\": true,\n	\n	\n		/**\n		 * Enable or disable the display of a 'processing' indicator when the table is\n		 * being processed (e.g. a sort). This is particularly useful for tables with\n		 * large amounts of data where it can take a noticeable amount of time to sort\n		 * the entries.\n		 *  @type boolean\n		 *  @default false\n		 *\n		 *  @dtopt Features\n		 *  @name DataTable.defaults.processing\n		 *\n		 *  @example\n		 *    $(document).ready( function () {\n		 *      $('#example').dataTable( {\n		 *        \"processing\": true\n		 *      } );\n		 *    } );\n		 */\n		\"bProcessing\": false,\n	\n	\n		/**\n		 * Retrieve the DataTables object for the given selector. Note that if the\n		 * table has already been initialised, this parameter will cause DataTables\n		 * to simply return the object that has already been set up - it will not take\n		 * account of any changes you might have made to the initialisation object\n		 * passed to DataTables (setting this parameter to true is an acknowledgement\n		 * that you understand this). `destroy` can be used to reinitialise a table if\n		 * you need.\n		 *  @type boolean\n		 *  @default false\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.retrieve\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      initTable();\n		 *      tableActions();\n		 *    } );\n		 *\n		 *    function initTable ()\n		 *    {\n		 *      return $('#example').dataTable( {\n		 *        \"scrollY\": \"200px\",\n		 *        \"paginate\": false,\n		 *        \"retrieve\": true\n		 *      } );\n		 *    }\n		 *\n		 *    function tableActions ()\n		 *    {\n		 *      var table = initTable();\n		 *      // perform API operations with oTable\n		 *    }\n		 */\n		\"bRetrieve\": false,\n	\n	\n		/**\n		 * When vertical (y) scrolling is enabled, DataTables will force the height of\n		 * the table's viewport to the given height at all times (useful for layout).\n		 * However, this can look odd when filtering data down to a small data set,\n		 * and the footer is left \"floating\" further down. This parameter (when\n		 * enabled) will cause DataTables to collapse the table's viewport down when\n		 * the result set will fit within the given Y height.\n		 *  @type boolean\n		 *  @default false\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.scrollCollapse\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"scrollY\": \"200\",\n		 *        \"scrollCollapse\": true\n		 *      } );\n		 *    } );\n		 */\n		\"bScrollCollapse\": false,\n	\n	\n		/**\n		 * Configure DataTables to use server-side processing. Note that the\n		 * `ajax` parameter must also be given in order to give DataTables a\n		 * source to obtain the required data for each draw.\n		 *  @type boolean\n		 *  @default false\n		 *\n		 *  @dtopt Features\n		 *  @dtopt Server-side\n		 *  @name DataTable.defaults.serverSide\n		 *\n		 *  @example\n		 *    $(document).ready( function () {\n		 *      $('#example').dataTable( {\n		 *        \"serverSide\": true,\n		 *        \"ajax\": \"xhr.php\"\n		 *      } );\n		 *    } );\n		 */\n		\"bServerSide\": false,\n	\n	\n		/**\n		 * Enable or disable sorting of columns. Sorting of individual columns can be\n		 * disabled by the `sortable` option for each column.\n		 *  @type boolean\n		 *  @default true\n		 *\n		 *  @dtopt Features\n		 *  @name DataTable.defaults.ordering\n		 *\n		 *  @example\n		 *    $(document).ready( function () {\n		 *      $('#example').dataTable( {\n		 *        \"ordering\": false\n		 *      } );\n		 *    } );\n		 */\n		\"bSort\": true,\n	\n	\n		/**\n		 * Enable or display DataTables' ability to sort multiple columns at the\n		 * same time (activated by shift-click by the user).\n		 *  @type boolean\n		 *  @default true\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.orderMulti\n		 *\n		 *  @example\n		 *    // Disable multiple column sorting ability\n		 *    $(document).ready( function () {\n		 *      $('#example').dataTable( {\n		 *        \"orderMulti\": false\n		 *      } );\n		 *    } );\n		 */\n		\"bSortMulti\": true,\n	\n	\n		/**\n		 * Allows control over whether DataTables should use the top (true) unique\n		 * cell that is found for a single column, or the bottom (false - default).\n		 * This is useful when using complex headers.\n		 *  @type boolean\n		 *  @default false\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.orderCellsTop\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"orderCellsTop\": true\n		 *      } );\n		 *    } );\n		 */\n		\"bSortCellsTop\": false,\n	\n	\n		/**\n		 * Enable or disable the addition of the classes `sorting\\_1`, `sorting\\_2` and\n		 * `sorting\\_3` to the columns which are currently being sorted on. This is\n		 * presented as a feature switch as it can increase processing time (while\n		 * classes are removed and added) so for large data sets you might want to\n		 * turn this off.\n		 *  @type boolean\n		 *  @default true\n		 *\n		 *  @dtopt Features\n		 *  @name DataTable.defaults.orderClasses\n		 *\n		 *  @example\n		 *    $(document).ready( function () {\n		 *      $('#example').dataTable( {\n		 *        \"orderClasses\": false\n		 *      } );\n		 *    } );\n		 */\n		\"bSortClasses\": true,\n	\n	\n		/**\n		 * Enable or disable state saving. When enabled HTML5 `localStorage` will be\n		 * used to save table display information such as pagination information,\n		 * display length, filtering and sorting. As such when the end user reloads\n		 * the page the display display will match what thy had previously set up.\n		 *\n		 * Due to the use of `localStorage` the default state saving is not supported\n		 * in IE6 or 7. If state saving is required in those browsers, use\n		 * `stateSaveCallback` to provide a storage solution such as cookies.\n		 *  @type boolean\n		 *  @default false\n		 *\n		 *  @dtopt Features\n		 *  @name DataTable.defaults.stateSave\n		 *\n		 *  @example\n		 *    $(document).ready( function () {\n		 *      $('#example').dataTable( {\n		 *        \"stateSave\": true\n		 *      } );\n		 *    } );\n		 */\n		\"bStateSave\": false,\n	\n	\n		/**\n		 * This function is called when a TR element is created (and all TD child\n		 * elements have been inserted), or registered if using a DOM source, allowing\n		 * manipulation of the TR element (adding classes etc).\n		 *  @type function\n		 *  @param {node} row \"TR\" element for the current row\n		 *  @param {array} data Raw data array for this row\n		 *  @param {int} dataIndex The index of this row in the internal aoData array\n		 *\n		 *  @dtopt Callbacks\n		 *  @name DataTable.defaults.createdRow\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"createdRow\": function( row, data, dataIndex ) {\n		 *          // Bold the grade for all 'A' grade browsers\n		 *          if ( data[4] == \"A\" )\n		 *          {\n		 *            $('td:eq(4)', row).html( '<b>A</b>' );\n		 *          }\n		 *        }\n		 *      } );\n		 *    } );\n		 */\n		\"fnCreatedRow\": null,\n	\n	\n		/**\n		 * This function is called on every 'draw' event, and allows you to\n		 * dynamically modify any aspect you want about the created DOM.\n		 *  @type function\n		 *  @param {object} settings DataTables settings object\n		 *\n		 *  @dtopt Callbacks\n		 *  @name DataTable.defaults.drawCallback\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"drawCallback\": function( settings ) {\n		 *          alert( 'DataTables has redrawn the table' );\n		 *        }\n		 *      } );\n		 *    } );\n		 */\n		\"fnDrawCallback\": null,\n	\n	\n		/**\n		 * Identical to fnHeaderCallback() but for the table footer this function\n		 * allows you to modify the table footer on every 'draw' event.\n		 *  @type function\n		 *  @param {node} foot \"TR\" element for the footer\n		 *  @param {array} data Full table data (as derived from the original HTML)\n		 *  @param {int} start Index for the current display starting point in the\n		 *    display array\n		 *  @param {int} end Index for the current display ending point in the\n		 *    display array\n		 *  @param {array int} display Index array to translate the visual position\n		 *    to the full data array\n		 *\n		 *  @dtopt Callbacks\n		 *  @name DataTable.defaults.footerCallback\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"footerCallback\": function( tfoot, data, start, end, display ) {\n		 *          tfoot.getElementsByTagName('th')[0].innerHTML = \"Starting index is \"+start;\n		 *        }\n		 *      } );\n		 *    } )\n		 */\n		\"fnFooterCallback\": null,\n	\n	\n		/**\n		 * When rendering large numbers in the information element for the table\n		 * (i.e. \"Showing 1 to 10 of 57 entries\") DataTables will render large numbers\n		 * to have a comma separator for the 'thousands' units (e.g. 1 million is\n		 * rendered as \"1,000,000\") to help readability for the end user. This\n		 * function will override the default method DataTables uses.\n		 *  @type function\n		 *  @member\n		 *  @param {int} toFormat number to be formatted\n		 *  @returns {string} formatted string for DataTables to show the number\n		 *\n		 *  @dtopt Callbacks\n		 *  @name DataTable.defaults.formatNumber\n		 *\n		 *  @example\n		 *    // Format a number using a single quote for the separator (note that\n		 *    // this can also be done with the language.thousands option)\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"formatNumber\": function ( toFormat ) {\n		 *          return toFormat.toString().replace(\n		 *            /\\B(?=(\\d{3})+(?!\\d))/g, \"'\"\n		 *          );\n		 *        };\n		 *      } );\n		 *    } );\n		 */\n		\"fnFormatNumber\": function ( toFormat ) {\n			return toFormat.toString().replace(\n				/\\B(?=(\\d{3})+(?!\\d))/g,\n				this.oLanguage.sThousands\n			);\n		},\n	\n	\n		/**\n		 * This function is called on every 'draw' event, and allows you to\n		 * dynamically modify the header row. This can be used to calculate and\n		 * display useful information about the table.\n		 *  @type function\n		 *  @param {node} head \"TR\" element for the header\n		 *  @param {array} data Full table data (as derived from the original HTML)\n		 *  @param {int} start Index for the current display starting point in the\n		 *    display array\n		 *  @param {int} end Index for the current display ending point in the\n		 *    display array\n		 *  @param {array int} display Index array to translate the visual position\n		 *    to the full data array\n		 *\n		 *  @dtopt Callbacks\n		 *  @name DataTable.defaults.headerCallback\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"fheaderCallback\": function( head, data, start, end, display ) {\n		 *          head.getElementsByTagName('th')[0].innerHTML = \"Displaying \"+(end-start)+\" records\";\n		 *        }\n		 *      } );\n		 *    } )\n		 */\n		\"fnHeaderCallback\": null,\n	\n	\n		/**\n		 * The information element can be used to convey information about the current\n		 * state of the table. Although the internationalisation options presented by\n		 * DataTables are quite capable of dealing with most customisations, there may\n		 * be times where you wish to customise the string further. This callback\n		 * allows you to do exactly that.\n		 *  @type function\n		 *  @param {object} oSettings DataTables settings object\n		 *  @param {int} start Starting position in data for the draw\n		 *  @param {int} end End position in data for the draw\n		 *  @param {int} max Total number of rows in the table (regardless of\n		 *    filtering)\n		 *  @param {int} total Total number of rows in the data set, after filtering\n		 *  @param {string} pre The string that DataTables has formatted using it's\n		 *    own rules\n		 *  @returns {string} The string to be displayed in the information element.\n		 *\n		 *  @dtopt Callbacks\n		 *  @name DataTable.defaults.infoCallback\n		 *\n		 *  @example\n		 *    $('#example').dataTable( {\n		 *      \"infoCallback\": function( settings, start, end, max, total, pre ) {\n		 *        return start +\" to \"+ end;\n		 *      }\n		 *    } );\n		 */\n		\"fnInfoCallback\": null,\n	\n	\n		/**\n		 * Called when the table has been initialised. Normally DataTables will\n		 * initialise sequentially and there will be no need for this function,\n		 * however, this does not hold true when using external language information\n		 * since that is obtained using an async XHR call.\n		 *  @type function\n		 *  @param {object} settings DataTables settings object\n		 *  @param {object} json The JSON object request from the server - only\n		 *    present if client-side Ajax sourced data is used\n		 *\n		 *  @dtopt Callbacks\n		 *  @name DataTable.defaults.initComplete\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"initComplete\": function(settings, json) {\n		 *          alert( 'DataTables has finished its initialisation.' );\n		 *        }\n		 *      } );\n		 *    } )\n		 */\n		\"fnInitComplete\": null,\n	\n	\n		/**\n		 * Called at the very start of each table draw and can be used to cancel the\n		 * draw by returning false, any other return (including undefined) results in\n		 * the full draw occurring).\n		 *  @type function\n		 *  @param {object} settings DataTables settings object\n		 *  @returns {boolean} False will cancel the draw, anything else (including no\n		 *    return) will allow it to complete.\n		 *\n		 *  @dtopt Callbacks\n		 *  @name DataTable.defaults.preDrawCallback\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"preDrawCallback\": function( settings ) {\n		 *          if ( $('#test').val() == 1 ) {\n		 *            return false;\n		 *          }\n		 *        }\n		 *      } );\n		 *    } );\n		 */\n		\"fnPreDrawCallback\": null,\n	\n	\n		/**\n		 * This function allows you to 'post process' each row after it have been\n		 * generated for each table draw, but before it is rendered on screen. This\n		 * function might be used for setting the row class name etc.\n		 *  @type function\n		 *  @param {node} row \"TR\" element for the current row\n		 *  @param {array} data Raw data array for this row\n		 *  @param {int} displayIndex The display index for the current table draw\n		 *  @param {int} displayIndexFull The index of the data in the full list of\n		 *    rows (after filtering)\n		 *\n		 *  @dtopt Callbacks\n		 *  @name DataTable.defaults.rowCallback\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"rowCallback\": function( row, data, displayIndex, displayIndexFull ) {\n		 *          // Bold the grade for all 'A' grade browsers\n		 *          if ( data[4] == \"A\" ) {\n		 *            $('td:eq(4)', row).html( '<b>A</b>' );\n		 *          }\n		 *        }\n		 *      } );\n		 *    } );\n		 */\n		\"fnRowCallback\": null,\n	\n	\n		/**\n		 * __Deprecated__ The functionality provided by this parameter has now been\n		 * superseded by that provided through `ajax`, which should be used instead.\n		 *\n		 * This parameter allows you to override the default function which obtains\n		 * the data from the server so something more suitable for your application.\n		 * For example you could use POST data, or pull information from a Gears or\n		 * AIR database.\n		 *  @type function\n		 *  @member\n		 *  @param {string} source HTTP source to obtain the data from (`ajax`)\n		 *  @param {array} data A key/value pair object containing the data to send\n		 *    to the server\n		 *  @param {function} callback to be called on completion of the data get\n		 *    process that will draw the data on the page.\n		 *  @param {object} settings DataTables settings object\n		 *\n		 *  @dtopt Callbacks\n		 *  @dtopt Server-side\n		 *  @name DataTable.defaults.serverData\n		 *\n		 *  @deprecated 1.10. Please use `ajax` for this functionality now.\n		 */\n		\"fnServerData\": null,\n	\n	\n		/**\n		 * __Deprecated__ The functionality provided by this parameter has now been\n		 * superseded by that provided through `ajax`, which should be used instead.\n		 *\n		 *  It is often useful to send extra data to the server when making an Ajax\n		 * request - for example custom filtering information, and this callback\n		 * function makes it trivial to send extra information to the server. The\n		 * passed in parameter is the data set that has been constructed by\n		 * DataTables, and you can add to this or modify it as you require.\n		 *  @type function\n		 *  @param {array} data Data array (array of objects which are name/value\n		 *    pairs) that has been constructed by DataTables and will be sent to the\n		 *    server. In the case of Ajax sourced data with server-side processing\n		 *    this will be an empty array, for server-side processing there will be a\n		 *    significant number of parameters!\n		 *  @returns {undefined} Ensure that you modify the data array passed in,\n		 *    as this is passed by reference.\n		 *\n		 *  @dtopt Callbacks\n		 *  @dtopt Server-side\n		 *  @name DataTable.defaults.serverParams\n		 *\n		 *  @deprecated 1.10. Please use `ajax` for this functionality now.\n		 */\n		\"fnServerParams\": null,\n	\n	\n		/**\n		 * Load the table state. With this function you can define from where, and how, the\n		 * state of a table is loaded. By default DataTables will load from `localStorage`\n		 * but you might wish to use a server-side database or cookies.\n		 *  @type function\n		 *  @member\n		 *  @param {object} settings DataTables settings object\n		 *  @return {object} The DataTables state object to be loaded\n		 *\n		 *  @dtopt Callbacks\n		 *  @name DataTable.defaults.stateLoadCallback\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"stateSave\": true,\n		 *        \"stateLoadCallback\": function (settings) {\n		 *          var o;\n		 *\n		 *          // Send an Ajax request to the server to get the data. Note that\n		 *          // this is a synchronous request.\n		 *          $.ajax( {\n		 *            \"url\": \"/state_load\",\n		 *            \"async\": false,\n		 *            \"dataType\": \"json\",\n		 *            \"success\": function (json) {\n		 *              o = json;\n		 *            }\n		 *          } );\n		 *\n		 *          return o;\n		 *        }\n		 *      } );\n		 *    } );\n		 */\n		\"fnStateLoadCallback\": function ( settings ) {\n			try {\n				return JSON.parse(\n					(settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(\n						'DataTables_'+settings.sInstance+'_'+location.pathname\n					)\n				);\n			} catch (e) {}\n		},\n	\n	\n		/**\n		 * Callback which allows modification of the saved state prior to loading that state.\n		 * This callback is called when the table is loading state from the stored data, but\n		 * prior to the settings object being modified by the saved state. Note that for\n		 * plug-in authors, you should use the `stateLoadParams` event to load parameters for\n		 * a plug-in.\n		 *  @type function\n		 *  @param {object} settings DataTables settings object\n		 *  @param {object} data The state object that is to be loaded\n		 *\n		 *  @dtopt Callbacks\n		 *  @name DataTable.defaults.stateLoadParams\n		 *\n		 *  @example\n		 *    // Remove a saved filter, so filtering is never loaded\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"stateSave\": true,\n		 *        \"stateLoadParams\": function (settings, data) {\n		 *          data.oSearch.sSearch = \"\";\n		 *        }\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Disallow state loading by returning false\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"stateSave\": true,\n		 *        \"stateLoadParams\": function (settings, data) {\n		 *          return false;\n		 *        }\n		 *      } );\n		 *    } );\n		 */\n		\"fnStateLoadParams\": null,\n	\n	\n		/**\n		 * Callback that is called when the state has been loaded from the state saving method\n		 * and the DataTables settings object has been modified as a result of the loaded state.\n		 *  @type function\n		 *  @param {object} settings DataTables settings object\n		 *  @param {object} data The state object that was loaded\n		 *\n		 *  @dtopt Callbacks\n		 *  @name DataTable.defaults.stateLoaded\n		 *\n		 *  @example\n		 *    // Show an alert with the filtering value that was saved\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"stateSave\": true,\n		 *        \"stateLoaded\": function (settings, data) {\n		 *          alert( 'Saved filter was: '+data.oSearch.sSearch );\n		 *        }\n		 *      } );\n		 *    } );\n		 */\n		\"fnStateLoaded\": null,\n	\n	\n		/**\n		 * Save the table state. This function allows you to define where and how the state\n		 * information for the table is stored By default DataTables will use `localStorage`\n		 * but you might wish to use a server-side database or cookies.\n		 *  @type function\n		 *  @member\n		 *  @param {object} settings DataTables settings object\n		 *  @param {object} data The state object to be saved\n		 *\n		 *  @dtopt Callbacks\n		 *  @name DataTable.defaults.stateSaveCallback\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"stateSave\": true,\n		 *        \"stateSaveCallback\": function (settings, data) {\n		 *          // Send an Ajax request to the server with the state object\n		 *          $.ajax( {\n		 *            \"url\": \"/state_save\",\n		 *            \"data\": data,\n		 *            \"dataType\": \"json\",\n		 *            \"method\": \"POST\"\n		 *            \"success\": function () {}\n		 *          } );\n		 *        }\n		 *      } );\n		 *    } );\n		 */\n		\"fnStateSaveCallback\": function ( settings, data ) {\n			try {\n				(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(\n					'DataTables_'+settings.sInstance+'_'+location.pathname,\n					JSON.stringify( data )\n				);\n			} catch (e) {}\n		},\n	\n	\n		/**\n		 * Callback which allows modification of the state to be saved. Called when the table\n		 * has changed state a new state save is required. This method allows modification of\n		 * the state saving object prior to actually doing the save, including addition or\n		 * other state properties or modification. Note that for plug-in authors, you should\n		 * use the `stateSaveParams` event to save parameters for a plug-in.\n		 *  @type function\n		 *  @param {object} settings DataTables settings object\n		 *  @param {object} data The state object to be saved\n		 *\n		 *  @dtopt Callbacks\n		 *  @name DataTable.defaults.stateSaveParams\n		 *\n		 *  @example\n		 *    // Remove a saved filter, so filtering is never saved\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"stateSave\": true,\n		 *        \"stateSaveParams\": function (settings, data) {\n		 *          data.oSearch.sSearch = \"\";\n		 *        }\n		 *      } );\n		 *    } );\n		 */\n		\"fnStateSaveParams\": null,\n	\n	\n		/**\n		 * Duration for which the saved state information is considered valid. After this period\n		 * has elapsed the state will be returned to the default.\n		 * Value is given in seconds.\n		 *  @type int\n		 *  @default 7200 <i>(2 hours)</i>\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.stateDuration\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"stateDuration\": 60*60*24; // 1 day\n		 *      } );\n		 *    } )\n		 */\n		\"iStateDuration\": 7200,\n	\n	\n		/**\n		 * When enabled DataTables will not make a request to the server for the first\n		 * page draw - rather it will use the data already on the page (no sorting etc\n		 * will be applied to it), thus saving on an XHR at load time. `deferLoading`\n		 * is used to indicate that deferred loading is required, but it is also used\n		 * to tell DataTables how many records there are in the full table (allowing\n		 * the information element and pagination to be displayed correctly). In the case\n		 * where a filtering is applied to the table on initial load, this can be\n		 * indicated by giving the parameter as an array, where the first element is\n		 * the number of records available after filtering and the second element is the\n		 * number of records without filtering (allowing the table information element\n		 * to be shown correctly).\n		 *  @type int | array\n		 *  @default null\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.deferLoading\n		 *\n		 *  @example\n		 *    // 57 records available in the table, no filtering applied\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"serverSide\": true,\n		 *        \"ajax\": \"scripts/server_processing.php\",\n		 *        \"deferLoading\": 57\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // 57 records after filtering, 100 without filtering (an initial filter applied)\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"serverSide\": true,\n		 *        \"ajax\": \"scripts/server_processing.php\",\n		 *        \"deferLoading\": [ 57, 100 ],\n		 *        \"search\": {\n		 *          \"search\": \"my_filter\"\n		 *        }\n		 *      } );\n		 *    } );\n		 */\n		\"iDeferLoading\": null,\n	\n	\n		/**\n		 * Number of rows to display on a single page when using pagination. If\n		 * feature enabled (`lengthChange`) then the end user will be able to override\n		 * this to a custom setting using a pop-up menu.\n		 *  @type int\n		 *  @default 10\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.pageLength\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"pageLength\": 50\n		 *      } );\n		 *    } )\n		 */\n		\"iDisplayLength\": 10,\n	\n	\n		/**\n		 * Define the starting point for data display when using DataTables with\n		 * pagination. Note that this parameter is the number of records, rather than\n		 * the page number, so if you have 10 records per page and want to start on\n		 * the third page, it should be \"20\".\n		 *  @type int\n		 *  @default 0\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.displayStart\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"displayStart\": 20\n		 *      } );\n		 *    } )\n		 */\n		\"iDisplayStart\": 0,\n	\n	\n		/**\n		 * By default DataTables allows keyboard navigation of the table (sorting, paging,\n		 * and filtering) by adding a `tabindex` attribute to the required elements. This\n		 * allows you to tab through the controls and press the enter key to activate them.\n		 * The tabindex is default 0, meaning that the tab follows the flow of the document.\n		 * You can overrule this using this parameter if you wish. Use a value of -1 to\n		 * disable built-in keyboard navigation.\n		 *  @type int\n		 *  @default 0\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.tabIndex\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"tabIndex\": 1\n		 *      } );\n		 *    } );\n		 */\n		\"iTabIndex\": 0,\n	\n	\n		/**\n		 * Classes that DataTables assigns to the various components and features\n		 * that it adds to the HTML table. This allows classes to be configured\n		 * during initialisation in addition to through the static\n		 * {@link DataTable.ext.oStdClasses} object).\n		 *  @namespace\n		 *  @name DataTable.defaults.classes\n		 */\n		\"oClasses\": {},\n	\n	\n		/**\n		 * All strings that DataTables uses in the user interface that it creates\n		 * are defined in this object, allowing you to modified them individually or\n		 * completely replace them all as required.\n		 *  @namespace\n		 *  @name DataTable.defaults.language\n		 */\n		\"oLanguage\": {\n			/**\n			 * Strings that are used for WAI-ARIA labels and controls only (these are not\n			 * actually visible on the page, but will be read by screenreaders, and thus\n			 * must be internationalised as well).\n			 *  @namespace\n			 *  @name DataTable.defaults.language.aria\n			 */\n			\"oAria\": {\n				/**\n				 * ARIA label that is added to the table headers when the column may be\n				 * sorted ascending by activing the column (click or return when focused).\n				 * Note that the column header is prefixed to this string.\n				 *  @type string\n				 *  @default : activate to sort column ascending\n				 *\n				 *  @dtopt Language\n				 *  @name DataTable.defaults.language.aria.sortAscending\n				 *\n				 *  @example\n				 *    $(document).ready( function() {\n				 *      $('#example').dataTable( {\n				 *        \"language\": {\n				 *          \"aria\": {\n				 *            \"sortAscending\": \" - click/return to sort ascending\"\n				 *          }\n				 *        }\n				 *      } );\n				 *    } );\n				 */\n				\"sSortAscending\": \": activate to sort column ascending\",\n	\n				/**\n				 * ARIA label that is added to the table headers when the column may be\n				 * sorted descending by activing the column (click or return when focused).\n				 * Note that the column header is prefixed to this string.\n				 *  @type string\n				 *  @default : activate to sort column ascending\n				 *\n				 *  @dtopt Language\n				 *  @name DataTable.defaults.language.aria.sortDescending\n				 *\n				 *  @example\n				 *    $(document).ready( function() {\n				 *      $('#example').dataTable( {\n				 *        \"language\": {\n				 *          \"aria\": {\n				 *            \"sortDescending\": \" - click/return to sort descending\"\n				 *          }\n				 *        }\n				 *      } );\n				 *    } );\n				 */\n				\"sSortDescending\": \": activate to sort column descending\"\n			},\n	\n			/**\n			 * Pagination string used by DataTables for the built-in pagination\n			 * control types.\n			 *  @namespace\n			 *  @name DataTable.defaults.language.paginate\n			 */\n			\"oPaginate\": {\n				/**\n				 * Text to use when using the 'full_numbers' type of pagination for the\n				 * button to take the user to the first page.\n				 *  @type string\n				 *  @default First\n				 *\n				 *  @dtopt Language\n				 *  @name DataTable.defaults.language.paginate.first\n				 *\n				 *  @example\n				 *    $(document).ready( function() {\n				 *      $('#example').dataTable( {\n				 *        \"language\": {\n				 *          \"paginate\": {\n				 *            \"first\": \"First page\"\n				 *          }\n				 *        }\n				 *      } );\n				 *    } );\n				 */\n				\"sFirst\": \"First\",\n	\n	\n				/**\n				 * Text to use when using the 'full_numbers' type of pagination for the\n				 * button to take the user to the last page.\n				 *  @type string\n				 *  @default Last\n				 *\n				 *  @dtopt Language\n				 *  @name DataTable.defaults.language.paginate.last\n				 *\n				 *  @example\n				 *    $(document).ready( function() {\n				 *      $('#example').dataTable( {\n				 *        \"language\": {\n				 *          \"paginate\": {\n				 *            \"last\": \"Last page\"\n				 *          }\n				 *        }\n				 *      } );\n				 *    } );\n				 */\n				\"sLast\": \"Last\",\n	\n	\n				/**\n				 * Text to use for the 'next' pagination button (to take the user to the\n				 * next page).\n				 *  @type string\n				 *  @default Next\n				 *\n				 *  @dtopt Language\n				 *  @name DataTable.defaults.language.paginate.next\n				 *\n				 *  @example\n				 *    $(document).ready( function() {\n				 *      $('#example').dataTable( {\n				 *        \"language\": {\n				 *          \"paginate\": {\n				 *            \"next\": \"Next page\"\n				 *          }\n				 *        }\n				 *      } );\n				 *    } );\n				 */\n				\"sNext\": \"Next\",\n	\n	\n				/**\n				 * Text to use for the 'previous' pagination button (to take the user to\n				 * the previous page).\n				 *  @type string\n				 *  @default Previous\n				 *\n				 *  @dtopt Language\n				 *  @name DataTable.defaults.language.paginate.previous\n				 *\n				 *  @example\n				 *    $(document).ready( function() {\n				 *      $('#example').dataTable( {\n				 *        \"language\": {\n				 *          \"paginate\": {\n				 *            \"previous\": \"Previous page\"\n				 *          }\n				 *        }\n				 *      } );\n				 *    } );\n				 */\n				\"sPrevious\": \"Previous\"\n			},\n	\n			/**\n			 * This string is shown in preference to `zeroRecords` when the table is\n			 * empty of data (regardless of filtering). Note that this is an optional\n			 * parameter - if it is not given, the value of `zeroRecords` will be used\n			 * instead (either the default or given value).\n			 *  @type string\n			 *  @default No data available in table\n			 *\n			 *  @dtopt Language\n			 *  @name DataTable.defaults.language.emptyTable\n			 *\n			 *  @example\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"emptyTable\": \"No data available in table\"\n			 *        }\n			 *      } );\n			 *    } );\n			 */\n			\"sEmptyTable\": \"No data available in table\",\n	\n	\n			/**\n			 * This string gives information to the end user about the information\n			 * that is current on display on the page. The following tokens can be\n			 * used in the string and will be dynamically replaced as the table\n			 * display updates. This tokens can be placed anywhere in the string, or\n			 * removed as needed by the language requires:\n			 *\n			 * * `\\_START\\_` - Display index of the first record on the current page\n			 * * `\\_END\\_` - Display index of the last record on the current page\n			 * * `\\_TOTAL\\_` - Number of records in the table after filtering\n			 * * `\\_MAX\\_` - Number of records in the table without filtering\n			 * * `\\_PAGE\\_` - Current page number\n			 * * `\\_PAGES\\_` - Total number of pages of data in the table\n			 *\n			 *  @type string\n			 *  @default Showing _START_ to _END_ of _TOTAL_ entries\n			 *\n			 *  @dtopt Language\n			 *  @name DataTable.defaults.language.info\n			 *\n			 *  @example\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"info\": \"Showing page _PAGE_ of _PAGES_\"\n			 *        }\n			 *      } );\n			 *    } );\n			 */\n			\"sInfo\": \"Showing _START_ to _END_ of _TOTAL_ entries\",\n	\n	\n			/**\n			 * Display information string for when the table is empty. Typically the\n			 * format of this string should match `info`.\n			 *  @type string\n			 *  @default Showing 0 to 0 of 0 entries\n			 *\n			 *  @dtopt Language\n			 *  @name DataTable.defaults.language.infoEmpty\n			 *\n			 *  @example\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"infoEmpty\": \"No entries to show\"\n			 *        }\n			 *      } );\n			 *    } );\n			 */\n			\"sInfoEmpty\": \"Showing 0 to 0 of 0 entries\",\n	\n	\n			/**\n			 * When a user filters the information in a table, this string is appended\n			 * to the information (`info`) to give an idea of how strong the filtering\n			 * is. The variable _MAX_ is dynamically updated.\n			 *  @type string\n			 *  @default (filtered from _MAX_ total entries)\n			 *\n			 *  @dtopt Language\n			 *  @name DataTable.defaults.language.infoFiltered\n			 *\n			 *  @example\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"infoFiltered\": \" - filtering from _MAX_ records\"\n			 *        }\n			 *      } );\n			 *    } );\n			 */\n			\"sInfoFiltered\": \"(filtered from _MAX_ total entries)\",\n	\n	\n			/**\n			 * If can be useful to append extra information to the info string at times,\n			 * and this variable does exactly that. This information will be appended to\n			 * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are\n			 * being used) at all times.\n			 *  @type string\n			 *  @default <i>Empty string</i>\n			 *\n			 *  @dtopt Language\n			 *  @name DataTable.defaults.language.infoPostFix\n			 *\n			 *  @example\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"infoPostFix\": \"All records shown are derived from real information.\"\n			 *        }\n			 *      } );\n			 *    } );\n			 */\n			\"sInfoPostFix\": \"\",\n	\n	\n			/**\n			 * This decimal place operator is a little different from the other\n			 * language options since DataTables doesn't output floating point\n			 * numbers, so it won't ever use this for display of a number. Rather,\n			 * what this parameter does is modify the sort methods of the table so\n			 * that numbers which are in a format which has a character other than\n			 * a period (`.`) as a decimal place will be sorted numerically.\n			 *\n			 * Note that numbers with different decimal places cannot be shown in\n			 * the same table and still be sortable, the table must be consistent.\n			 * However, multiple different tables on the page can use different\n			 * decimal place characters.\n			 *  @type string\n			 *  @default \n			 *\n			 *  @dtopt Language\n			 *  @name DataTable.defaults.language.decimal\n			 *\n			 *  @example\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"decimal\": \",\"\n			 *          \"thousands\": \".\"\n			 *        }\n			 *      } );\n			 *    } );\n			 */\n			\"sDecimal\": \"\",\n	\n	\n			/**\n			 * DataTables has a build in number formatter (`formatNumber`) which is\n			 * used to format large numbers that are used in the table information.\n			 * By default a comma is used, but this can be trivially changed to any\n			 * character you wish with this parameter.\n			 *  @type string\n			 *  @default ,\n			 *\n			 *  @dtopt Language\n			 *  @name DataTable.defaults.language.thousands\n			 *\n			 *  @example\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"thousands\": \"'\"\n			 *        }\n			 *      } );\n			 *    } );\n			 */\n			\"sThousands\": \",\",\n	\n	\n			/**\n			 * Detail the action that will be taken when the drop down menu for the\n			 * pagination length option is changed. The '_MENU_' variable is replaced\n			 * with a default select list of 10, 25, 50 and 100, and can be replaced\n			 * with a custom select box if required.\n			 *  @type string\n			 *  @default Show _MENU_ entries\n			 *\n			 *  @dtopt Language\n			 *  @name DataTable.defaults.language.lengthMenu\n			 *\n			 *  @example\n			 *    // Language change only\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"lengthMenu\": \"Display _MENU_ records\"\n			 *        }\n			 *      } );\n			 *    } );\n			 *\n			 *  @example\n			 *    // Language and options change\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"lengthMenu\": 'Display <select>'+\n			 *            '<option value=\"10\">10</option>'+\n			 *            '<option value=\"20\">20</option>'+\n			 *            '<option value=\"30\">30</option>'+\n			 *            '<option value=\"40\">40</option>'+\n			 *            '<option value=\"50\">50</option>'+\n			 *            '<option value=\"-1\">All</option>'+\n			 *            '</select> records'\n			 *        }\n			 *      } );\n			 *    } );\n			 */\n			\"sLengthMenu\": \"Show _MENU_ entries\",\n	\n	\n			/**\n			 * When using Ajax sourced data and during the first draw when DataTables is\n			 * gathering the data, this message is shown in an empty row in the table to\n			 * indicate to the end user the the data is being loaded. Note that this\n			 * parameter is not used when loading data by server-side processing, just\n			 * Ajax sourced data with client-side processing.\n			 *  @type string\n			 *  @default Loading...\n			 *\n			 *  @dtopt Language\n			 *  @name DataTable.defaults.language.loadingRecords\n			 *\n			 *  @example\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"loadingRecords\": \"Please wait - loading...\"\n			 *        }\n			 *      } );\n			 *    } );\n			 */\n			\"sLoadingRecords\": \"Loading...\",\n	\n	\n			/**\n			 * Text which is displayed when the table is processing a user action\n			 * (usually a sort command or similar).\n			 *  @type string\n			 *  @default Processing...\n			 *\n			 *  @dtopt Language\n			 *  @name DataTable.defaults.language.processing\n			 *\n			 *  @example\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"processing\": \"DataTables is currently busy\"\n			 *        }\n			 *      } );\n			 *    } );\n			 */\n			\"sProcessing\": \"Processing...\",\n	\n	\n			/**\n			 * Details the actions that will be taken when the user types into the\n			 * filtering input text box. The variable \"_INPUT_\", if used in the string,\n			 * is replaced with the HTML text box for the filtering input allowing\n			 * control over where it appears in the string. If \"_INPUT_\" is not given\n			 * then the input box is appended to the string automatically.\n			 *  @type string\n			 *  @default Search:\n			 *\n			 *  @dtopt Language\n			 *  @name DataTable.defaults.language.search\n			 *\n			 *  @example\n			 *    // Input text box will be appended at the end automatically\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"search\": \"Filter records:\"\n			 *        }\n			 *      } );\n			 *    } );\n			 *\n			 *  @example\n			 *    // Specify where the filter should appear\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"search\": \"Apply filter _INPUT_ to table\"\n			 *        }\n			 *      } );\n			 *    } );\n			 */\n			\"sSearch\": \"Search:\",\n	\n	\n			/**\n			 * Assign a `placeholder` attribute to the search `input` element\n			 *  @type string\n			 *  @default \n			 *\n			 *  @dtopt Language\n			 *  @name DataTable.defaults.language.searchPlaceholder\n			 */\n			\"sSearchPlaceholder\": \"\",\n	\n	\n			/**\n			 * All of the language information can be stored in a file on the\n			 * server-side, which DataTables will look up if this parameter is passed.\n			 * It must store the URL of the language file, which is in a JSON format,\n			 * and the object has the same properties as the oLanguage object in the\n			 * initialiser object (i.e. the above parameters). Please refer to one of\n			 * the example language files to see how this works in action.\n			 *  @type string\n			 *  @default <i>Empty string - i.e. disabled</i>\n			 *\n			 *  @dtopt Language\n			 *  @name DataTable.defaults.language.url\n			 *\n			 *  @example\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"url\": \"http://www.sprymedia.co.uk/dataTables/lang.txt\"\n			 *        }\n			 *      } );\n			 *    } );\n			 */\n			\"sUrl\": \"\",\n	\n	\n			/**\n			 * Text shown inside the table records when the is no information to be\n			 * displayed after filtering. `emptyTable` is shown when there is simply no\n			 * information in the table at all (regardless of filtering).\n			 *  @type string\n			 *  @default No matching records found\n			 *\n			 *  @dtopt Language\n			 *  @name DataTable.defaults.language.zeroRecords\n			 *\n			 *  @example\n			 *    $(document).ready( function() {\n			 *      $('#example').dataTable( {\n			 *        \"language\": {\n			 *          \"zeroRecords\": \"No records to display\"\n			 *        }\n			 *      } );\n			 *    } );\n			 */\n			\"sZeroRecords\": \"No matching records found\"\n		},\n	\n	\n		/**\n		 * This parameter allows you to have define the global filtering state at\n		 * initialisation time. As an object the `search` parameter must be\n		 * defined, but all other parameters are optional. When `regex` is true,\n		 * the search string will be treated as a regular expression, when false\n		 * (default) it will be treated as a straight string. When `smart`\n		 * DataTables will use it's smart filtering methods (to word match at\n		 * any point in the data), when false this will not be done.\n		 *  @namespace\n		 *  @extends DataTable.models.oSearch\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.search\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"search\": {\"search\": \"Initial search\"}\n		 *      } );\n		 *    } )\n		 */\n		\"oSearch\": $.extend( {}, DataTable.models.oSearch ),\n	\n	\n		/**\n		 * __Deprecated__ The functionality provided by this parameter has now been\n		 * superseded by that provided through `ajax`, which should be used instead.\n		 *\n		 * By default DataTables will look for the property `data` (or `aaData` for\n		 * compatibility with DataTables 1.9-) when obtaining data from an Ajax\n		 * source or for server-side processing - this parameter allows that\n		 * property to be changed. You can use Javascript dotted object notation to\n		 * get a data source for multiple levels of nesting.\n		 *  @type string\n		 *  @default data\n		 *\n		 *  @dtopt Options\n		 *  @dtopt Server-side\n		 *  @name DataTable.defaults.ajaxDataProp\n		 *\n		 *  @deprecated 1.10. Please use `ajax` for this functionality now.\n		 */\n		\"sAjaxDataProp\": \"data\",\n	\n	\n		/**\n		 * __Deprecated__ The functionality provided by this parameter has now been\n		 * superseded by that provided through `ajax`, which should be used instead.\n		 *\n		 * You can instruct DataTables to load data from an external\n		 * source using this parameter (use aData if you want to pass data in you\n		 * already have). Simply provide a url a JSON object can be obtained from.\n		 *  @type string\n		 *  @default null\n		 *\n		 *  @dtopt Options\n		 *  @dtopt Server-side\n		 *  @name DataTable.defaults.ajaxSource\n		 *\n		 *  @deprecated 1.10. Please use `ajax` for this functionality now.\n		 */\n		\"sAjaxSource\": null,\n	\n	\n		/**\n		 * This initialisation variable allows you to specify exactly where in the\n		 * DOM you want DataTables to inject the various controls it adds to the page\n		 * (for example you might want the pagination controls at the top of the\n		 * table). DIV elements (with or without a custom class) can also be added to\n		 * aid styling. The follow syntax is used:\n		 *   <ul>\n		 *     <li>The following options are allowed:\n		 *       <ul>\n		 *         <li>'l' - Length changing</li>\n		 *         <li>'f' - Filtering input</li>\n		 *         <li>'t' - The table!</li>\n		 *         <li>'i' - Information</li>\n		 *         <li>'p' - Pagination</li>\n		 *         <li>'r' - pRocessing</li>\n		 *       </ul>\n		 *     </li>\n		 *     <li>The following constants are allowed:\n		 *       <ul>\n		 *         <li>'H' - jQueryUI theme \"header\" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>\n		 *         <li>'F' - jQueryUI theme \"footer\" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>\n		 *       </ul>\n		 *     </li>\n		 *     <li>The following syntax is expected:\n		 *       <ul>\n		 *         <li>'&lt;' and '&gt;' - div elements</li>\n		 *         <li>'&lt;\"class\" and '&gt;' - div with a class</li>\n		 *         <li>'&lt;\"#id\" and '&gt;' - div with an ID</li>\n		 *       </ul>\n		 *     </li>\n		 *     <li>Examples:\n		 *       <ul>\n		 *         <li>'&lt;\"wrapper\"flipt&gt;'</li>\n		 *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>\n		 *       </ul>\n		 *     </li>\n		 *   </ul>\n		 *  @type string\n		 *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>\n		 *    <\"H\"lfr>t<\"F\"ip> <i>(when `jQueryUI` is true)</i>\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.dom\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"dom\": '&lt;\"top\"i&gt;rt&lt;\"bottom\"flp&gt;&lt;\"clear\"&gt;'\n		 *      } );\n		 *    } );\n		 */\n		\"sDom\": \"lfrtip\",\n	\n	\n		/**\n		 * Search delay option. This will throttle full table searches that use the\n		 * DataTables provided search input element (it does not effect calls to\n		 * `dt-api search()`, providing a delay before the search is made.\n		 *  @type integer\n		 *  @default 0\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.searchDelay\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"searchDelay\": 200\n		 *      } );\n		 *    } )\n		 */\n		\"searchDelay\": null,\n	\n	\n		/**\n		 * DataTables features four different built-in options for the buttons to\n		 * display for pagination control:\n		 *\n		 * * `simple` - 'Previous' and 'Next' buttons only\n		 * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers\n		 * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons\n		 * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus\n		 *   page numbers\n		 *  \n		 * Further methods can be added using {@link DataTable.ext.oPagination}.\n		 *  @type string\n		 *  @default simple_numbers\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.pagingType\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"pagingType\": \"full_numbers\"\n		 *      } );\n		 *    } )\n		 */\n		\"sPaginationType\": \"simple_numbers\",\n	\n	\n		/**\n		 * Enable horizontal scrolling. When a table is too wide to fit into a\n		 * certain layout, or you have a large number of columns in the table, you\n		 * can enable x-scrolling to show the table in a viewport, which can be\n		 * scrolled. This property can be `true` which will allow the table to\n		 * scroll horizontally when needed, or any CSS unit, or a number (in which\n		 * case it will be treated as a pixel measurement). Setting as simply `true`\n		 * is recommended.\n		 *  @type boolean|string\n		 *  @default <i>blank string - i.e. disabled</i>\n		 *\n		 *  @dtopt Features\n		 *  @name DataTable.defaults.scrollX\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"scrollX\": true,\n		 *        \"scrollCollapse\": true\n		 *      } );\n		 *    } );\n		 */\n		\"sScrollX\": \"\",\n	\n	\n		/**\n		 * This property can be used to force a DataTable to use more width than it\n		 * might otherwise do when x-scrolling is enabled. For example if you have a\n		 * table which requires to be well spaced, this parameter is useful for\n		 * \"over-sizing\" the table, and thus forcing scrolling. This property can by\n		 * any CSS unit, or a number (in which case it will be treated as a pixel\n		 * measurement).\n		 *  @type string\n		 *  @default <i>blank string - i.e. disabled</i>\n		 *\n		 *  @dtopt Options\n		 *  @name DataTable.defaults.scrollXInner\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"scrollX\": \"100%\",\n		 *        \"scrollXInner\": \"110%\"\n		 *      } );\n		 *    } );\n		 */\n		\"sScrollXInner\": \"\",\n	\n	\n		/**\n		 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable\n		 * to the given height, and enable scrolling for any data which overflows the\n		 * current viewport. This can be used as an alternative to paging to display\n		 * a lot of data in a small area (although paging and scrolling can both be\n		 * enabled at the same time). This property can be any CSS unit, or a number\n		 * (in which case it will be treated as a pixel measurement).\n		 *  @type string\n		 *  @default <i>blank string - i.e. disabled</i>\n		 *\n		 *  @dtopt Features\n		 *  @name DataTable.defaults.scrollY\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"scrollY\": \"200px\",\n		 *        \"paginate\": false\n		 *      } );\n		 *    } );\n		 */\n		\"sScrollY\": \"\",\n	\n	\n		/**\n		 * __Deprecated__ The functionality provided by this parameter has now been\n		 * superseded by that provided through `ajax`, which should be used instead.\n		 *\n		 * Set the HTTP method that is used to make the Ajax call for server-side\n		 * processing or Ajax sourced data.\n		 *  @type string\n		 *  @default GET\n		 *\n		 *  @dtopt Options\n		 *  @dtopt Server-side\n		 *  @name DataTable.defaults.serverMethod\n		 *\n		 *  @deprecated 1.10. Please use `ajax` for this functionality now.\n		 */\n		\"sServerMethod\": \"GET\",\n	\n	\n		/**\n		 * DataTables makes use of renderers when displaying HTML elements for\n		 * a table. These renderers can be added or modified by plug-ins to\n		 * generate suitable mark-up for a site. For example the Bootstrap\n		 * integration plug-in for DataTables uses a paging button renderer to\n		 * display pagination buttons in the mark-up required by Bootstrap.\n		 *\n		 * For further information about the renderers available see\n		 * DataTable.ext.renderer\n		 *  @type string|object\n		 *  @default null\n		 *\n		 *  @name DataTable.defaults.renderer\n		 *\n		 */\n		\"renderer\": null,\n	\n	\n		/**\n		 * Set the data property name that DataTables should use to get a row's id\n		 * to set as the `id` property in the node.\n		 *  @type string\n		 *  @default DT_RowId\n		 *\n		 *  @name DataTable.defaults.rowId\n		 */\n		\"rowId\": \"DT_RowId\"\n	};\n	\n	_fnHungarianMap( DataTable.defaults );\n	\n	\n	\n	/*\n	 * Developer note - See note in model.defaults.js about the use of Hungarian\n	 * notation and camel case.\n	 */\n	\n	/**\n	 * Column options that can be given to DataTables at initialisation time.\n	 *  @namespace\n	 */\n	DataTable.defaults.column = {\n		/**\n		 * Define which column(s) an order will occur on for this column. This\n		 * allows a column's ordering to take multiple columns into account when\n		 * doing a sort or use the data from a different column. For example first\n		 * name / last name columns make sense to do a multi-column sort over the\n		 * two columns.\n		 *  @type array|int\n		 *  @default null <i>Takes the value of the column index automatically</i>\n		 *\n		 *  @name DataTable.defaults.column.orderData\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Using `columnDefs`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [\n		 *          { \"orderData\": [ 0, 1 ], \"targets\": [ 0 ] },\n		 *          { \"orderData\": [ 1, 0 ], \"targets\": [ 1 ] },\n		 *          { \"orderData\": 2, \"targets\": [ 2 ] }\n		 *        ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using `columns`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columns\": [\n		 *          { \"orderData\": [ 0, 1 ] },\n		 *          { \"orderData\": [ 1, 0 ] },\n		 *          { \"orderData\": 2 },\n		 *          null,\n		 *          null\n		 *        ]\n		 *      } );\n		 *    } );\n		 */\n		\"aDataSort\": null,\n		\"iDataSort\": -1,\n	\n	\n		/**\n		 * You can control the default ordering direction, and even alter the\n		 * behaviour of the sort handler (i.e. only allow ascending ordering etc)\n		 * using this parameter.\n		 *  @type array\n		 *  @default [ 'asc', 'desc' ]\n		 *\n		 *  @name DataTable.defaults.column.orderSequence\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Using `columnDefs`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [\n		 *          { \"orderSequence\": [ \"asc\" ], \"targets\": [ 1 ] },\n		 *          { \"orderSequence\": [ \"desc\", \"asc\", \"asc\" ], \"targets\": [ 2 ] },\n		 *          { \"orderSequence\": [ \"desc\" ], \"targets\": [ 3 ] }\n		 *        ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using `columns`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columns\": [\n		 *          null,\n		 *          { \"orderSequence\": [ \"asc\" ] },\n		 *          { \"orderSequence\": [ \"desc\", \"asc\", \"asc\" ] },\n		 *          { \"orderSequence\": [ \"desc\" ] },\n		 *          null\n		 *        ]\n		 *      } );\n		 *    } );\n		 */\n		\"asSorting\": [ 'asc', 'desc' ],\n	\n	\n		/**\n		 * Enable or disable filtering on the data in this column.\n		 *  @type boolean\n		 *  @default true\n		 *\n		 *  @name DataTable.defaults.column.searchable\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Using `columnDefs`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [\n		 *          { \"searchable\": false, \"targets\": [ 0 ] }\n		 *        ] } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using `columns`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columns\": [\n		 *          { \"searchable\": false },\n		 *          null,\n		 *          null,\n		 *          null,\n		 *          null\n		 *        ] } );\n		 *    } );\n		 */\n		\"bSearchable\": true,\n	\n	\n		/**\n		 * Enable or disable ordering on this column.\n		 *  @type boolean\n		 *  @default true\n		 *\n		 *  @name DataTable.defaults.column.orderable\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Using `columnDefs`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [\n		 *          { \"orderable\": false, \"targets\": [ 0 ] }\n		 *        ] } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using `columns`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columns\": [\n		 *          { \"orderable\": false },\n		 *          null,\n		 *          null,\n		 *          null,\n		 *          null\n		 *        ] } );\n		 *    } );\n		 */\n		\"bSortable\": true,\n	\n	\n		/**\n		 * Enable or disable the display of this column.\n		 *  @type boolean\n		 *  @default true\n		 *\n		 *  @name DataTable.defaults.column.visible\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Using `columnDefs`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [\n		 *          { \"visible\": false, \"targets\": [ 0 ] }\n		 *        ] } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using `columns`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columns\": [\n		 *          { \"visible\": false },\n		 *          null,\n		 *          null,\n		 *          null,\n		 *          null\n		 *        ] } );\n		 *    } );\n		 */\n		\"bVisible\": true,\n	\n	\n		/**\n		 * Developer definable function that is called whenever a cell is created (Ajax source,\n		 * etc) or processed for input (DOM source). This can be used as a compliment to mRender\n		 * allowing you to modify the DOM element (add background colour for example) when the\n		 * element is available.\n		 *  @type function\n		 *  @param {element} td The TD node that has been created\n		 *  @param {*} cellData The Data for the cell\n		 *  @param {array|object} rowData The data for the whole row\n		 *  @param {int} row The row index for the aoData data store\n		 *  @param {int} col The column index for aoColumns\n		 *\n		 *  @name DataTable.defaults.column.createdCell\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [ {\n		 *          \"targets\": [3],\n		 *          \"createdCell\": function (td, cellData, rowData, row, col) {\n		 *            if ( cellData == \"1.7\" ) {\n		 *              $(td).css('color', 'blue')\n		 *            }\n		 *          }\n		 *        } ]\n		 *      });\n		 *    } );\n		 */\n		\"fnCreatedCell\": null,\n	\n	\n		/**\n		 * This parameter has been replaced by `data` in DataTables to ensure naming\n		 * consistency. `dataProp` can still be used, as there is backwards\n		 * compatibility in DataTables for this option, but it is strongly\n		 * recommended that you use `data` in preference to `dataProp`.\n		 *  @name DataTable.defaults.column.dataProp\n		 */\n	\n	\n		/**\n		 * This property can be used to read data from any data source property,\n		 * including deeply nested objects / properties. `data` can be given in a\n		 * number of different ways which effect its behaviour:\n		 *\n		 * * `integer` - treated as an array index for the data source. This is the\n		 *   default that DataTables uses (incrementally increased for each column).\n		 * * `string` - read an object property from the data source. There are\n		 *   three 'special' options that can be used in the string to alter how\n		 *   DataTables reads the data from the source object:\n		 *    * `.` - Dotted Javascript notation. Just as you use a `.` in\n		 *      Javascript to read from nested objects, so to can the options\n		 *      specified in `data`. For example: `browser.version` or\n		 *      `browser.name`. If your object parameter name contains a period, use\n		 *      `\\\\` to escape it - i.e. `first\\\\.name`.\n		 *    * `[]` - Array notation. DataTables can automatically combine data\n		 *      from and array source, joining the data with the characters provided\n		 *      between the two brackets. For example: `name[, ]` would provide a\n		 *      comma-space separated list from the source array. If no characters\n		 *      are provided between the brackets, the original array source is\n		 *      returned.\n		 *    * `()` - Function notation. Adding `()` to the end of a parameter will\n		 *      execute a function of the name given. For example: `browser()` for a\n		 *      simple function on the data source, `browser.version()` for a\n		 *      function in a nested property or even `browser().version` to get an\n		 *      object property if the function called returns an object. Note that\n		 *      function notation is recommended for use in `render` rather than\n		 *      `data` as it is much simpler to use as a renderer.\n		 * * `null` - use the original data source for the row rather than plucking\n		 *   data directly from it. This action has effects on two other\n		 *   initialisation options:\n		 *    * `defaultContent` - When null is given as the `data` option and\n		 *      `defaultContent` is specified for the column, the value defined by\n		 *      `defaultContent` will be used for the cell.\n		 *    * `render` - When null is used for the `data` option and the `render`\n		 *      option is specified for the column, the whole data source for the\n		 *      row is used for the renderer.\n		 * * `function` - the function given will be executed whenever DataTables\n		 *   needs to set or get the data for a cell in the column. The function\n		 *   takes three parameters:\n		 *    * Parameters:\n		 *      * `{array|object}` The data source for the row\n		 *      * `{string}` The type call data requested - this will be 'set' when\n		 *        setting data or 'filter', 'display', 'type', 'sort' or undefined\n		 *        when gathering data. Note that when `undefined` is given for the\n		 *        type DataTables expects to get the raw data for the object back<\n		 *      * `{*}` Data to set when the second parameter is 'set'.\n		 *    * Return:\n		 *      * The return value from the function is not required when 'set' is\n		 *        the type of call, but otherwise the return is what will be used\n		 *        for the data requested.\n		 *\n		 * Note that `data` is a getter and setter option. If you just require\n		 * formatting of data for output, you will likely want to use `render` which\n		 * is simply a getter and thus simpler to use.\n		 *\n		 * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The\n		 * name change reflects the flexibility of this property and is consistent\n		 * with the naming of mRender. If 'mDataProp' is given, then it will still\n		 * be used by DataTables, as it automatically maps the old name to the new\n		 * if required.\n		 *\n		 *  @type string|int|function|null\n		 *  @default null <i>Use automatically calculated column index</i>\n		 *\n		 *  @name DataTable.defaults.column.data\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Read table data from objects\n		 *    // JSON structure for each row:\n		 *    //   {\n		 *    //      \"engine\": {value},\n		 *    //      \"browser\": {value},\n		 *    //      \"platform\": {value},\n		 *    //      \"version\": {value},\n		 *    //      \"grade\": {value}\n		 *    //   }\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"ajaxSource\": \"sources/objects.txt\",\n		 *        \"columns\": [\n		 *          { \"data\": \"engine\" },\n		 *          { \"data\": \"browser\" },\n		 *          { \"data\": \"platform\" },\n		 *          { \"data\": \"version\" },\n		 *          { \"data\": \"grade\" }\n		 *        ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Read information from deeply nested objects\n		 *    // JSON structure for each row:\n		 *    //   {\n		 *    //      \"engine\": {value},\n		 *    //      \"browser\": {value},\n		 *    //      \"platform\": {\n		 *    //         \"inner\": {value}\n		 *    //      },\n		 *    //      \"details\": [\n		 *    //         {value}, {value}\n		 *    //      ]\n		 *    //   }\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"ajaxSource\": \"sources/deep.txt\",\n		 *        \"columns\": [\n		 *          { \"data\": \"engine\" },\n		 *          { \"data\": \"browser\" },\n		 *          { \"data\": \"platform.inner\" },\n		 *          { \"data\": \"platform.details.0\" },\n		 *          { \"data\": \"platform.details.1\" }\n		 *        ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using `data` as a function to provide different information for\n		 *    // sorting, filtering and display. In this case, currency (price)\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [ {\n		 *          \"targets\": [ 0 ],\n		 *          \"data\": function ( source, type, val ) {\n		 *            if (type === 'set') {\n		 *              source.price = val;\n		 *              // Store the computed dislay and filter values for efficiency\n		 *              source.price_display = val==\"\" ? \"\" : \"$\"+numberFormat(val);\n		 *              source.price_filter  = val==\"\" ? \"\" : \"$\"+numberFormat(val)+\" \"+val;\n		 *              return;\n		 *            }\n		 *            else if (type === 'display') {\n		 *              return source.price_display;\n		 *            }\n		 *            else if (type === 'filter') {\n		 *              return source.price_filter;\n		 *            }\n		 *            // 'sort', 'type' and undefined all just use the integer\n		 *            return source.price;\n		 *          }\n		 *        } ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using default content\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [ {\n		 *          \"targets\": [ 0 ],\n		 *          \"data\": null,\n		 *          \"defaultContent\": \"Click to edit\"\n		 *        } ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using array notation - outputting a list from an array\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [ {\n		 *          \"targets\": [ 0 ],\n		 *          \"data\": \"name[, ]\"\n		 *        } ]\n		 *      } );\n		 *    } );\n		 *\n		 */\n		\"mData\": null,\n	\n	\n		/**\n		 * This property is the rendering partner to `data` and it is suggested that\n		 * when you want to manipulate data for display (including filtering,\n		 * sorting etc) without altering the underlying data for the table, use this\n		 * property. `render` can be considered to be the the read only companion to\n		 * `data` which is read / write (then as such more complex). Like `data`\n		 * this option can be given in a number of different ways to effect its\n		 * behaviour:\n		 *\n		 * * `integer` - treated as an array index for the data source. This is the\n		 *   default that DataTables uses (incrementally increased for each column).\n		 * * `string` - read an object property from the data source. There are\n		 *   three 'special' options that can be used in the string to alter how\n		 *   DataTables reads the data from the source object:\n		 *    * `.` - Dotted Javascript notation. Just as you use a `.` in\n		 *      Javascript to read from nested objects, so to can the options\n		 *      specified in `data`. For example: `browser.version` or\n		 *      `browser.name`. If your object parameter name contains a period, use\n		 *      `\\\\` to escape it - i.e. `first\\\\.name`.\n		 *    * `[]` - Array notation. DataTables can automatically combine data\n		 *      from and array source, joining the data with the characters provided\n		 *      between the two brackets. For example: `name[, ]` would provide a\n		 *      comma-space separated list from the source array. If no characters\n		 *      are provided between the brackets, the original array source is\n		 *      returned.\n		 *    * `()` - Function notation. Adding `()` to the end of a parameter will\n		 *      execute a function of the name given. For example: `browser()` for a\n		 *      simple function on the data source, `browser.version()` for a\n		 *      function in a nested property or even `browser().version` to get an\n		 *      object property if the function called returns an object.\n		 * * `object` - use different data for the different data types requested by\n		 *   DataTables ('filter', 'display', 'type' or 'sort'). The property names\n		 *   of the object is the data type the property refers to and the value can\n		 *   defined using an integer, string or function using the same rules as\n		 *   `render` normally does. Note that an `_` option _must_ be specified.\n		 *   This is the default value to use if you haven't specified a value for\n		 *   the data type requested by DataTables.\n		 * * `function` - the function given will be executed whenever DataTables\n		 *   needs to set or get the data for a cell in the column. The function\n		 *   takes three parameters:\n		 *    * Parameters:\n		 *      * {array|object} The data source for the row (based on `data`)\n		 *      * {string} The type call data requested - this will be 'filter',\n		 *        'display', 'type' or 'sort'.\n		 *      * {array|object} The full data source for the row (not based on\n		 *        `data`)\n		 *    * Return:\n		 *      * The return value from the function is what will be used for the\n		 *        data requested.\n		 *\n		 *  @type string|int|function|object|null\n		 *  @default null Use the data source value.\n		 *\n		 *  @name DataTable.defaults.column.render\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Create a comma separated list from an array of objects\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"ajaxSource\": \"sources/deep.txt\",\n		 *        \"columns\": [\n		 *          { \"data\": \"engine\" },\n		 *          { \"data\": \"browser\" },\n		 *          {\n		 *            \"data\": \"platform\",\n		 *            \"render\": \"[, ].name\"\n		 *          }\n		 *        ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Execute a function to obtain data\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [ {\n		 *          \"targets\": [ 0 ],\n		 *          \"data\": null, // Use the full data source object for the renderer's source\n		 *          \"render\": \"browserName()\"\n		 *        } ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // As an object, extracting different data for the different types\n		 *    // This would be used with a data source such as:\n		 *    //   { \"phone\": 5552368, \"phone_filter\": \"5552368 555-2368\", \"phone_display\": \"555-2368\" }\n		 *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`\n		 *    // (which has both forms) is used for filtering for if a user inputs either format, while\n		 *    // the formatted phone number is the one that is shown in the table.\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [ {\n		 *          \"targets\": [ 0 ],\n		 *          \"data\": null, // Use the full data source object for the renderer's source\n		 *          \"render\": {\n		 *            \"_\": \"phone\",\n		 *            \"filter\": \"phone_filter\",\n		 *            \"display\": \"phone_display\"\n		 *          }\n		 *        } ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Use as a function to create a link from the data source\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [ {\n		 *          \"targets\": [ 0 ],\n		 *          \"data\": \"download_link\",\n		 *          \"render\": function ( data, type, full ) {\n		 *            return '<a href=\"'+data+'\">Download</a>';\n		 *          }\n		 *        } ]\n		 *      } );\n		 *    } );\n		 */\n		\"mRender\": null,\n	\n	\n		/**\n		 * Change the cell type created for the column - either TD cells or TH cells. This\n		 * can be useful as TH cells have semantic meaning in the table body, allowing them\n		 * to act as a header for a row (you may wish to add scope='row' to the TH elements).\n		 *  @type string\n		 *  @default td\n		 *\n		 *  @name DataTable.defaults.column.cellType\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Make the first column use TH cells\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [ {\n		 *          \"targets\": [ 0 ],\n		 *          \"cellType\": \"th\"\n		 *        } ]\n		 *      } );\n		 *    } );\n		 */\n		\"sCellType\": \"td\",\n	\n	\n		/**\n		 * Class to give to each cell in this column.\n		 *  @type string\n		 *  @default <i>Empty string</i>\n		 *\n		 *  @name DataTable.defaults.column.class\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Using `columnDefs`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [\n		 *          { \"class\": \"my_class\", \"targets\": [ 0 ] }\n		 *        ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using `columns`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columns\": [\n		 *          { \"class\": \"my_class\" },\n		 *          null,\n		 *          null,\n		 *          null,\n		 *          null\n		 *        ]\n		 *      } );\n		 *    } );\n		 */\n		\"sClass\": \"\",\n	\n		/**\n		 * When DataTables calculates the column widths to assign to each column,\n		 * it finds the longest string in each column and then constructs a\n		 * temporary table and reads the widths from that. The problem with this\n		 * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\n		 * string - thus the calculation can go wrong (doing it properly and putting\n		 * it into an DOM object and measuring that is horribly(!) slow). Thus as\n		 * a \"work around\" we provide this option. It will append its value to the\n		 * text that is found to be the longest string for the column - i.e. padding.\n		 * Generally you shouldn't need this!\n		 *  @type string\n		 *  @default <i>Empty string<i>\n		 *\n		 *  @name DataTable.defaults.column.contentPadding\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Using `columns`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columns\": [\n		 *          null,\n		 *          null,\n		 *          null,\n		 *          {\n		 *            \"contentPadding\": \"mmm\"\n		 *          }\n		 *        ]\n		 *      } );\n		 *    } );\n		 */\n		\"sContentPadding\": \"\",\n	\n	\n		/**\n		 * Allows a default value to be given for a column's data, and will be used\n		 * whenever a null data source is encountered (this can be because `data`\n		 * is set to null, or because the data source itself is null).\n		 *  @type string\n		 *  @default null\n		 *\n		 *  @name DataTable.defaults.column.defaultContent\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Using `columnDefs`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [\n		 *          {\n		 *            \"data\": null,\n		 *            \"defaultContent\": \"Edit\",\n		 *            \"targets\": [ -1 ]\n		 *          }\n		 *        ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using `columns`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columns\": [\n		 *          null,\n		 *          null,\n		 *          null,\n		 *          {\n		 *            \"data\": null,\n		 *            \"defaultContent\": \"Edit\"\n		 *          }\n		 *        ]\n		 *      } );\n		 *    } );\n		 */\n		\"sDefaultContent\": null,\n	\n	\n		/**\n		 * This parameter is only used in DataTables' server-side processing. It can\n		 * be exceptionally useful to know what columns are being displayed on the\n		 * client side, and to map these to database fields. When defined, the names\n		 * also allow DataTables to reorder information from the server if it comes\n		 * back in an unexpected order (i.e. if you switch your columns around on the\n		 * client-side, your server-side code does not also need updating).\n		 *  @type string\n		 *  @default <i>Empty string</i>\n		 *\n		 *  @name DataTable.defaults.column.name\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Using `columnDefs`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [\n		 *          { \"name\": \"engine\", \"targets\": [ 0 ] },\n		 *          { \"name\": \"browser\", \"targets\": [ 1 ] },\n		 *          { \"name\": \"platform\", \"targets\": [ 2 ] },\n		 *          { \"name\": \"version\", \"targets\": [ 3 ] },\n		 *          { \"name\": \"grade\", \"targets\": [ 4 ] }\n		 *        ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using `columns`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columns\": [\n		 *          { \"name\": \"engine\" },\n		 *          { \"name\": \"browser\" },\n		 *          { \"name\": \"platform\" },\n		 *          { \"name\": \"version\" },\n		 *          { \"name\": \"grade\" }\n		 *        ]\n		 *      } );\n		 *    } );\n		 */\n		\"sName\": \"\",\n	\n	\n		/**\n		 * Defines a data source type for the ordering which can be used to read\n		 * real-time information from the table (updating the internally cached\n		 * version) prior to ordering. This allows ordering to occur on user\n		 * editable elements such as form inputs.\n		 *  @type string\n		 *  @default std\n		 *\n		 *  @name DataTable.defaults.column.orderDataType\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Using `columnDefs`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [\n		 *          { \"orderDataType\": \"dom-text\", \"targets\": [ 2, 3 ] },\n		 *          { \"type\": \"numeric\", \"targets\": [ 3 ] },\n		 *          { \"orderDataType\": \"dom-select\", \"targets\": [ 4 ] },\n		 *          { \"orderDataType\": \"dom-checkbox\", \"targets\": [ 5 ] }\n		 *        ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using `columns`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columns\": [\n		 *          null,\n		 *          null,\n		 *          { \"orderDataType\": \"dom-text\" },\n		 *          { \"orderDataType\": \"dom-text\", \"type\": \"numeric\" },\n		 *          { \"orderDataType\": \"dom-select\" },\n		 *          { \"orderDataType\": \"dom-checkbox\" }\n		 *        ]\n		 *      } );\n		 *    } );\n		 */\n		\"sSortDataType\": \"std\",\n	\n	\n		/**\n		 * The title of this column.\n		 *  @type string\n		 *  @default null <i>Derived from the 'TH' value for this column in the\n		 *    original HTML table.</i>\n		 *\n		 *  @name DataTable.defaults.column.title\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Using `columnDefs`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [\n		 *          { \"title\": \"My column title\", \"targets\": [ 0 ] }\n		 *        ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using `columns`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columns\": [\n		 *          { \"title\": \"My column title\" },\n		 *          null,\n		 *          null,\n		 *          null,\n		 *          null\n		 *        ]\n		 *      } );\n		 *    } );\n		 */\n		\"sTitle\": null,\n	\n	\n		/**\n		 * The type allows you to specify how the data for this column will be\n		 * ordered. Four types (string, numeric, date and html (which will strip\n		 * HTML tags before ordering)) are currently available. Note that only date\n		 * formats understood by Javascript's Date() object will be accepted as type\n		 * date. For example: \"Mar 26, 2008 5:03 PM\". May take the values: 'string',\n		 * 'numeric', 'date' or 'html' (by default). Further types can be adding\n		 * through plug-ins.\n		 *  @type string\n		 *  @default null <i>Auto-detected from raw data</i>\n		 *\n		 *  @name DataTable.defaults.column.type\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Using `columnDefs`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [\n		 *          { \"type\": \"html\", \"targets\": [ 0 ] }\n		 *        ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using `columns`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columns\": [\n		 *          { \"type\": \"html\" },\n		 *          null,\n		 *          null,\n		 *          null,\n		 *          null\n		 *        ]\n		 *      } );\n		 *    } );\n		 */\n		\"sType\": null,\n	\n	\n		/**\n		 * Defining the width of the column, this parameter may take any CSS value\n		 * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not\n		 * been given a specific width through this interface ensuring that the table\n		 * remains readable.\n		 *  @type string\n		 *  @default null <i>Automatic</i>\n		 *\n		 *  @name DataTable.defaults.column.width\n		 *  @dtopt Columns\n		 *\n		 *  @example\n		 *    // Using `columnDefs`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columnDefs\": [\n		 *          { \"width\": \"20%\", \"targets\": [ 0 ] }\n		 *        ]\n		 *      } );\n		 *    } );\n		 *\n		 *  @example\n		 *    // Using `columns`\n		 *    $(document).ready( function() {\n		 *      $('#example').dataTable( {\n		 *        \"columns\": [\n		 *          { \"width\": \"20%\" },\n		 *          null,\n		 *          null,\n		 *          null,\n		 *          null\n		 *        ]\n		 *      } );\n		 *    } );\n		 */\n		\"sWidth\": null\n	};\n	\n	_fnHungarianMap( DataTable.defaults.column );\n	\n	\n	\n	/**\n	 * DataTables settings object - this holds all the information needed for a\n	 * given table, including configuration, data and current application of the\n	 * table options. DataTables does not have a single instance for each DataTable\n	 * with the settings attached to that instance, but rather instances of the\n	 * DataTable \"class\" are created on-the-fly as needed (typically by a\n	 * $().dataTable() call) and the settings object is then applied to that\n	 * instance.\n	 *\n	 * Note that this object is related to {@link DataTable.defaults} but this\n	 * one is the internal data store for DataTables's cache of columns. It should\n	 * NOT be manipulated outside of DataTables. Any configuration should be done\n	 * through the initialisation options.\n	 *  @namespace\n	 *  @todo Really should attach the settings object to individual instances so we\n	 *    don't need to create new instances on each $().dataTable() call (if the\n	 *    table already exists). It would also save passing oSettings around and\n	 *    into every single function. However, this is a very significant\n	 *    architecture change for DataTables and will almost certainly break\n	 *    backwards compatibility with older installations. This is something that\n	 *    will be done in 2.0.\n	 */\n	DataTable.models.oSettings = {\n		/**\n		 * Primary features of DataTables and their enablement state.\n		 *  @namespace\n		 */\n		\"oFeatures\": {\n	\n			/**\n			 * Flag to say if DataTables should automatically try to calculate the\n			 * optimum table and columns widths (true) or not (false).\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type boolean\n			 */\n			\"bAutoWidth\": null,\n	\n			/**\n			 * Delay the creation of TR and TD elements until they are actually\n			 * needed by a driven page draw. This can give a significant speed\n			 * increase for Ajax source and Javascript source data, but makes no\n			 * difference at all fro DOM and server-side processing tables.\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type boolean\n			 */\n			\"bDeferRender\": null,\n	\n			/**\n			 * Enable filtering on the table or not. Note that if this is disabled\n			 * then there is no filtering at all on the table, including fnFilter.\n			 * To just remove the filtering input use sDom and remove the 'f' option.\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type boolean\n			 */\n			\"bFilter\": null,\n	\n			/**\n			 * Table information element (the 'Showing x of y records' div) enable\n			 * flag.\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type boolean\n			 */\n			\"bInfo\": null,\n	\n			/**\n			 * Present a user control allowing the end user to change the page size\n			 * when pagination is enabled.\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type boolean\n			 */\n			\"bLengthChange\": null,\n	\n			/**\n			 * Pagination enabled or not. Note that if this is disabled then length\n			 * changing must also be disabled.\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type boolean\n			 */\n			\"bPaginate\": null,\n	\n			/**\n			 * Processing indicator enable flag whenever DataTables is enacting a\n			 * user request - typically an Ajax request for server-side processing.\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type boolean\n			 */\n			\"bProcessing\": null,\n	\n			/**\n			 * Server-side processing enabled flag - when enabled DataTables will\n			 * get all data from the server for every draw - there is no filtering,\n			 * sorting or paging done on the client-side.\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type boolean\n			 */\n			\"bServerSide\": null,\n	\n			/**\n			 * Sorting enablement flag.\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type boolean\n			 */\n			\"bSort\": null,\n	\n			/**\n			 * Multi-column sorting\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type boolean\n			 */\n			\"bSortMulti\": null,\n	\n			/**\n			 * Apply a class to the columns which are being sorted to provide a\n			 * visual highlight or not. This can slow things down when enabled since\n			 * there is a lot of DOM interaction.\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type boolean\n			 */\n			\"bSortClasses\": null,\n	\n			/**\n			 * State saving enablement flag.\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type boolean\n			 */\n			\"bStateSave\": null\n		},\n	\n	\n		/**\n		 * Scrolling settings for a table.\n		 *  @namespace\n		 */\n		\"oScroll\": {\n			/**\n			 * When the table is shorter in height than sScrollY, collapse the\n			 * table container down to the height of the table (when true).\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type boolean\n			 */\n			\"bCollapse\": null,\n	\n			/**\n			 * Width of the scrollbar for the web-browser's platform. Calculated\n			 * during table initialisation.\n			 *  @type int\n			 *  @default 0\n			 */\n			\"iBarWidth\": 0,\n	\n			/**\n			 * Viewport width for horizontal scrolling. Horizontal scrolling is\n			 * disabled if an empty string.\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type string\n			 */\n			\"sX\": null,\n	\n			/**\n			 * Width to expand the table to when using x-scrolling. Typically you\n			 * should not need to use this.\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type string\n			 *  @deprecated\n			 */\n			\"sXInner\": null,\n	\n			/**\n			 * Viewport height for vertical scrolling. Vertical scrolling is disabled\n			 * if an empty string.\n			 * Note that this parameter will be set by the initialisation routine. To\n			 * set a default use {@link DataTable.defaults}.\n			 *  @type string\n			 */\n			\"sY\": null\n		},\n	\n		/**\n		 * Language information for the table.\n		 *  @namespace\n		 *  @extends DataTable.defaults.oLanguage\n		 */\n		\"oLanguage\": {\n			/**\n			 * Information callback function. See\n			 * {@link DataTable.defaults.fnInfoCallback}\n			 *  @type function\n			 *  @default null\n			 */\n			\"fnInfoCallback\": null\n		},\n	\n		/**\n		 * Browser support parameters\n		 *  @namespace\n		 */\n		\"oBrowser\": {\n			/**\n			 * Indicate if the browser incorrectly calculates width:100% inside a\n			 * scrolling element (IE6/7)\n			 *  @type boolean\n			 *  @default false\n			 */\n			\"bScrollOversize\": false,\n	\n			/**\n			 * Determine if the vertical scrollbar is on the right or left of the\n			 * scrolling container - needed for rtl language layout, although not\n			 * all browsers move the scrollbar (Safari).\n			 *  @type boolean\n			 *  @default false\n			 */\n			\"bScrollbarLeft\": false,\n	\n			/**\n			 * Flag for if `getBoundingClientRect` is fully supported or not\n			 *  @type boolean\n			 *  @default false\n			 */\n			\"bBounding\": false,\n	\n			/**\n			 * Browser scrollbar width\n			 *  @type integer\n			 *  @default 0\n			 */\n			\"barWidth\": 0\n		},\n	\n	\n		\"ajax\": null,\n	\n	\n		/**\n		 * Array referencing the nodes which are used for the features. The\n		 * parameters of this object match what is allowed by sDom - i.e.\n		 *   <ul>\n		 *     <li>'l' - Length changing</li>\n		 *     <li>'f' - Filtering input</li>\n		 *     <li>'t' - The table!</li>\n		 *     <li>'i' - Information</li>\n		 *     <li>'p' - Pagination</li>\n		 *     <li>'r' - pRocessing</li>\n		 *   </ul>\n		 *  @type array\n		 *  @default []\n		 */\n		\"aanFeatures\": [],\n	\n		/**\n		 * Store data information - see {@link DataTable.models.oRow} for detailed\n		 * information.\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoData\": [],\n	\n		/**\n		 * Array of indexes which are in the current display (after filtering etc)\n		 *  @type array\n		 *  @default []\n		 */\n		\"aiDisplay\": [],\n	\n		/**\n		 * Array of indexes for display - no filtering\n		 *  @type array\n		 *  @default []\n		 */\n		\"aiDisplayMaster\": [],\n	\n		/**\n		 * Map of row ids to data indexes\n		 *  @type object\n		 *  @default {}\n		 */\n		\"aIds\": {},\n	\n		/**\n		 * Store information about each column that is in use\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoColumns\": [],\n	\n		/**\n		 * Store information about the table's header\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoHeader\": [],\n	\n		/**\n		 * Store information about the table's footer\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoFooter\": [],\n	\n		/**\n		 * Store the applied global search information in case we want to force a\n		 * research or compare the old search to a new one.\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @namespace\n		 *  @extends DataTable.models.oSearch\n		 */\n		\"oPreviousSearch\": {},\n	\n		/**\n		 * Store the applied search for each column - see\n		 * {@link DataTable.models.oSearch} for the format that is used for the\n		 * filtering information for each column.\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoPreSearchCols\": [],\n	\n		/**\n		 * Sorting that is applied to the table. Note that the inner arrays are\n		 * used in the following manner:\n		 * <ul>\n		 *   <li>Index 0 - column number</li>\n		 *   <li>Index 1 - current sorting direction</li>\n		 * </ul>\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type array\n		 *  @todo These inner arrays should really be objects\n		 */\n		\"aaSorting\": null,\n	\n		/**\n		 * Sorting that is always applied to the table (i.e. prefixed in front of\n		 * aaSorting).\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type array\n		 *  @default []\n		 */\n		\"aaSortingFixed\": [],\n	\n		/**\n		 * Classes to use for the striping of a table.\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type array\n		 *  @default []\n		 */\n		\"asStripeClasses\": null,\n	\n		/**\n		 * If restoring a table - we should restore its striping classes as well\n		 *  @type array\n		 *  @default []\n		 */\n		\"asDestroyStripes\": [],\n	\n		/**\n		 * If restoring a table - we should restore its width\n		 *  @type int\n		 *  @default 0\n		 */\n		\"sDestroyWidth\": 0,\n	\n		/**\n		 * Callback functions array for every time a row is inserted (i.e. on a draw).\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoRowCallback\": [],\n	\n		/**\n		 * Callback functions for the header on each draw.\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoHeaderCallback\": [],\n	\n		/**\n		 * Callback function for the footer on each draw.\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoFooterCallback\": [],\n	\n		/**\n		 * Array of callback functions for draw callback functions\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoDrawCallback\": [],\n	\n		/**\n		 * Array of callback functions for row created function\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoRowCreatedCallback\": [],\n	\n		/**\n		 * Callback functions for just before the table is redrawn. A return of\n		 * false will be used to cancel the draw.\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoPreDrawCallback\": [],\n	\n		/**\n		 * Callback functions for when the table has been initialised.\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoInitComplete\": [],\n	\n	\n		/**\n		 * Callbacks for modifying the settings to be stored for state saving, prior to\n		 * saving state.\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoStateSaveParams\": [],\n	\n		/**\n		 * Callbacks for modifying the settings that have been stored for state saving\n		 * prior to using the stored values to restore the state.\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoStateLoadParams\": [],\n	\n		/**\n		 * Callbacks for operating on the settings object once the saved state has been\n		 * loaded\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoStateLoaded\": [],\n	\n		/**\n		 * Cache the table ID for quick access\n		 *  @type string\n		 *  @default <i>Empty string</i>\n		 */\n		\"sTableId\": \"\",\n	\n		/**\n		 * The TABLE node for the main table\n		 *  @type node\n		 *  @default null\n		 */\n		\"nTable\": null,\n	\n		/**\n		 * Permanent ref to the thead element\n		 *  @type node\n		 *  @default null\n		 */\n		\"nTHead\": null,\n	\n		/**\n		 * Permanent ref to the tfoot element - if it exists\n		 *  @type node\n		 *  @default null\n		 */\n		\"nTFoot\": null,\n	\n		/**\n		 * Permanent ref to the tbody element\n		 *  @type node\n		 *  @default null\n		 */\n		\"nTBody\": null,\n	\n		/**\n		 * Cache the wrapper node (contains all DataTables controlled elements)\n		 *  @type node\n		 *  @default null\n		 */\n		\"nTableWrapper\": null,\n	\n		/**\n		 * Indicate if when using server-side processing the loading of data\n		 * should be deferred until the second draw.\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type boolean\n		 *  @default false\n		 */\n		\"bDeferLoading\": false,\n	\n		/**\n		 * Indicate if all required information has been read in\n		 *  @type boolean\n		 *  @default false\n		 */\n		\"bInitialised\": false,\n	\n		/**\n		 * Information about open rows. Each object in the array has the parameters\n		 * 'nTr' and 'nParent'\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoOpenRows\": [],\n	\n		/**\n		 * Dictate the positioning of DataTables' control elements - see\n		 * {@link DataTable.model.oInit.sDom}.\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type string\n		 *  @default null\n		 */\n		\"sDom\": null,\n	\n		/**\n		 * Search delay (in mS)\n		 *  @type integer\n		 *  @default null\n		 */\n		\"searchDelay\": null,\n	\n		/**\n		 * Which type of pagination should be used.\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type string\n		 *  @default two_button\n		 */\n		\"sPaginationType\": \"two_button\",\n	\n		/**\n		 * The state duration (for `stateSave`) in seconds.\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type int\n		 *  @default 0\n		 */\n		\"iStateDuration\": 0,\n	\n		/**\n		 * Array of callback functions for state saving. Each array element is an\n		 * object with the following parameters:\n		 *   <ul>\n		 *     <li>function:fn - function to call. Takes two parameters, oSettings\n		 *       and the JSON string to save that has been thus far created. Returns\n		 *       a JSON string to be inserted into a json object\n		 *       (i.e. '\"param\": [ 0, 1, 2]')</li>\n		 *     <li>string:sName - name of callback</li>\n		 *   </ul>\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoStateSave\": [],\n	\n		/**\n		 * Array of callback functions for state loading. Each array element is an\n		 * object with the following parameters:\n		 *   <ul>\n		 *     <li>function:fn - function to call. Takes two parameters, oSettings\n		 *       and the object stored. May return false to cancel state loading</li>\n		 *     <li>string:sName - name of callback</li>\n		 *   </ul>\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoStateLoad\": [],\n	\n		/**\n		 * State that was saved. Useful for back reference\n		 *  @type object\n		 *  @default null\n		 */\n		\"oSavedState\": null,\n	\n		/**\n		 * State that was loaded. Useful for back reference\n		 *  @type object\n		 *  @default null\n		 */\n		\"oLoadedState\": null,\n	\n		/**\n		 * Source url for AJAX data for the table.\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type string\n		 *  @default null\n		 */\n		\"sAjaxSource\": null,\n	\n		/**\n		 * Property from a given object from which to read the table data from. This\n		 * can be an empty string (when not server-side processing), in which case\n		 * it is  assumed an an array is given directly.\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type string\n		 */\n		\"sAjaxDataProp\": null,\n	\n		/**\n		 * Note if draw should be blocked while getting data\n		 *  @type boolean\n		 *  @default true\n		 */\n		\"bAjaxDataGet\": true,\n	\n		/**\n		 * The last jQuery XHR object that was used for server-side data gathering.\n		 * This can be used for working with the XHR information in one of the\n		 * callbacks\n		 *  @type object\n		 *  @default null\n		 */\n		\"jqXHR\": null,\n	\n		/**\n		 * JSON returned from the server in the last Ajax request\n		 *  @type object\n		 *  @default undefined\n		 */\n		\"json\": undefined,\n	\n		/**\n		 * Data submitted as part of the last Ajax request\n		 *  @type object\n		 *  @default undefined\n		 */\n		\"oAjaxData\": undefined,\n	\n		/**\n		 * Function to get the server-side data.\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type function\n		 */\n		\"fnServerData\": null,\n	\n		/**\n		 * Functions which are called prior to sending an Ajax request so extra\n		 * parameters can easily be sent to the server\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoServerParams\": [],\n	\n		/**\n		 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if\n		 * required).\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type string\n		 */\n		\"sServerMethod\": null,\n	\n		/**\n		 * Format numbers for display.\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type function\n		 */\n		\"fnFormatNumber\": null,\n	\n		/**\n		 * List of options that can be used for the user selectable length menu.\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type array\n		 *  @default []\n		 */\n		\"aLengthMenu\": null,\n	\n		/**\n		 * Counter for the draws that the table does. Also used as a tracker for\n		 * server-side processing\n		 *  @type int\n		 *  @default 0\n		 */\n		\"iDraw\": 0,\n	\n		/**\n		 * Indicate if a redraw is being done - useful for Ajax\n		 *  @type boolean\n		 *  @default false\n		 */\n		\"bDrawing\": false,\n	\n		/**\n		 * Draw index (iDraw) of the last error when parsing the returned data\n		 *  @type int\n		 *  @default -1\n		 */\n		\"iDrawError\": -1,\n	\n		/**\n		 * Paging display length\n		 *  @type int\n		 *  @default 10\n		 */\n		\"_iDisplayLength\": 10,\n	\n		/**\n		 * Paging start point - aiDisplay index\n		 *  @type int\n		 *  @default 0\n		 */\n		\"_iDisplayStart\": 0,\n	\n		/**\n		 * Server-side processing - number of records in the result set\n		 * (i.e. before filtering), Use fnRecordsTotal rather than\n		 * this property to get the value of the number of records, regardless of\n		 * the server-side processing setting.\n		 *  @type int\n		 *  @default 0\n		 *  @private\n		 */\n		\"_iRecordsTotal\": 0,\n	\n		/**\n		 * Server-side processing - number of records in the current display set\n		 * (i.e. after filtering). Use fnRecordsDisplay rather than\n		 * this property to get the value of the number of records, regardless of\n		 * the server-side processing setting.\n		 *  @type boolean\n		 *  @default 0\n		 *  @private\n		 */\n		\"_iRecordsDisplay\": 0,\n	\n		/**\n		 * Flag to indicate if jQuery UI marking and classes should be used.\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type boolean\n		 */\n		\"bJUI\": null,\n	\n		/**\n		 * The classes to use for the table\n		 *  @type object\n		 *  @default {}\n		 */\n		\"oClasses\": {},\n	\n		/**\n		 * Flag attached to the settings object so you can check in the draw\n		 * callback if filtering has been done in the draw. Deprecated in favour of\n		 * events.\n		 *  @type boolean\n		 *  @default false\n		 *  @deprecated\n		 */\n		\"bFiltered\": false,\n	\n		/**\n		 * Flag attached to the settings object so you can check in the draw\n		 * callback if sorting has been done in the draw. Deprecated in favour of\n		 * events.\n		 *  @type boolean\n		 *  @default false\n		 *  @deprecated\n		 */\n		\"bSorted\": false,\n	\n		/**\n		 * Indicate that if multiple rows are in the header and there is more than\n		 * one unique cell per column, if the top one (true) or bottom one (false)\n		 * should be used for sorting / title by DataTables.\n		 * Note that this parameter will be set by the initialisation routine. To\n		 * set a default use {@link DataTable.defaults}.\n		 *  @type boolean\n		 */\n		\"bSortCellsTop\": null,\n	\n		/**\n		 * Initialisation object that is used for the table\n		 *  @type object\n		 *  @default null\n		 */\n		\"oInit\": null,\n	\n		/**\n		 * Destroy callback functions - for plug-ins to attach themselves to the\n		 * destroy so they can clean up markup and events.\n		 *  @type array\n		 *  @default []\n		 */\n		\"aoDestroyCallback\": [],\n	\n	\n		/**\n		 * Get the number of records in the current record set, before filtering\n		 *  @type function\n		 */\n		\"fnRecordsTotal\": function ()\n		{\n			return _fnDataSource( this ) == 'ssp' ?\n				this._iRecordsTotal * 1 :\n				this.aiDisplayMaster.length;\n		},\n	\n		/**\n		 * Get the number of records in the current record set, after filtering\n		 *  @type function\n		 */\n		\"fnRecordsDisplay\": function ()\n		{\n			return _fnDataSource( this ) == 'ssp' ?\n				this._iRecordsDisplay * 1 :\n				this.aiDisplay.length;\n		},\n	\n		/**\n		 * Get the display end point - aiDisplay index\n		 *  @type function\n		 */\n		\"fnDisplayEnd\": function ()\n		{\n			var\n				len      = this._iDisplayLength,\n				start    = this._iDisplayStart,\n				calc     = start + len,\n				records  = this.aiDisplay.length,\n				features = this.oFeatures,\n				paginate = features.bPaginate;\n	\n			if ( features.bServerSide ) {\n				return paginate === false || len === -1 ?\n					start + records :\n					Math.min( start+len, this._iRecordsDisplay );\n			}\n			else {\n				return ! paginate || calc>records || len===-1 ?\n					records :\n					calc;\n			}\n		},\n	\n		/**\n		 * The DataTables object for this table\n		 *  @type object\n		 *  @default null\n		 */\n		\"oInstance\": null,\n	\n		/**\n		 * Unique identifier for each instance of the DataTables object. If there\n		 * is an ID on the table node, then it takes that value, otherwise an\n		 * incrementing internal counter is used.\n		 *  @type string\n		 *  @default null\n		 */\n		\"sInstance\": null,\n	\n		/**\n		 * tabindex attribute value that is added to DataTables control elements, allowing\n		 * keyboard navigation of the table and its controls.\n		 */\n		\"iTabIndex\": 0,\n	\n		/**\n		 * DIV container for the footer scrolling table if scrolling\n		 */\n		\"nScrollHead\": null,\n	\n		/**\n		 * DIV container for the footer scrolling table if scrolling\n		 */\n		\"nScrollFoot\": null,\n	\n		/**\n		 * Last applied sort\n		 *  @type array\n		 *  @default []\n		 */\n		\"aLastSort\": [],\n	\n		/**\n		 * Stored plug-in instances\n		 *  @type object\n		 *  @default {}\n		 */\n		\"oPlugins\": {},\n	\n		/**\n		 * Function used to get a row's id from the row's data\n		 *  @type function\n		 *  @default null\n		 */\n		\"rowIdFn\": null,\n	\n		/**\n		 * Data location where to store a row's id\n		 *  @type string\n		 *  @default null\n		 */\n		\"rowId\": null\n	};\n\n	/**\n	 * Extension object for DataTables that is used to provide all extension\n	 * options.\n	 *\n	 * Note that the `DataTable.ext` object is available through\n	 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is\n	 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.\n	 *  @namespace\n	 *  @extends DataTable.models.ext\n	 */\n	\n	\n	/**\n	 * DataTables extensions\n	 * \n	 * This namespace acts as a collection area for plug-ins that can be used to\n	 * extend DataTables capabilities. Indeed many of the build in methods\n	 * use this method to provide their own capabilities (sorting methods for\n	 * example).\n	 *\n	 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy\n	 * reasons\n	 *\n	 *  @namespace\n	 */\n	DataTable.ext = _ext = {\n		/**\n		 * Buttons. For use with the Buttons extension for DataTables. This is\n		 * defined here so other extensions can define buttons regardless of load\n		 * order. It is _not_ used by DataTables core.\n		 *\n		 *  @type object\n		 *  @default {}\n		 */\n		buttons: {},\n	\n	\n		/**\n		 * Element class names\n		 *\n		 *  @type object\n		 *  @default {}\n		 */\n		classes: {},\n	\n	\n		/**\n		 * DataTables build type (expanded by the download builder)\n		 *\n		 *  @type string\n		 */\n		builder: \"-source-\",\n	\n	\n		/**\n		 * Error reporting.\n		 * \n		 * How should DataTables report an error. Can take the value 'alert',\n		 * 'throw', 'none' or a function.\n		 *\n		 *  @type string|function\n		 *  @default alert\n		 */\n		errMode: \"alert\",\n	\n	\n		/**\n		 * Feature plug-ins.\n		 * \n		 * This is an array of objects which describe the feature plug-ins that are\n		 * available to DataTables. These feature plug-ins are then available for\n		 * use through the `dom` initialisation option.\n		 * \n		 * Each feature plug-in is described by an object which must have the\n		 * following properties:\n		 * \n		 * * `fnInit` - function that is used to initialise the plug-in,\n		 * * `cFeature` - a character so the feature can be enabled by the `dom`\n		 *   instillation option. This is case sensitive.\n		 *\n		 * The `fnInit` function has the following input parameters:\n		 *\n		 * 1. `{object}` DataTables settings object: see\n		 *    {@link DataTable.models.oSettings}\n		 *\n		 * And the following return is expected:\n		 * \n		 * * {node|null} The element which contains your feature. Note that the\n		 *   return may also be void if your plug-in does not require to inject any\n		 *   DOM elements into DataTables control (`dom`) - for example this might\n		 *   be useful when developing a plug-in which allows table control via\n		 *   keyboard entry\n		 *\n		 *  @type array\n		 *\n		 *  @example\n		 *    $.fn.dataTable.ext.features.push( {\n		 *      \"fnInit\": function( oSettings ) {\n		 *        return new TableTools( { \"oDTSettings\": oSettings } );\n		 *      },\n		 *      \"cFeature\": \"T\"\n		 *    } );\n		 */\n		feature: [],\n	\n	\n		/**\n		 * Row searching.\n		 * \n		 * This method of searching is complimentary to the default type based\n		 * searching, and a lot more comprehensive as it allows you complete control\n		 * over the searching logic. Each element in this array is a function\n		 * (parameters described below) that is called for every row in the table,\n		 * and your logic decides if it should be included in the searching data set\n		 * or not.\n		 *\n		 * Searching functions have the following input parameters:\n		 *\n		 * 1. `{object}` DataTables settings object: see\n		 *    {@link DataTable.models.oSettings}\n		 * 2. `{array|object}` Data for the row to be processed (same as the\n		 *    original format that was passed in as the data source, or an array\n		 *    from a DOM data source\n		 * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which\n		 *    can be useful to retrieve the `TR` element if you need DOM interaction.\n		 *\n		 * And the following return is expected:\n		 *\n		 * * {boolean} Include the row in the searched result set (true) or not\n		 *   (false)\n		 *\n		 * Note that as with the main search ability in DataTables, technically this\n		 * is \"filtering\", since it is subtractive. However, for consistency in\n		 * naming we call it searching here.\n		 *\n		 *  @type array\n		 *  @default []\n		 *\n		 *  @example\n		 *    // The following example shows custom search being applied to the\n		 *    // fourth column (i.e. the data[3] index) based on two input values\n		 *    // from the end-user, matching the data in a certain range.\n		 *    $.fn.dataTable.ext.search.push(\n		 *      function( settings, data, dataIndex ) {\n		 *        var min = document.getElementById('min').value * 1;\n		 *        var max = document.getElementById('max').value * 1;\n		 *        var version = data[3] == \"-\" ? 0 : data[3]*1;\n		 *\n		 *        if ( min == \"\" && max == \"\" ) {\n		 *          return true;\n		 *        }\n		 *        else if ( min == \"\" && version < max ) {\n		 *          return true;\n		 *        }\n		 *        else if ( min < version && \"\" == max ) {\n		 *          return true;\n		 *        }\n		 *        else if ( min < version && version < max ) {\n		 *          return true;\n		 *        }\n		 *        return false;\n		 *      }\n		 *    );\n		 */\n		search: [],\n	\n	\n		/**\n		 * Selector extensions\n		 *\n		 * The `selector` option can be used to extend the options available for the\n		 * selector modifier options (`selector-modifier` object data type) that\n		 * each of the three built in selector types offer (row, column and cell +\n		 * their plural counterparts). For example the Select extension uses this\n		 * mechanism to provide an option to select only rows, columns and cells\n		 * that have been marked as selected by the end user (`{selected: true}`),\n		 * which can be used in conjunction with the existing built in selector\n		 * options.\n		 *\n		 * Each property is an array to which functions can be pushed. The functions\n		 * take three attributes:\n		 *\n		 * * Settings object for the host table\n		 * * Options object (`selector-modifier` object type)\n		 * * Array of selected item indexes\n		 *\n		 * The return is an array of the resulting item indexes after the custom\n		 * selector has been applied.\n		 *\n		 *  @type object\n		 */\n		selector: {\n			cell: [],\n			column: [],\n			row: []\n		},\n	\n	\n		/**\n		 * Internal functions, exposed for used in plug-ins.\n		 * \n		 * Please note that you should not need to use the internal methods for\n		 * anything other than a plug-in (and even then, try to avoid if possible).\n		 * The internal function may change between releases.\n		 *\n		 *  @type object\n		 *  @default {}\n		 */\n		internal: {},\n	\n	\n		/**\n		 * Legacy configuration options. Enable and disable legacy options that\n		 * are available in DataTables.\n		 *\n		 *  @type object\n		 */\n		legacy: {\n			/**\n			 * Enable / disable DataTables 1.9 compatible server-side processing\n			 * requests\n			 *\n			 *  @type boolean\n			 *  @default null\n			 */\n			ajax: null\n		},\n	\n	\n		/**\n		 * Pagination plug-in methods.\n		 * \n		 * Each entry in this object is a function and defines which buttons should\n		 * be shown by the pagination rendering method that is used for the table:\n		 * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the\n		 * buttons are displayed in the document, while the functions here tell it\n		 * what buttons to display. This is done by returning an array of button\n		 * descriptions (what each button will do).\n		 *\n		 * Pagination types (the four built in options and any additional plug-in\n		 * options defined here) can be used through the `paginationType`\n		 * initialisation parameter.\n		 *\n		 * The functions defined take two parameters:\n		 *\n		 * 1. `{int} page` The current page index\n		 * 2. `{int} pages` The number of pages in the table\n		 *\n		 * Each function is expected to return an array where each element of the\n		 * array can be one of:\n		 *\n		 * * `first` - Jump to first page when activated\n		 * * `last` - Jump to last page when activated\n		 * * `previous` - Show previous page when activated\n		 * * `next` - Show next page when activated\n		 * * `{int}` - Show page of the index given\n		 * * `{array}` - A nested array containing the above elements to add a\n		 *   containing 'DIV' element (might be useful for styling).\n		 *\n		 * Note that DataTables v1.9- used this object slightly differently whereby\n		 * an object with two functions would be defined for each plug-in. That\n		 * ability is still supported by DataTables 1.10+ to provide backwards\n		 * compatibility, but this option of use is now decremented and no longer\n		 * documented in DataTables 1.10+.\n		 *\n		 *  @type object\n		 *  @default {}\n		 *\n		 *  @example\n		 *    // Show previous, next and current page buttons only\n		 *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {\n		 *      return [ 'previous', page, 'next' ];\n		 *    };\n		 */\n		pager: {},\n	\n	\n		renderer: {\n			pageButton: {},\n			header: {}\n		},\n	\n	\n		/**\n		 * Ordering plug-ins - custom data source\n		 * \n		 * The extension options for ordering of data available here is complimentary\n		 * to the default type based ordering that DataTables typically uses. It\n		 * allows much greater control over the the data that is being used to\n		 * order a column, but is necessarily therefore more complex.\n		 * \n		 * This type of ordering is useful if you want to do ordering based on data\n		 * live from the DOM (for example the contents of an 'input' element) rather\n		 * than just the static string that DataTables knows of.\n		 * \n		 * The way these plug-ins work is that you create an array of the values you\n		 * wish to be ordering for the column in question and then return that\n		 * array. The data in the array much be in the index order of the rows in\n		 * the table (not the currently ordering order!). Which order data gathering\n		 * function is run here depends on the `dt-init columns.orderDataType`\n		 * parameter that is used for the column (if any).\n		 *\n		 * The functions defined take two parameters:\n		 *\n		 * 1. `{object}` DataTables settings object: see\n		 *    {@link DataTable.models.oSettings}\n		 * 2. `{int}` Target column index\n		 *\n		 * Each function is expected to return an array:\n		 *\n		 * * `{array}` Data for the column to be ordering upon\n		 *\n		 *  @type array\n		 *\n		 *  @example\n		 *    // Ordering using `input` node values\n		 *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )\n		 *    {\n		 *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {\n		 *        return $('input', td).val();\n		 *      } );\n		 *    }\n		 */\n		order: {},\n	\n	\n		/**\n		 * Type based plug-ins.\n		 *\n		 * Each column in DataTables has a type assigned to it, either by automatic\n		 * detection or by direct assignment using the `type` option for the column.\n		 * The type of a column will effect how it is ordering and search (plug-ins\n		 * can also make use of the column type if required).\n		 *\n		 * @namespace\n		 */\n		type: {\n			/**\n			 * Type detection functions.\n			 *\n			 * The functions defined in this object are used to automatically detect\n			 * a column's type, making initialisation of DataTables super easy, even\n			 * when complex data is in the table.\n			 *\n			 * The functions defined take two parameters:\n			 *\n		     *  1. `{*}` Data from the column cell to be analysed\n		     *  2. `{settings}` DataTables settings object. This can be used to\n		     *     perform context specific type detection - for example detection\n		     *     based on language settings such as using a comma for a decimal\n		     *     place. Generally speaking the options from the settings will not\n		     *     be required\n			 *\n			 * Each function is expected to return:\n			 *\n			 * * `{string|null}` Data type detected, or null if unknown (and thus\n			 *   pass it on to the other type detection functions.\n			 *\n			 *  @type array\n			 *\n			 *  @example\n			 *    // Currency type detection plug-in:\n			 *    $.fn.dataTable.ext.type.detect.push(\n			 *      function ( data, settings ) {\n			 *        // Check the numeric part\n			 *        if ( ! $.isNumeric( data.substring(1) ) ) {\n			 *          return null;\n			 *        }\n			 *\n			 *        // Check prefixed by currency\n			 *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {\n			 *          return 'currency';\n			 *        }\n			 *        return null;\n			 *      }\n			 *    );\n			 */\n			detect: [],\n	\n	\n			/**\n			 * Type based search formatting.\n			 *\n			 * The type based searching functions can be used to pre-format the\n			 * data to be search on. For example, it can be used to strip HTML\n			 * tags or to de-format telephone numbers for numeric only searching.\n			 *\n			 * Note that is a search is not defined for a column of a given type,\n			 * no search formatting will be performed.\n			 * \n			 * Pre-processing of searching data plug-ins - When you assign the sType\n			 * for a column (or have it automatically detected for you by DataTables\n			 * or a type detection plug-in), you will typically be using this for\n			 * custom sorting, but it can also be used to provide custom searching\n			 * by allowing you to pre-processing the data and returning the data in\n			 * the format that should be searched upon. This is done by adding\n			 * functions this object with a parameter name which matches the sType\n			 * for that target column. This is the corollary of <i>afnSortData</i>\n			 * for searching data.\n			 *\n			 * The functions defined take a single parameter:\n			 *\n		     *  1. `{*}` Data from the column cell to be prepared for searching\n			 *\n			 * Each function is expected to return:\n			 *\n			 * * `{string|null}` Formatted string that will be used for the searching.\n			 *\n			 *  @type object\n			 *  @default {}\n			 *\n			 *  @example\n			 *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {\n			 *      return d.replace(/\\n/g,\" \").replace( /<.*?>/g, \"\" );\n			 *    }\n			 */\n			search: {},\n	\n	\n			/**\n			 * Type based ordering.\n			 *\n			 * The column type tells DataTables what ordering to apply to the table\n			 * when a column is sorted upon. The order for each type that is defined,\n			 * is defined by the functions available in this object.\n			 *\n			 * Each ordering option can be described by three properties added to\n			 * this object:\n			 *\n			 * * `{type}-pre` - Pre-formatting function\n			 * * `{type}-asc` - Ascending order function\n			 * * `{type}-desc` - Descending order function\n			 *\n			 * All three can be used together, only `{type}-pre` or only\n			 * `{type}-asc` and `{type}-desc` together. It is generally recommended\n			 * that only `{type}-pre` is used, as this provides the optimal\n			 * implementation in terms of speed, although the others are provided\n			 * for compatibility with existing Javascript sort functions.\n			 *\n			 * `{type}-pre`: Functions defined take a single parameter:\n			 *\n		     *  1. `{*}` Data from the column cell to be prepared for ordering\n			 *\n			 * And return:\n			 *\n			 * * `{*}` Data to be sorted upon\n			 *\n			 * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort\n			 * functions, taking two parameters:\n			 *\n		     *  1. `{*}` Data to compare to the second parameter\n		     *  2. `{*}` Data to compare to the first parameter\n			 *\n			 * And returning:\n			 *\n			 * * `{*}` Ordering match: <0 if first parameter should be sorted lower\n			 *   than the second parameter, ===0 if the two parameters are equal and\n			 *   >0 if the first parameter should be sorted height than the second\n			 *   parameter.\n			 * \n			 *  @type object\n			 *  @default {}\n			 *\n			 *  @example\n			 *    // Numeric ordering of formatted numbers with a pre-formatter\n			 *    $.extend( $.fn.dataTable.ext.type.order, {\n			 *      \"string-pre\": function(x) {\n			 *        a = (a === \"-\" || a === \"\") ? 0 : a.replace( /[^\\d\\-\\.]/g, \"\" );\n			 *        return parseFloat( a );\n			 *      }\n			 *    } );\n			 *\n			 *  @example\n			 *    // Case-sensitive string ordering, with no pre-formatting method\n			 *    $.extend( $.fn.dataTable.ext.order, {\n			 *      \"string-case-asc\": function(x,y) {\n			 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n			 *      },\n			 *      \"string-case-desc\": function(x,y) {\n			 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));\n			 *      }\n			 *    } );\n			 */\n			order: {}\n		},\n	\n		/**\n		 * Unique DataTables instance counter\n		 *\n		 * @type int\n		 * @private\n		 */\n		_unique: 0,\n	\n	\n		//\n		// Depreciated\n		// The following properties are retained for backwards compatiblity only.\n		// The should not be used in new projects and will be removed in a future\n		// version\n		//\n	\n		/**\n		 * Version check function.\n		 *  @type function\n		 *  @depreciated Since 1.10\n		 */\n		fnVersionCheck: DataTable.fnVersionCheck,\n	\n	\n		/**\n		 * Index for what 'this' index API functions should use\n		 *  @type int\n		 *  @deprecated Since v1.10\n		 */\n		iApiIndex: 0,\n	\n	\n		/**\n		 * jQuery UI class container\n		 *  @type object\n		 *  @deprecated Since v1.10\n		 */\n		oJUIClasses: {},\n	\n	\n		/**\n		 * Software version\n		 *  @type string\n		 *  @deprecated Since v1.10\n		 */\n		sVersion: DataTable.version\n	};\n	\n	\n	//\n	// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts\n	//\n	$.extend( _ext, {\n		afnFiltering: _ext.search,\n		aTypes:       _ext.type.detect,\n		ofnSearch:    _ext.type.search,\n		oSort:        _ext.type.order,\n		afnSortData:  _ext.order,\n		aoFeatures:   _ext.feature,\n		oApi:         _ext.internal,\n		oStdClasses:  _ext.classes,\n		oPagination:  _ext.pager\n	} );\n	\n	\n	$.extend( DataTable.ext.classes, {\n		\"sTable\": \"dataTable\",\n		\"sNoFooter\": \"no-footer\",\n	\n		/* Paging buttons */\n		\"sPageButton\": \"paginate_button\",\n		\"sPageButtonActive\": \"current\",\n		\"sPageButtonDisabled\": \"disabled\",\n	\n		/* Striping classes */\n		\"sStripeOdd\": \"odd\",\n		\"sStripeEven\": \"even\",\n	\n		/* Empty row */\n		\"sRowEmpty\": \"dataTables_empty\",\n	\n		/* Features */\n		\"sWrapper\": \"dataTables_wrapper\",\n		\"sFilter\": \"dataTables_filter\",\n		\"sInfo\": \"dataTables_info\",\n		\"sPaging\": \"dataTables_paginate paging_\", /* Note that the type is postfixed */\n		\"sLength\": \"dataTables_length\",\n		\"sProcessing\": \"dataTables_processing\",\n	\n		/* Sorting */\n		\"sSortAsc\": \"sorting_asc\",\n		\"sSortDesc\": \"sorting_desc\",\n		\"sSortable\": \"sorting\", /* Sortable in both directions */\n		\"sSortableAsc\": \"sorting_asc_disabled\",\n		\"sSortableDesc\": \"sorting_desc_disabled\",\n		\"sSortableNone\": \"sorting_disabled\",\n		\"sSortColumn\": \"sorting_\", /* Note that an int is postfixed for the sorting order */\n	\n		/* Filtering */\n		\"sFilterInput\": \"\",\n	\n		/* Page length */\n		\"sLengthSelect\": \"\",\n	\n		/* Scrolling */\n		\"sScrollWrapper\": \"dataTables_scroll\",\n		\"sScrollHead\": \"dataTables_scrollHead\",\n		\"sScrollHeadInner\": \"dataTables_scrollHeadInner\",\n		\"sScrollBody\": \"dataTables_scrollBody\",\n		\"sScrollFoot\": \"dataTables_scrollFoot\",\n		\"sScrollFootInner\": \"dataTables_scrollFootInner\",\n	\n		/* Misc */\n		\"sHeaderTH\": \"\",\n		\"sFooterTH\": \"\",\n	\n		// Deprecated\n		\"sSortJUIAsc\": \"\",\n		\"sSortJUIDesc\": \"\",\n		\"sSortJUI\": \"\",\n		\"sSortJUIAscAllowed\": \"\",\n		\"sSortJUIDescAllowed\": \"\",\n		\"sSortJUIWrapper\": \"\",\n		\"sSortIcon\": \"\",\n		\"sJUIHeader\": \"\",\n		\"sJUIFooter\": \"\"\n	} );\n	\n	\n	(function() {\n	\n	// Reused strings for better compression. Closure compiler appears to have a\n	// weird edge case where it is trying to expand strings rather than use the\n	// variable version. This results in about 200 bytes being added, for very\n	// little preference benefit since it this run on script load only.\n	var _empty = '';\n	_empty = '';\n	\n	var _stateDefault = _empty + 'ui-state-default';\n	var _sortIcon     = _empty + 'css_right ui-icon ui-icon-';\n	var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix';\n	\n	$.extend( DataTable.ext.oJUIClasses, DataTable.ext.classes, {\n		/* Full numbers paging buttons */\n		\"sPageButton\":         \"fg-button ui-button \"+_stateDefault,\n		\"sPageButtonActive\":   \"ui-state-disabled\",\n		\"sPageButtonDisabled\": \"ui-state-disabled\",\n	\n		/* Features */\n		\"sPaging\": \"dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi \"+\n			\"ui-buttonset-multi paging_\", /* Note that the type is postfixed */\n	\n		/* Sorting */\n		\"sSortAsc\":            _stateDefault+\" sorting_asc\",\n		\"sSortDesc\":           _stateDefault+\" sorting_desc\",\n		\"sSortable\":           _stateDefault+\" sorting\",\n		\"sSortableAsc\":        _stateDefault+\" sorting_asc_disabled\",\n		\"sSortableDesc\":       _stateDefault+\" sorting_desc_disabled\",\n		\"sSortableNone\":       _stateDefault+\" sorting_disabled\",\n		\"sSortJUIAsc\":         _sortIcon+\"triangle-1-n\",\n		\"sSortJUIDesc\":        _sortIcon+\"triangle-1-s\",\n		\"sSortJUI\":            _sortIcon+\"carat-2-n-s\",\n		\"sSortJUIAscAllowed\":  _sortIcon+\"carat-1-n\",\n		\"sSortJUIDescAllowed\": _sortIcon+\"carat-1-s\",\n		\"sSortJUIWrapper\":     \"DataTables_sort_wrapper\",\n		\"sSortIcon\":           \"DataTables_sort_icon\",\n	\n		/* Scrolling */\n		\"sScrollHead\": \"dataTables_scrollHead \"+_stateDefault,\n		\"sScrollFoot\": \"dataTables_scrollFoot \"+_stateDefault,\n	\n		/* Misc */\n		\"sHeaderTH\":  _stateDefault,\n		\"sFooterTH\":  _stateDefault,\n		\"sJUIHeader\": _headerFooter+\" ui-corner-tl ui-corner-tr\",\n		\"sJUIFooter\": _headerFooter+\" ui-corner-bl ui-corner-br\"\n	} );\n	\n	}());\n	\n	\n	\n	var extPagination = DataTable.ext.pager;\n	\n	function _numbers ( page, pages ) {\n		var\n			numbers = [],\n			buttons = extPagination.numbers_length,\n			half = Math.floor( buttons / 2 ),\n			i = 1;\n	\n		if ( pages <= buttons ) {\n			numbers = _range( 0, pages );\n		}\n		else if ( page <= half ) {\n			numbers = _range( 0, buttons-2 );\n			numbers.push( 'ellipsis' );\n			numbers.push( pages-1 );\n		}\n		else if ( page >= pages - 1 - half ) {\n			numbers = _range( pages-(buttons-2), pages );\n			numbers.splice( 0, 0, 'ellipsis' ); // no unshift in ie6\n			numbers.splice( 0, 0, 0 );\n		}\n		else {\n			numbers = _range( page-half+2, page+half-1 );\n			numbers.push( 'ellipsis' );\n			numbers.push( pages-1 );\n			numbers.splice( 0, 0, 'ellipsis' );\n			numbers.splice( 0, 0, 0 );\n		}\n	\n		numbers.DT_el = 'span';\n		return numbers;\n	}\n	\n	\n	$.extend( extPagination, {\n		simple: function ( page, pages ) {\n			return [ 'previous', 'next' ];\n		},\n	\n		full: function ( page, pages ) {\n			return [  'first', 'previous', 'next', 'last' ];\n		},\n	\n		numbers: function ( page, pages ) {\n			return [ _numbers(page, pages) ];\n		},\n	\n		simple_numbers: function ( page, pages ) {\n			return [ 'previous', _numbers(page, pages), 'next' ];\n		},\n	\n		full_numbers: function ( page, pages ) {\n			return [ 'first', 'previous', _numbers(page, pages), 'next', 'last' ];\n		},\n	\n		// For testing and plug-ins to use\n		_numbers: _numbers,\n	\n		// Number of number buttons (including ellipsis) to show. _Must be odd!_\n		numbers_length: 7\n	} );\n	\n	\n	$.extend( true, DataTable.ext.renderer, {\n		pageButton: {\n			_: function ( settings, host, idx, buttons, page, pages ) {\n				var classes = settings.oClasses;\n				var lang = settings.oLanguage.oPaginate;\n				var aria = settings.oLanguage.oAria.paginate || {};\n				var btnDisplay, btnClass, counter=0;\n	\n				var attach = function( container, buttons ) {\n					var i, ien, node, button;\n					var clickHandler = function ( e ) {\n						_fnPageChange( settings, e.data.action, true );\n					};\n	\n					for ( i=0, ien=buttons.length ; i<ien ; i++ ) {\n						button = buttons[i];\n	\n						if ( $.isArray( button ) ) {\n							var inner = $( '<'+(button.DT_el || 'div')+'/>' )\n								.appendTo( container );\n							attach( inner, button );\n						}\n						else {\n							btnDisplay = null;\n							btnClass = '';\n	\n							switch ( button ) {\n								case 'ellipsis':\n									container.append('<span class=\"ellipsis\">&#x2026;</span>');\n									break;\n	\n								case 'first':\n									btnDisplay = lang.sFirst;\n									btnClass = button + (page > 0 ?\n										'' : ' '+classes.sPageButtonDisabled);\n									break;\n	\n								case 'previous':\n									btnDisplay = lang.sPrevious;\n									btnClass = button + (page > 0 ?\n										'' : ' '+classes.sPageButtonDisabled);\n									break;\n	\n								case 'next':\n									btnDisplay = lang.sNext;\n									btnClass = button + (page < pages-1 ?\n										'' : ' '+classes.sPageButtonDisabled);\n									break;\n	\n								case 'last':\n									btnDisplay = lang.sLast;\n									btnClass = button + (page < pages-1 ?\n										'' : ' '+classes.sPageButtonDisabled);\n									break;\n	\n								default:\n									btnDisplay = button + 1;\n									btnClass = page === button ?\n										classes.sPageButtonActive : '';\n									break;\n							}\n	\n							if ( btnDisplay !== null ) {\n								node = $('<a>', {\n										'class': classes.sPageButton+' '+btnClass,\n										'aria-controls': settings.sTableId,\n										'aria-label': aria[ button ],\n										'data-dt-idx': counter,\n										'tabindex': settings.iTabIndex,\n										'id': idx === 0 && typeof button === 'string' ?\n											settings.sTableId +'_'+ button :\n											null\n									} )\n									.html( btnDisplay )\n									.appendTo( container );\n	\n								_fnBindAction(\n									node, {action: button}, clickHandler\n								);\n	\n								counter++;\n							}\n						}\n					}\n				};\n	\n				// IE9 throws an 'unknown error' if document.activeElement is used\n				// inside an iframe or frame. Try / catch the error. Not good for\n				// accessibility, but neither are frames.\n				var activeEl;\n	\n				try {\n					// Because this approach is destroying and recreating the paging\n					// elements, focus is lost on the select button which is bad for\n					// accessibility. So we want to restore focus once the draw has\n					// completed\n					activeEl = $(host).find(document.activeElement).data('dt-idx');\n				}\n				catch (e) {}\n	\n				attach( $(host).empty(), buttons );\n	\n				if ( activeEl ) {\n					$(host).find( '[data-dt-idx='+activeEl+']' ).focus();\n				}\n			}\n		}\n	} );\n	\n	\n	\n	// Built in type detection. See model.ext.aTypes for information about\n	// what is required from this methods.\n	$.extend( DataTable.ext.type.detect, [\n		// Plain numbers - first since V8 detects some plain numbers as dates\n		// e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).\n		function ( d, settings )\n		{\n			var decimal = settings.oLanguage.sDecimal;\n			return _isNumber( d, decimal ) ? 'num'+decimal : null;\n		},\n	\n		// Dates (only those recognised by the browser's Date.parse)\n		function ( d, settings )\n		{\n			// V8 will remove any unknown characters at the start and end of the\n			// expression, leading to false matches such as `$245.12` or `10%` being\n			// a valid date. See forum thread 18941 for detail.\n			if ( d && !(d instanceof Date) && ( ! _re_date_start.test(d) || ! _re_date_end.test(d) ) ) {\n				return null;\n			}\n			var parsed = Date.parse(d);\n			return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;\n		},\n	\n		// Formatted numbers\n		function ( d, settings )\n		{\n			var decimal = settings.oLanguage.sDecimal;\n			return _isNumber( d, decimal, true ) ? 'num-fmt'+decimal : null;\n		},\n	\n		// HTML numeric\n		function ( d, settings )\n		{\n			var decimal = settings.oLanguage.sDecimal;\n			return _htmlNumeric( d, decimal ) ? 'html-num'+decimal : null;\n		},\n	\n		// HTML numeric, formatted\n		function ( d, settings )\n		{\n			var decimal = settings.oLanguage.sDecimal;\n			return _htmlNumeric( d, decimal, true ) ? 'html-num-fmt'+decimal : null;\n		},\n	\n		// HTML (this is strict checking - there must be html)\n		function ( d, settings )\n		{\n			return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1) ?\n				'html' : null;\n		}\n	] );\n	\n	\n	\n	// Filter formatting functions. See model.ext.ofnSearch for information about\n	// what is required from these methods.\n	// \n	// Note that additional search methods are added for the html numbers and\n	// html formatted numbers by `_addNumericSort()` when we know what the decimal\n	// place is\n	\n	\n	$.extend( DataTable.ext.type.search, {\n		html: function ( data ) {\n			return _empty(data) ?\n				data :\n				typeof data === 'string' ?\n					data\n						.replace( _re_new_lines, \" \" )\n						.replace( _re_html, \"\" ) :\n					'';\n		},\n	\n		string: function ( data ) {\n			return _empty(data) ?\n				data :\n				typeof data === 'string' ?\n					data.replace( _re_new_lines, \" \" ) :\n					data;\n		}\n	} );\n	\n	\n	\n	var __numericReplace = function ( d, decimalPlace, re1, re2 ) {\n		if ( d !== 0 && (!d || d === '-') ) {\n			return -Infinity;\n		}\n	\n		// If a decimal place other than `.` is used, it needs to be given to the\n		// function so we can detect it and replace with a `.` which is the only\n		// decimal place Javascript recognises - it is not locale aware.\n		if ( decimalPlace ) {\n			d = _numToDecimal( d, decimalPlace );\n		}\n	\n		if ( d.replace ) {\n			if ( re1 ) {\n				d = d.replace( re1, '' );\n			}\n	\n			if ( re2 ) {\n				d = d.replace( re2, '' );\n			}\n		}\n	\n		return d * 1;\n	};\n	\n	\n	// Add the numeric 'deformatting' functions for sorting and search. This is done\n	// in a function to provide an easy ability for the language options to add\n	// additional methods if a non-period decimal place is used.\n	function _addNumericSort ( decimalPlace ) {\n		$.each(\n			{\n				// Plain numbers\n				\"num\": function ( d ) {\n					return __numericReplace( d, decimalPlace );\n				},\n	\n				// Formatted numbers\n				\"num-fmt\": function ( d ) {\n					return __numericReplace( d, decimalPlace, _re_formatted_numeric );\n				},\n	\n				// HTML numeric\n				\"html-num\": function ( d ) {\n					return __numericReplace( d, decimalPlace, _re_html );\n				},\n	\n				// HTML numeric, formatted\n				\"html-num-fmt\": function ( d ) {\n					return __numericReplace( d, decimalPlace, _re_html, _re_formatted_numeric );\n				}\n			},\n			function ( key, fn ) {\n				// Add the ordering method\n				_ext.type.order[ key+decimalPlace+'-pre' ] = fn;\n	\n				// For HTML types add a search formatter that will strip the HTML\n				if ( key.match(/^html\\-/) ) {\n					_ext.type.search[ key+decimalPlace ] = _ext.type.search.html;\n				}\n			}\n		);\n	}\n	\n	\n	// Default sort methods\n	$.extend( _ext.type.order, {\n		// Dates\n		\"date-pre\": function ( d ) {\n			return Date.parse( d ) || 0;\n		},\n	\n		// html\n		\"html-pre\": function ( a ) {\n			return _empty(a) ?\n				'' :\n				a.replace ?\n					a.replace( /<.*?>/g, \"\" ).toLowerCase() :\n					a+'';\n		},\n	\n		// string\n		\"string-pre\": function ( a ) {\n			// This is a little complex, but faster than always calling toString,\n			// http://jsperf.com/tostring-v-check\n			return _empty(a) ?\n				'' :\n				typeof a === 'string' ?\n					a.toLowerCase() :\n					! a.toString ?\n						'' :\n						a.toString();\n		},\n	\n		// string-asc and -desc are retained only for compatibility with the old\n		// sort methods\n		\"string-asc\": function ( x, y ) {\n			return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n		},\n	\n		\"string-desc\": function ( x, y ) {\n			return ((x < y) ? 1 : ((x > y) ? -1 : 0));\n		}\n	} );\n	\n	\n	// Numeric sorting types - order doesn't matter here\n	_addNumericSort( '' );\n	\n	\n	$.extend( true, DataTable.ext.renderer, {\n		header: {\n			_: function ( settings, cell, column, classes ) {\n				// No additional mark-up required\n				// Attach a sort listener to update on sort - note that using the\n				// `DT` namespace will allow the event to be removed automatically\n				// on destroy, while the `dt` namespaced event is the one we are\n				// listening for\n				$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {\n					if ( settings !== ctx ) { // need to check this this is the host\n						return;               // table, not a nested one\n					}\n	\n					var colIdx = column.idx;\n	\n					cell\n						.removeClass(\n							column.sSortingClass +' '+\n							classes.sSortAsc +' '+\n							classes.sSortDesc\n						)\n						.addClass( columns[ colIdx ] == 'asc' ?\n							classes.sSortAsc : columns[ colIdx ] == 'desc' ?\n								classes.sSortDesc :\n								column.sSortingClass\n						);\n				} );\n			},\n	\n			jqueryui: function ( settings, cell, column, classes ) {\n				$('<div/>')\n					.addClass( classes.sSortJUIWrapper )\n					.append( cell.contents() )\n					.append( $('<span/>')\n						.addClass( classes.sSortIcon+' '+column.sSortingClassJUI )\n					)\n					.appendTo( cell );\n	\n				// Attach a sort listener to update on sort\n				$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {\n					if ( settings !== ctx ) {\n						return;\n					}\n	\n					var colIdx = column.idx;\n	\n					cell\n						.removeClass( classes.sSortAsc +\" \"+classes.sSortDesc )\n						.addClass( columns[ colIdx ] == 'asc' ?\n							classes.sSortAsc : columns[ colIdx ] == 'desc' ?\n								classes.sSortDesc :\n								column.sSortingClass\n						);\n	\n					cell\n						.find( 'span.'+classes.sSortIcon )\n						.removeClass(\n							classes.sSortJUIAsc +\" \"+\n							classes.sSortJUIDesc +\" \"+\n							classes.sSortJUI +\" \"+\n							classes.sSortJUIAscAllowed +\" \"+\n							classes.sSortJUIDescAllowed\n						)\n						.addClass( columns[ colIdx ] == 'asc' ?\n							classes.sSortJUIAsc : columns[ colIdx ] == 'desc' ?\n								classes.sSortJUIDesc :\n								column.sSortingClassJUI\n						);\n				} );\n			}\n		}\n	} );\n	\n	/*\n	 * Public helper functions. These aren't used internally by DataTables, or\n	 * called by any of the options passed into DataTables, but they can be used\n	 * externally by developers working with DataTables. They are helper functions\n	 * to make working with DataTables a little bit easier.\n	 */\n	\n	/**\n	 * Helpers for `columns.render`.\n	 *\n	 * The options defined here can be used with the `columns.render` initialisation\n	 * option to provide a display renderer. The following functions are defined:\n	 *\n	 * * `number` - Will format numeric data (defined by `columns.data`) for\n	 *   display, retaining the original unformatted data for sorting and filtering.\n	 *   It takes 5 parameters:\n	 *   * `string` - Thousands grouping separator\n	 *   * `string` - Decimal point indicator\n	 *   * `integer` - Number of decimal points to show\n	 *   * `string` (optional) - Prefix.\n	 *   * `string` (optional) - Postfix (/suffix).\n	 * * `text` - Escape HTML to help prevent XSS attacks. It has no optional\n	 *   parameters.\n	 *\n	 * @example\n	 *   // Column definition using the number renderer\n	 *   {\n	 *     data: \"salary\",\n	 *     render: $.fn.dataTable.render.number( '\\'', '.', 0, '$' )\n	 *   }\n	 *\n	 * @namespace\n	 */\n	DataTable.render = {\n		number: function ( thousands, decimal, precision, prefix, postfix ) {\n			return {\n				display: function ( d ) {\n					if ( typeof d !== 'number' && typeof d !== 'string' ) {\n						return d;\n					}\n	\n					var negative = d < 0 ? '-' : '';\n					var flo = parseFloat( d );\n	\n					// If NaN then there isn't much formatting that we can do - just\n					// return immediately\n					if ( isNaN( flo ) ) {\n						return d;\n					}\n	\n					d = Math.abs( flo );\n	\n					var intPart = parseInt( d, 10 );\n					var floatPart = precision ?\n						decimal+(d - intPart).toFixed( precision ).substring( 2 ):\n						'';\n	\n					return negative + (prefix||'') +\n						intPart.toString().replace(\n							/\\B(?=(\\d{3})+(?!\\d))/g, thousands\n						) +\n						floatPart +\n						(postfix||'');\n				}\n			};\n		},\n	\n		text: function () {\n			return {\n				display: function ( d ) {\n					return typeof d === 'string' ?\n						d.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;') :\n						d;\n				}\n			};\n		}\n	};\n	\n	\n	/*\n	 * This is really a good bit rubbish this method of exposing the internal methods\n	 * publicly... - To be fixed in 2.0 using methods on the prototype\n	 */\n	\n	\n	/**\n	 * Create a wrapper function for exporting an internal functions to an external API.\n	 *  @param {string} fn API function name\n	 *  @returns {function} wrapped function\n	 *  @memberof DataTable#internal\n	 */\n	function _fnExternApiFunc (fn)\n	{\n		return function() {\n			var args = [_fnSettingsFromNode( this[DataTable.ext.iApiIndex] )].concat(\n				Array.prototype.slice.call(arguments)\n			);\n			return DataTable.ext.internal[fn].apply( this, args );\n		};\n	}\n	\n	\n	/**\n	 * Reference to internal functions for use by plug-in developers. Note that\n	 * these methods are references to internal functions and are considered to be\n	 * private. If you use these methods, be aware that they are liable to change\n	 * between versions.\n	 *  @namespace\n	 */\n	$.extend( DataTable.ext.internal, {\n		_fnExternApiFunc: _fnExternApiFunc,\n		_fnBuildAjax: _fnBuildAjax,\n		_fnAjaxUpdate: _fnAjaxUpdate,\n		_fnAjaxParameters: _fnAjaxParameters,\n		_fnAjaxUpdateDraw: _fnAjaxUpdateDraw,\n		_fnAjaxDataSrc: _fnAjaxDataSrc,\n		_fnAddColumn: _fnAddColumn,\n		_fnColumnOptions: _fnColumnOptions,\n		_fnAdjustColumnSizing: _fnAdjustColumnSizing,\n		_fnVisibleToColumnIndex: _fnVisibleToColumnIndex,\n		_fnColumnIndexToVisible: _fnColumnIndexToVisible,\n		_fnVisbleColumns: _fnVisbleColumns,\n		_fnGetColumns: _fnGetColumns,\n		_fnColumnTypes: _fnColumnTypes,\n		_fnApplyColumnDefs: _fnApplyColumnDefs,\n		_fnHungarianMap: _fnHungarianMap,\n		_fnCamelToHungarian: _fnCamelToHungarian,\n		_fnLanguageCompat: _fnLanguageCompat,\n		_fnBrowserDetect: _fnBrowserDetect,\n		_fnAddData: _fnAddData,\n		_fnAddTr: _fnAddTr,\n		_fnNodeToDataIndex: _fnNodeToDataIndex,\n		_fnNodeToColumnIndex: _fnNodeToColumnIndex,\n		_fnGetCellData: _fnGetCellData,\n		_fnSetCellData: _fnSetCellData,\n		_fnSplitObjNotation: _fnSplitObjNotation,\n		_fnGetObjectDataFn: _fnGetObjectDataFn,\n		_fnSetObjectDataFn: _fnSetObjectDataFn,\n		_fnGetDataMaster: _fnGetDataMaster,\n		_fnClearTable: _fnClearTable,\n		_fnDeleteIndex: _fnDeleteIndex,\n		_fnInvalidate: _fnInvalidate,\n		_fnGetRowElements: _fnGetRowElements,\n		_fnCreateTr: _fnCreateTr,\n		_fnBuildHead: _fnBuildHead,\n		_fnDrawHead: _fnDrawHead,\n		_fnDraw: _fnDraw,\n		_fnReDraw: _fnReDraw,\n		_fnAddOptionsHtml: _fnAddOptionsHtml,\n		_fnDetectHeader: _fnDetectHeader,\n		_fnGetUniqueThs: _fnGetUniqueThs,\n		_fnFeatureHtmlFilter: _fnFeatureHtmlFilter,\n		_fnFilterComplete: _fnFilterComplete,\n		_fnFilterCustom: _fnFilterCustom,\n		_fnFilterColumn: _fnFilterColumn,\n		_fnFilter: _fnFilter,\n		_fnFilterCreateSearch: _fnFilterCreateSearch,\n		_fnEscapeRegex: _fnEscapeRegex,\n		_fnFilterData: _fnFilterData,\n		_fnFeatureHtmlInfo: _fnFeatureHtmlInfo,\n		_fnUpdateInfo: _fnUpdateInfo,\n		_fnInfoMacros: _fnInfoMacros,\n		_fnInitialise: _fnInitialise,\n		_fnInitComplete: _fnInitComplete,\n		_fnLengthChange: _fnLengthChange,\n		_fnFeatureHtmlLength: _fnFeatureHtmlLength,\n		_fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,\n		_fnPageChange: _fnPageChange,\n		_fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,\n		_fnProcessingDisplay: _fnProcessingDisplay,\n		_fnFeatureHtmlTable: _fnFeatureHtmlTable,\n		_fnScrollDraw: _fnScrollDraw,\n		_fnApplyToChildren: _fnApplyToChildren,\n		_fnCalculateColumnWidths: _fnCalculateColumnWidths,\n		_fnThrottle: _fnThrottle,\n		_fnConvertToWidth: _fnConvertToWidth,\n		_fnGetWidestNode: _fnGetWidestNode,\n		_fnGetMaxLenString: _fnGetMaxLenString,\n		_fnStringToCss: _fnStringToCss,\n		_fnSortFlatten: _fnSortFlatten,\n		_fnSort: _fnSort,\n		_fnSortAria: _fnSortAria,\n		_fnSortListener: _fnSortListener,\n		_fnSortAttachListener: _fnSortAttachListener,\n		_fnSortingClasses: _fnSortingClasses,\n		_fnSortData: _fnSortData,\n		_fnSaveState: _fnSaveState,\n		_fnLoadState: _fnLoadState,\n		_fnSettingsFromNode: _fnSettingsFromNode,\n		_fnLog: _fnLog,\n		_fnMap: _fnMap,\n		_fnBindAction: _fnBindAction,\n		_fnCallbackReg: _fnCallbackReg,\n		_fnCallbackFire: _fnCallbackFire,\n		_fnLengthOverflow: _fnLengthOverflow,\n		_fnRenderer: _fnRenderer,\n		_fnDataSource: _fnDataSource,\n		_fnRowAttributes: _fnRowAttributes,\n		_fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant\n		                                // in 1.10, so this dead-end function is\n		                                // added to prevent errors\n	} );\n	\n\n	// jQuery access\n	$.fn.dataTable = DataTable;\n\n	// Provide access to the host jQuery object (circular reference)\n	DataTable.$ = $;\n\n	// Legacy aliases\n	$.fn.dataTableSettings = DataTable.settings;\n	$.fn.dataTableExt = DataTable.ext;\n\n	// With a capital `D` we return a DataTables API instance rather than a\n	// jQuery object\n	$.fn.DataTable = function ( opts ) {\n		return $(this).dataTable( opts ).api();\n	};\n\n	// All properties that are available to $.fn.dataTable should also be\n	// available on $.fn.DataTable\n	$.each( DataTable, function ( prop, val ) {\n		$.fn.DataTable[ prop ] = val;\n	} );\n\n\n	// Information about events fired by DataTables - for documentation.\n	/**\n	 * Draw event, fired whenever the table is redrawn on the page, at the same\n	 * point as fnDrawCallback. This may be useful for binding events or\n	 * performing calculations when the table is altered at all.\n	 *  @name DataTable#draw.dt\n	 *  @event\n	 *  @param {event} e jQuery event object\n	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n	 */\n\n	/**\n	 * Search event, fired when the searching applied to the table (using the\n	 * built-in global search, or column filters) is altered.\n	 *  @name DataTable#search.dt\n	 *  @event\n	 *  @param {event} e jQuery event object\n	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n	 */\n\n	/**\n	 * Page change event, fired when the paging of the table is altered.\n	 *  @name DataTable#page.dt\n	 *  @event\n	 *  @param {event} e jQuery event object\n	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n	 */\n\n	/**\n	 * Order event, fired when the ordering applied to the table is altered.\n	 *  @name DataTable#order.dt\n	 *  @event\n	 *  @param {event} e jQuery event object\n	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n	 */\n\n	/**\n	 * DataTables initialisation complete event, fired when the table is fully\n	 * drawn, including Ajax data loaded, if Ajax data is required.\n	 *  @name DataTable#init.dt\n	 *  @event\n	 *  @param {event} e jQuery event object\n	 *  @param {object} oSettings DataTables settings object\n	 *  @param {object} json The JSON object request from the server - only\n	 *    present if client-side Ajax sourced data is used</li></ol>\n	 */\n\n	/**\n	 * State save event, fired when the table has changed state a new state save\n	 * is required. This event allows modification of the state saving object\n	 * prior to actually doing the save, including addition or other state\n	 * properties (for plug-ins) or modification of a DataTables core property.\n	 *  @name DataTable#stateSaveParams.dt\n	 *  @event\n	 *  @param {event} e jQuery event object\n	 *  @param {object} oSettings DataTables settings object\n	 *  @param {object} json The state information to be saved\n	 */\n\n	/**\n	 * State load event, fired when the table is loading state from the stored\n	 * data, but prior to the settings object being modified by the saved state\n	 * - allowing modification of the saved state is required or loading of\n	 * state for a plug-in.\n	 *  @name DataTable#stateLoadParams.dt\n	 *  @event\n	 *  @param {event} e jQuery event object\n	 *  @param {object} oSettings DataTables settings object\n	 *  @param {object} json The saved state information\n	 */\n\n	/**\n	 * State loaded event, fired when state has been loaded from stored data and\n	 * the settings object has been modified by the loaded data.\n	 *  @name DataTable#stateLoaded.dt\n	 *  @event\n	 *  @param {event} e jQuery event object\n	 *  @param {object} oSettings DataTables settings object\n	 *  @param {object} json The saved state information\n	 */\n\n	/**\n	 * Processing event, fired when DataTables is doing some kind of processing\n	 * (be it, order, searcg or anything else). It can be used to indicate to\n	 * the end user that there is something happening, or that something has\n	 * finished.\n	 *  @name DataTable#processing.dt\n	 *  @event\n	 *  @param {event} e jQuery event object\n	 *  @param {object} oSettings DataTables settings object\n	 *  @param {boolean} bShow Flag for if DataTables is doing processing or not\n	 */\n\n	/**\n	 * Ajax (XHR) event, fired whenever an Ajax request is completed from a\n	 * request to made to the server for new data. This event is called before\n	 * DataTables processed the returned data, so it can also be used to pre-\n	 * process the data returned from the server, if needed.\n	 *\n	 * Note that this trigger is called in `fnServerData`, if you override\n	 * `fnServerData` and which to use this event, you need to trigger it in you\n	 * success function.\n	 *  @name DataTable#xhr.dt\n	 *  @event\n	 *  @param {event} e jQuery event object\n	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n	 *  @param {object} json JSON returned from the server\n	 *\n	 *  @example\n	 *     // Use a custom property returned from the server in another DOM element\n	 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {\n	 *       $('#status').html( json.status );\n	 *     } );\n	 *\n	 *  @example\n	 *     // Pre-process the data returned from the server\n	 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {\n	 *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {\n	 *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;\n	 *       }\n	 *       // Note no return - manipulate the data directly in the JSON object.\n	 *     } );\n	 */\n\n	/**\n	 * Destroy event, fired when the DataTable is destroyed by calling fnDestroy\n	 * or passing the bDestroy:true parameter in the initialisation object. This\n	 * can be used to remove bound events, added DOM nodes, etc.\n	 *  @name DataTable#destroy.dt\n	 *  @event\n	 *  @param {event} e jQuery event object\n	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n	 */\n\n	/**\n	 * Page length change event, fired when number of records to show on each\n	 * page (the length) is changed.\n	 *  @name DataTable#length.dt\n	 *  @event\n	 *  @param {event} e jQuery event object\n	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n	 *  @param {integer} len New length\n	 */\n\n	/**\n	 * Column sizing has changed.\n	 *  @name DataTable#column-sizing.dt\n	 *  @event\n	 *  @param {event} e jQuery event object\n	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n	 */\n\n	/**\n	 * Column visibility has changed.\n	 *  @name DataTable#column-visibility.dt\n	 *  @event\n	 *  @param {event} e jQuery event object\n	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n	 *  @param {int} column Column index\n	 *  @param {bool} vis `false` if column now hidden, or `true` if visible\n	 */\n\n	return $.fn.dataTable;\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datatables.net/js/jquery.dataTables.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/datatables.net/js/jquery.dataTables.js?");
},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {'use strict';\n\n__webpack_require__(12);\n\n__webpack_require__(14);\n\n__webpack_require__(13);\n\n__webpack_require__(9);\n\n__webpack_require__(6);\n\n__webpack_require__(5);\n\n__webpack_require__(4);\n\n__webpack_require__(17);\n\n__webpack_require__(8);\n\n__webpack_require__(7);\n\n__webpack_require__(20);\n__webpack_require__(19);\n__webpack_require__(18);\n\nvar $ = __webpack_require__(1);\n__webpack_provided_window_dot_jQuery = $;\nwindow.$ = $;\n\nconsole.log('Hello from Genomix app!');\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/app.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/app.js?")},function(module,exports){eval("'use strict'\n\n/*! matchMedia() polyfill addListener/removeListener extension. Author & copyright (c) 2012: Scott Jehl. Dual MIT/BSD license */\n;\n(function () {\n    // Bail out for browsers that have addListener support\n    if (window.matchMedia && window.matchMedia('all').addListener) {\n        return false;\n    }\n\n    var localMatchMedia = window.matchMedia,\n        hasMediaQueries = localMatchMedia('only all').matches,\n        isListening = false,\n        timeoutID = 0,\n\n    // setTimeout for debouncing 'handleChange'\n    queries = [],\n\n    // Contains each 'mql' and associated 'listeners' if 'addListener' is used\n    handleChange = function handleChange(evt) {\n        // Debounce\n        clearTimeout(timeoutID);\n\n        timeoutID = setTimeout(function () {\n            for (var i = 0, il = queries.length; i < il; i++) {\n                var mql = queries[i].mql,\n                    listeners = queries[i].listeners || [],\n                    matches = localMatchMedia(mql.media).matches;\n\n                // Update mql.matches value and call listeners\n                // Fire listeners only if transitioning to or from matched state\n                if (matches !== mql.matches) {\n                    mql.matches = matches;\n\n                    for (var j = 0, jl = listeners.length; j < jl; j++) {\n                        listeners[j].call(window, mql);\n                    }\n                }\n            }\n        }, 30);\n    };\n\n    window.matchMedia = function (media) {\n        var mql = localMatchMedia(media),\n            listeners = [],\n            index = 0;\n\n        mql.addListener = function (listener) {\n            // Changes would not occur to css media type so return now (Affects IE <= 8)\n            if (!hasMediaQueries) {\n                return;\n            }\n\n            // Set up 'resize' listener for browsers that support CSS3 media queries (Not for IE <= 8)\n            // There should only ever be 1 resize listener running for performance\n            if (!isListening) {\n                isListening = true;\n                window.addEventListener('resize', handleChange, true);\n            }\n\n            // Push object only if it has not been pushed already\n            if (index === 0) {\n                index = queries.push({\n                    mql: mql,\n                    listeners: listeners\n                });\n            }\n\n            listeners.push(listener);\n        };\n\n        mql.removeListener = function (listener) {\n            for (var i = 0, il = listeners.length; i < il; i++) {\n                if (listeners[i] === listener) {\n                    listeners.splice(i, 1);\n                }\n            }\n        };\n\n        return mql;\n    };\n})();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/assets/vendor/matchMedia/matchMedia.addListener.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/assets/vendor/matchMedia/matchMedia.addListener.js?")},function(module,exports){eval("'use strict'\n\n/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */\n\n;\nwindow.matchMedia || (window.matchMedia = (function () {\n    \"use strict\"\n\n    // For browsers that support matchMedium api such as IE 9 and webkit\n    ;\n\n    var styleMedia = window.styleMedia || window.media;\n\n    // For those that don't support matchMedium\n    if (!styleMedia) {\n        var style = document.createElement('style'),\n            script = document.getElementsByTagName('script')[0],\n            info = null;\n\n        style.type = 'text/css';\n        style.id = 'matchmediajs-test';\n\n        script.parentNode.insertBefore(style, script);\n\n        // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\n        info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;\n\n        styleMedia = {\n            matchMedium: function matchMedium(media) {\n                var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';\n\n                // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\n                if (style.styleSheet) {\n                    style.styleSheet.cssText = text;\n                } else {\n                    style.textContent = text;\n                }\n\n                // Test if media query is true or false\n                return info.width === '1px';\n            }\n        };\n    }\n\n    return function (media) {\n        return {\n            matches: styleMedia.matchMedium(media || 'all'),\n            media: media || 'all'\n        };\n    };\n})());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/assets/vendor/matchMedia/matchMedia.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/assets/vendor/matchMedia/matchMedia.js?")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function($) {"use strict";\n\nfunction _typeof(obj) {\n  return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;\n}\n\n/*! Select2 4.0.1-rc.1 | https://github.com/select2/select2/blob/master/LICENSE.md */!(function (a) {\n   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (a), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : a("object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? require("jquery") : jQuery);\n})(function (a) {\n  var b = (function () {\n    if (a && a.fn && a.fn.select2 && a.fn.select2.amd) var b = a.fn.select2.amd;var b;return (function () {\n      if (!b || !b.requirejs) {\n        b ? c = b : b = {};var a, c, d;!(function (b) {\n          function e(a, b) {\n            return u.call(a, b);\n          }function f(a, b) {\n            var c,\n                d,\n                e,\n                f,\n                g,\n                h,\n                i,\n                j,\n                k,\n                l,\n                m,\n                n = b && b.split("/"),\n                o = s.map,\n                p = o && o["*"] || {};if (a && "." === a.charAt(0)) if (b) {\n              for (n = n.slice(0, n.length - 1), a = a.split("/"), g = a.length - 1, s.nodeIdCompat && w.test(a[g]) && (a[g] = a[g].replace(w, "")), a = n.concat(a), k = 0; k < a.length; k += 1) {\n                if ((m = a[k], "." === m)) a.splice(k, 1), k -= 1;else if (".." === m) {\n                  if (1 === k && (".." === a[2] || ".." === a[0])) break;k > 0 && (a.splice(k - 1, 2), k -= 2);\n                }\n              }a = a.join("/");\n            } else 0 === a.indexOf("./") && (a = a.substring(2));if ((n || p) && o) {\n              for (c = a.split("/"), k = c.length; k > 0; k -= 1) {\n                if ((d = c.slice(0, k).join("/"), n)) for (l = n.length; l > 0; l -= 1) {\n                  if ((e = o[n.slice(0, l).join("/")], e && (e = e[d]))) {\n                    f = e, h = k;break;\n                  }\n                }if (f) break;!i && p && p[d] && (i = p[d], j = k);\n              }!f && i && (f = i, h = j), f && (c.splice(0, h, f), a = c.join("/"));\n            }return a;\n          }function g(a, c) {\n            return function () {\n              return n.apply(b, v.call(arguments, 0).concat([a, c]));\n            };\n          }function h(a) {\n            return function (b) {\n              return f(b, a);\n            };\n          }function i(a) {\n            return function (b) {\n              q[a] = b;\n            };\n          }function j(a) {\n            if (e(r, a)) {\n              var c = r[a];delete r[a], t[a] = !0, m.apply(b, c);\n            }if (!e(q, a) && !e(t, a)) throw new Error("No " + a);return q[a];\n          }function k(a) {\n            var b,\n                c = a ? a.indexOf("!") : -1;return c > -1 && (b = a.substring(0, c), a = a.substring(c + 1, a.length)), [b, a];\n          }function l(a) {\n            return function () {\n              return s && s.config && s.config[a] || {};\n            };\n          }var m,\n              n,\n              o,\n              p,\n              q = {},\n              r = {},\n              s = {},\n              t = {},\n              u = Object.prototype.hasOwnProperty,\n              v = [].slice,\n              w = /\\.js$/;o = function (a, b) {\n            var c,\n                d = k(a),\n                e = d[0];return a = d[1], e && (e = f(e, b), c = j(e)), e ? a = c && c.normalize ? c.normalize(a, h(b)) : f(a, b) : (a = f(a, b), d = k(a), e = d[0], a = d[1], e && (c = j(e))), { f: e ? e + "!" + a : a, n: a, pr: e, p: c };\n          }, p = { require: function require(a) {\n              return g(a);\n            }, exports: function exports(a) {\n              var b = q[a];return "undefined" != typeof b ? b : q[a] = {};\n            }, module: function module(a) {\n              return { id: a, uri: "", exports: q[a], config: l(a) };\n            } }, m = function (a, c, d, f) {\n            var h,\n                k,\n                l,\n                m,\n                n,\n                s,\n                u = [],\n                v = typeof d === "undefined" ? "undefined" : _typeof(d);if ((f = f || a, "undefined" === v || "function" === v)) {\n              for (c = !c.length && d.length ? ["require", "exports", "module"] : c, n = 0; n < c.length; n += 1) {\n                if ((m = o(c[n], f), k = m.f, "require" === k)) u[n] = p.require(a);else if ("exports" === k) u[n] = p.exports(a), s = !0;else if ("module" === k) h = u[n] = p.module(a);else if (e(q, k) || e(r, k) || e(t, k)) u[n] = j(k);else {\n                  if (!m.p) throw new Error(a + " missing " + k);m.p.load(m.n, g(f, !0), i(k), {}), u[n] = q[k];\n                }\n              }l = d ? d.apply(q[a], u) : void 0, a && (h && h.exports !== b && h.exports !== q[a] ? q[a] = h.exports : l === b && s || (q[a] = l));\n            } else a && (q[a] = d);\n          }, a = c = n = function (a, c, d, e, f) {\n            if ("string" == typeof a) return p[a] ? p[a](c) : j(o(a, c).f);if (!a.splice) {\n              if ((s = a, s.deps && n(s.deps, s.callback), !c)) return;c.splice ? (a = c, c = d, d = null) : a = b;\n            }return c = c || function () {}, "function" == typeof d && (d = e, e = f), e ? m(b, a, c, d) : setTimeout(function () {\n              m(b, a, c, d);\n            }, 4), n;\n          }, n.config = function (a) {\n            return n(a);\n          }, a._defined = q, d = function (a, b, c) {\n            b.splice || (c = b, b = []), e(q, a) || e(r, a) || (r[a] = [a, b, c]);\n          }, d.amd = { jQuery: !0 };\n        })(), b.requirejs = a, b.require = c, b.define = d;\n      }\n    })(), b.define("almond", function () {}), b.define("jquery", [], function () {\n      var b = a || $;return null == b && console && console.error && console.error("Select2: An instance of jQuery or a jQuery-compatible library was not found. Make sure that you are including jQuery before Select2 on your web page."), b;\n    }), b.define("select2/utils", ["jquery"], function (a) {\n      function b(a) {\n        var b = a.prototype,\n            c = [];for (var d in b) {\n          var e = b[d];"function" == typeof e && "constructor" !== d && c.push(d);\n        }return c;\n      }var c = {};c.Extend = function (a, b) {\n        function c() {\n          this.constructor = a;\n        }var d = ({}).hasOwnProperty;for (var e in b) {\n          d.call(b, e) && (a[e] = b[e]);\n        }return c.prototype = b.prototype, a.prototype = new c(), a.__super__ = b.prototype, a;\n      }, c.Decorate = function (a, c) {\n        function d() {\n          var b = Array.prototype.unshift,\n              d = c.prototype.constructor.length,\n              e = a.prototype.constructor;d > 0 && (b.call(arguments, a.prototype.constructor), e = c.prototype.constructor), e.apply(this, arguments);\n        }function e() {\n          this.constructor = d;\n        }var f = b(c),\n            g = b(a);c.displayName = a.displayName, d.prototype = new e();for (var h = 0; h < g.length; h++) {\n          var i = g[h];d.prototype[i] = a.prototype[i];\n        }for (var j = function j(a) {\n          var b = function b() {};(a in d.prototype) && (b = d.prototype[a]);var e = c.prototype[a];return function () {\n            var a = Array.prototype.unshift;return a.call(arguments, b), e.apply(this, arguments);\n          };\n        }, k = 0; k < f.length; k++) {\n          var l = f[k];d.prototype[l] = j(l);\n        }return d;\n      };var d = function d() {\n        this.listeners = {};\n      };return d.prototype.on = function (a, b) {\n        this.listeners = this.listeners || {}, a in this.listeners ? this.listeners[a].push(b) : this.listeners[a] = [b];\n      }, d.prototype.trigger = function (a) {\n        var b = Array.prototype.slice;this.listeners = this.listeners || {}, a in this.listeners && this.invoke(this.listeners[a], b.call(arguments, 1)), "*" in this.listeners && this.invoke(this.listeners["*"], arguments);\n      }, d.prototype.invoke = function (a, b) {\n        for (var c = 0, d = a.length; d > c; c++) {\n          a[c].apply(this, b);\n        }\n      }, c.Observable = d, c.generateChars = function (a) {\n        for (var b = "", c = 0; a > c; c++) {\n          var d = Math.floor(36 * Math.random());b += d.toString(36);\n        }return b;\n      }, c.bind = function (a, b) {\n        return function () {\n          a.apply(b, arguments);\n        };\n      }, c._convertData = function (a) {\n        for (var b in a) {\n          var c = b.split("-"),\n              d = a;if (1 !== c.length) {\n            for (var e = 0; e < c.length; e++) {\n              var f = c[e];f = f.substring(0, 1).toLowerCase() + f.substring(1), f in d || (d[f] = {}), e == c.length - 1 && (d[f] = a[b]), d = d[f];\n            }delete a[b];\n          }\n        }return a;\n      }, c.hasScroll = function (b, c) {\n        var d = a(c),\n            e = c.style.overflowX,\n            f = c.style.overflowY;return e !== f || "hidden" !== f && "visible" !== f ? "scroll" === e || "scroll" === f ? !0 : d.innerHeight() < c.scrollHeight || d.innerWidth() < c.scrollWidth : !1;\n      }, c.escapeMarkup = function (a) {\n        var b = { "\\\\": "&#92;", "&": "&amp;", "<": "&lt;", ">": "&gt;", \'"\': "&quot;", "\'": "&#39;", "/": "&#47;" };return "string" != typeof a ? a : String(a).replace(/[&<>"\'\\/\\\\]/g, function (a) {\n          return b[a];\n        });\n      }, c.appendMany = function (b, c) {\n        if ("1.7" === a.fn.jquery.substr(0, 3)) {\n          var d = a();a.map(c, function (a) {\n            d = d.add(a);\n          }), c = d;\n        }b.append(c);\n      }, c;\n    }), b.define("select2/results", ["jquery", "./utils"], function (a, b) {\n      function c(a, b, d) {\n        this.$element = a, this.data = d, this.options = b, c.__super__.constructor.call(this);\n      }return b.Extend(c, b.Observable), c.prototype.render = function () {\n        var b = a(\'<ul class="select2-results__options" role="tree"></ul>\');return this.options.get("multiple") && b.attr("aria-multiselectable", "true"), this.$results = b, b;\n      }, c.prototype.clear = function () {\n        this.$results.empty();\n      }, c.prototype.displayMessage = function (b) {\n        var c = this.options.get("escapeMarkup");this.clear(), this.hideLoading();var d = a(\'<li role="treeitem" class="select2-results__option"></li>\'),\n            e = this.options.get("translations").get(b.message);d.append(c(e(b.args))), d[0].className += " select2-results__message", this.$results.append(d);\n      }, c.prototype.hideMessages = function () {\n        this.$results.find(".select2-results__message").remove();\n      }, c.prototype.append = function (a) {\n        this.hideLoading();var b = [];if (null == a.results || 0 === a.results.length) return void (0 === this.$results.children().length && this.trigger("results:message", { message: "noResults" }));a.results = this.sort(a.results);for (var c = 0; c < a.results.length; c++) {\n          var d = a.results[c],\n              e = this.option(d);b.push(e);\n        }this.$results.append(b);\n      }, c.prototype.position = function (a, b) {\n        var c = b.find(".select2-results");c.append(a);\n      }, c.prototype.sort = function (a) {\n        var b = this.options.get("sorter");return b(a);\n      }, c.prototype.setClasses = function () {\n        var b = this;this.data.current(function (c) {\n          var d = a.map(c, function (a) {\n            return a.id.toString();\n          }),\n              e = b.$results.find(".select2-results__option[aria-selected]");e.each(function () {\n            var b = a(this),\n                c = a.data(this, "data"),\n                e = "" + c.id;null != c.element && c.element.selected || null == c.element && a.inArray(e, d) > -1 ? b.attr("aria-selected", "true") : b.attr("aria-selected", "false");\n          });var f = e.filter("[aria-selected=true]");f.length > 0 ? f.first().trigger("mouseenter") : e.first().trigger("mouseenter");\n        });\n      }, c.prototype.showLoading = function (a) {\n        this.hideLoading();var b = this.options.get("translations").get("searching"),\n            c = { disabled: !0, loading: !0, text: b(a) },\n            d = this.option(c);d.className += " loading-results", this.$results.prepend(d);\n      }, c.prototype.hideLoading = function () {\n        this.$results.find(".loading-results").remove();\n      }, c.prototype.option = function (b) {\n        var c = document.createElement("li");c.className = "select2-results__option";var d = { role: "treeitem", "aria-selected": "false" };b.disabled && (delete d["aria-selected"], d["aria-disabled"] = "true"), null == b.id && delete d["aria-selected"], null != b._resultId && (c.id = b._resultId), b.title && (c.title = b.title), b.children && (d.role = "group", d["aria-label"] = b.text, delete d["aria-selected"]);for (var e in d) {\n          var f = d[e];c.setAttribute(e, f);\n        }if (b.children) {\n          var g = a(c),\n              h = document.createElement("strong");h.className = "select2-results__group";a(h);this.template(b, h);for (var i = [], j = 0; j < b.children.length; j++) {\n            var k = b.children[j],\n                l = this.option(k);i.push(l);\n          }var m = a("<ul></ul>", { "class": "select2-results__options select2-results__options--nested" });m.append(i), g.append(h), g.append(m);\n        } else this.template(b, c);return a.data(c, "data", b), c;\n      }, c.prototype.bind = function (b, c) {\n        var d = this,\n            e = b.id + "-results";this.$results.attr("id", e), b.on("results:all", function (a) {\n          d.clear(), d.append(a.data), b.isOpen() && d.setClasses();\n        }), b.on("results:append", function (a) {\n          d.append(a.data), b.isOpen() && d.setClasses();\n        }), b.on("query", function (a) {\n          d.hideMessages(), d.showLoading(a);\n        }), b.on("select", function () {\n          b.isOpen() && d.setClasses();\n        }), b.on("unselect", function () {\n          b.isOpen() && d.setClasses();\n        }), b.on("open", function () {\n          d.$results.attr("aria-expanded", "true"), d.$results.attr("aria-hidden", "false"), d.setClasses(), d.ensureHighlightVisible();\n        }), b.on("close", function () {\n          d.$results.attr("aria-expanded", "false"), d.$results.attr("aria-hidden", "true"), d.$results.removeAttr("aria-activedescendant");\n        }), b.on("results:toggle", function () {\n          var a = d.getHighlightedResults();0 !== a.length && a.trigger("mouseup");\n        }), b.on("results:select", function () {\n          var a = d.getHighlightedResults();if (0 !== a.length) {\n            var b = a.data("data");"true" == a.attr("aria-selected") ? d.trigger("close", {}) : d.trigger("select", { data: b });\n          }\n        }), b.on("results:previous", function () {\n          var a = d.getHighlightedResults(),\n              b = d.$results.find("[aria-selected]"),\n              c = b.index(a);if (0 !== c) {\n            var e = c - 1;0 === a.length && (e = 0);var f = b.eq(e);f.trigger("mouseenter");var g = d.$results.offset().top,\n                h = f.offset().top,\n                i = d.$results.scrollTop() + (h - g);0 === e ? d.$results.scrollTop(0) : 0 > h - g && d.$results.scrollTop(i);\n          }\n        }), b.on("results:next", function () {\n          var a = d.getHighlightedResults(),\n              b = d.$results.find("[aria-selected]"),\n              c = b.index(a),\n              e = c + 1;if (!(e >= b.length)) {\n            var f = b.eq(e);f.trigger("mouseenter");var g = d.$results.offset().top + d.$results.outerHeight(!1),\n                h = f.offset().top + f.outerHeight(!1),\n                i = d.$results.scrollTop() + h - g;0 === e ? d.$results.scrollTop(0) : h > g && d.$results.scrollTop(i);\n          }\n        }), b.on("results:focus", function (a) {\n          a.element.addClass("select2-results__option--highlighted");\n        }), b.on("results:message", function (a) {\n          d.displayMessage(a);\n        }), a.fn.mousewheel && this.$results.on("mousewheel", function (a) {\n          var b = d.$results.scrollTop(),\n              c = d.$results.get(0).scrollHeight - d.$results.scrollTop() + a.deltaY,\n              e = a.deltaY > 0 && b - a.deltaY <= 0,\n              f = a.deltaY < 0 && c <= d.$results.height();e ? (d.$results.scrollTop(0), a.preventDefault(), a.stopPropagation()) : f && (d.$results.scrollTop(d.$results.get(0).scrollHeight - d.$results.height()), a.preventDefault(), a.stopPropagation());\n        }), this.$results.on("mouseup", ".select2-results__option[aria-selected]", function (b) {\n          var c = a(this),\n              e = c.data("data");return "true" === c.attr("aria-selected") ? void (d.options.get("multiple") ? d.trigger("unselect", { originalEvent: b, data: e }) : d.trigger("close", {})) : void d.trigger("select", { originalEvent: b, data: e });\n        }), this.$results.on("mouseenter", ".select2-results__option[aria-selected]", function (b) {\n          var c = a(this).data("data");d.getHighlightedResults().removeClass("select2-results__option--highlighted"), d.trigger("results:focus", { data: c, element: a(this) });\n        });\n      }, c.prototype.getHighlightedResults = function () {\n        var a = this.$results.find(".select2-results__option--highlighted");return a;\n      }, c.prototype.destroy = function () {\n        this.$results.remove();\n      }, c.prototype.ensureHighlightVisible = function () {\n        var a = this.getHighlightedResults();if (0 !== a.length) {\n          var b = this.$results.find("[aria-selected]"),\n              c = b.index(a),\n              d = this.$results.offset().top,\n              e = a.offset().top,\n              f = this.$results.scrollTop() + (e - d),\n              g = e - d;f -= 2 * a.outerHeight(!1), 2 >= c ? this.$results.scrollTop(0) : (g > this.$results.outerHeight() || 0 > g) && this.$results.scrollTop(f);\n        }\n      }, c.prototype.template = function (b, c) {\n        var d = this.options.get("templateResult"),\n            e = this.options.get("escapeMarkup"),\n            f = d(b);null == f ? c.style.display = "none" : "string" == typeof f ? c.innerHTML = e(f) : a(c).append(f);\n      }, c;\n    }), b.define("select2/keys", [], function () {\n      var a = { BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, DELETE: 46 };return a;\n    }), b.define("select2/selection/base", ["jquery", "../utils", "../keys"], function (a, b, c) {\n      function d(a, b) {\n        this.$element = a, this.options = b, d.__super__.constructor.call(this);\n      }return b.Extend(d, b.Observable), d.prototype.render = function () {\n        var b = a(\'<span class="select2-selection" role="combobox" aria-autocomplete="list" aria-haspopup="true" aria-expanded="false"></span>\');return this._tabindex = 0, null != this.$element.data("old-tabindex") ? this._tabindex = this.$element.data("old-tabindex") : null != this.$element.attr("tabindex") && (this._tabindex = this.$element.attr("tabindex")), b.attr("title", this.$element.attr("title")), b.attr("tabindex", this._tabindex), this.$selection = b, b;\n      }, d.prototype.bind = function (a, b) {\n        var d = this,\n            e = (a.id + "-container", a.id + "-results");this.container = a, this.$selection.on("focus", function (a) {\n          d.trigger("focus", a);\n        }), this.$selection.on("blur", function (a) {\n          d._handleBlur(a);\n        }), this.$selection.on("keydown", function (a) {\n          d.trigger("keypress", a), a.which === c.SPACE && a.preventDefault();\n        }), a.on("results:focus", function (a) {\n          d.$selection.attr("aria-activedescendant", a.data._resultId);\n        }), a.on("selection:update", function (a) {\n          d.update(a.data);\n        }), a.on("open", function () {\n          d.$selection.attr("aria-expanded", "true"), d.$selection.attr("aria-owns", e), d._attachCloseHandler(a);\n        }), a.on("close", function () {\n          d.$selection.attr("aria-expanded", "false"), d.$selection.removeAttr("aria-activedescendant"), d.$selection.removeAttr("aria-owns"), d.$selection.focus(), d._detachCloseHandler(a);\n        }), a.on("enable", function () {\n          d.$selection.attr("tabindex", d._tabindex);\n        }), a.on("disable", function () {\n          d.$selection.attr("tabindex", "-1");\n        });\n      }, d.prototype._handleBlur = function (b) {\n        var c = this;window.setTimeout(function () {\n          document.activeElement == c.$selection[0] || a.contains(c.$selection[0], document.activeElement) || c.trigger("blur", b);\n        }, 1);\n      }, d.prototype._attachCloseHandler = function (b) {\n        a(document.body).on("mousedown.select2." + b.id, function (b) {\n          var c = a(b.target),\n              d = c.closest(".select2"),\n              e = a(".select2.select2-container--open");e.each(function () {\n            var b = a(this);if (this != d[0]) {\n              var c = b.data("element");c.select2("close");\n            }\n          });\n        });\n      }, d.prototype._detachCloseHandler = function (b) {\n        a(document.body).off("mousedown.select2." + b.id);\n      }, d.prototype.position = function (a, b) {\n        var c = b.find(".selection");c.append(a);\n      }, d.prototype.destroy = function () {\n        this._detachCloseHandler(this.container);\n      }, d.prototype.update = function (a) {\n        throw new Error("The `update` method must be defined in child classes.");\n      }, d;\n    }), b.define("select2/selection/single", ["jquery", "./base", "../utils", "../keys"], function (a, b, c, d) {\n      function e() {\n        e.__super__.constructor.apply(this, arguments);\n      }return c.Extend(e, b), e.prototype.render = function () {\n        var a = e.__super__.render.call(this);return a.addClass("select2-selection--single"), a.html(\'<span class="select2-selection__rendered"></span><span class="select2-selection__arrow" role="presentation"><b role="presentation"></b></span>\'), a;\n      }, e.prototype.bind = function (a, b) {\n        var c = this;e.__super__.bind.apply(this, arguments);var d = a.id + "-container";this.$selection.find(".select2-selection__rendered").attr("id", d), this.$selection.attr("aria-labelledby", d), this.$selection.on("mousedown", function (a) {\n          1 === a.which && c.trigger("toggle", { originalEvent: a });\n        }), this.$selection.on("focus", function (a) {}), this.$selection.on("blur", function (a) {}), a.on("selection:update", function (a) {\n          c.update(a.data);\n        });\n      }, e.prototype.clear = function () {\n        this.$selection.find(".select2-selection__rendered").empty();\n      }, e.prototype.display = function (a, b) {\n        var c = this.options.get("templateSelection"),\n            d = this.options.get("escapeMarkup");return d(c(a, b));\n      }, e.prototype.selectionContainer = function () {\n        return a("<span></span>");\n      }, e.prototype.update = function (a) {\n        if (0 === a.length) return void this.clear();var b = a[0],\n            c = this.$selection.find(".select2-selection__rendered"),\n            d = this.display(b, c);c.empty().append(d), c.prop("title", b.title || b.text);\n      }, e;\n    }), b.define("select2/selection/multiple", ["jquery", "./base", "../utils"], function (a, b, c) {\n      function d(a, b) {\n        d.__super__.constructor.apply(this, arguments);\n      }return c.Extend(d, b), d.prototype.render = function () {\n        var a = d.__super__.render.call(this);return a.addClass("select2-selection--multiple"), a.html(\'<ul class="select2-selection__rendered"></ul>\'), a;\n      }, d.prototype.bind = function (b, c) {\n        var e = this;d.__super__.bind.apply(this, arguments), this.$selection.on("click", function (a) {\n          e.trigger("toggle", { originalEvent: a });\n        }), this.$selection.on("click", ".select2-selection__choice__remove", function (b) {\n          if (!e.options.get("disabled")) {\n            var c = a(this),\n                d = c.parent(),\n                f = d.data("data");e.trigger("unselect", { originalEvent: b, data: f });\n          }\n        });\n      }, d.prototype.clear = function () {\n        this.$selection.find(".select2-selection__rendered").empty();\n      }, d.prototype.display = function (a, b) {\n        var c = this.options.get("templateSelection"),\n            d = this.options.get("escapeMarkup");return d(c(a, b));\n      }, d.prototype.selectionContainer = function () {\n        var b = a(\'<li class="select2-selection__choice"><span class="select2-selection__choice__remove" role="presentation">&times;</span></li>\');return b;\n      }, d.prototype.update = function (a) {\n        if ((this.clear(), 0 !== a.length)) {\n          for (var b = [], d = 0; d < a.length; d++) {\n            var e = a[d],\n                f = this.selectionContainer(),\n                g = this.display(e, f);f.append(g), f.prop("title", e.title || e.text), f.data("data", e), b.push(f);\n          }var h = this.$selection.find(".select2-selection__rendered");c.appendMany(h, b);\n        }\n      }, d;\n    }), b.define("select2/selection/placeholder", ["../utils"], function (a) {\n      function b(a, b, c) {\n        this.placeholder = this.normalizePlaceholder(c.get("placeholder")), a.call(this, b, c);\n      }return b.prototype.normalizePlaceholder = function (a, b) {\n        return "string" == typeof b && (b = { id: "", text: b }), b;\n      }, b.prototype.createPlaceholder = function (a, b) {\n        var c = this.selectionContainer();return c.html(this.display(b)), c.addClass("select2-selection__placeholder").removeClass("select2-selection__choice"), c;\n      }, b.prototype.update = function (a, b) {\n        var c = 1 == b.length && b[0].id != this.placeholder.id,\n            d = b.length > 1;if (d || c) return a.call(this, b);this.clear();var e = this.createPlaceholder(this.placeholder);this.$selection.find(".select2-selection__rendered").append(e);\n      }, b;\n    }), b.define("select2/selection/allowClear", ["jquery", "../keys"], function (a, b) {\n      function c() {}return c.prototype.bind = function (a, b, c) {\n        var d = this;a.call(this, b, c), null == this.placeholder && this.options.get("debug") && window.console && console.error && console.error("Select2: The `allowClear` option should be used in combination with the `placeholder` option."), this.$selection.on("mousedown", ".select2-selection__clear", function (a) {\n          d._handleClear(a);\n        }), b.on("keypress", function (a) {\n          d._handleKeyboardClear(a, b);\n        });\n      }, c.prototype._handleClear = function (a, b) {\n        if (!this.options.get("disabled")) {\n          var c = this.$selection.find(".select2-selection__clear");if (0 !== c.length) {\n            b.stopPropagation();for (var d = c.data("data"), e = 0; e < d.length; e++) {\n              var f = { data: d[e] };if ((this.trigger("unselect", f), f.prevented)) return;\n            }this.$element.val(this.placeholder.id).trigger("change"), this.trigger("toggle", {});\n          }\n        }\n      }, c.prototype._handleKeyboardClear = function (a, c, d) {\n        d.isOpen() || (c.which == b.DELETE || c.which == b.BACKSPACE) && this._handleClear(c);\n      }, c.prototype.update = function (b, c) {\n        if ((b.call(this, c), !(this.$selection.find(".select2-selection__placeholder").length > 0 || 0 === c.length))) {\n          var d = a(\'<span class="select2-selection__clear">&times;</span>\');d.data("data", c), this.$selection.find(".select2-selection__rendered").prepend(d);\n        }\n      }, c;\n    }), b.define("select2/selection/search", ["jquery", "../utils", "../keys"], function (a, b, c) {\n      function d(a, b, c) {\n        a.call(this, b, c);\n      }return d.prototype.render = function (b) {\n        var c = a(\'<li class="select2-search select2-search--inline"><input class="select2-search__field" type="search" tabindex="-1" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="textbox" /></li>\');this.$searchContainer = c, this.$search = c.find("input");var d = b.call(this);return this._transferTabIndex(), d;\n      }, d.prototype.bind = function (a, b, d) {\n        var e = this;a.call(this, b, d), b.on("open", function () {\n          e.$search.trigger("focus");\n        }), b.on("close", function () {\n          e.$search.val(""), e.$search.trigger("focus");\n        }), b.on("enable", function () {\n          e.$search.prop("disabled", !1), e._transferTabIndex();\n        }), b.on("disable", function () {\n          e.$search.prop("disabled", !0);\n        }), b.on("focus", function (a) {\n          e.$search.trigger("focus");\n        }), this.$selection.on("focusin", ".select2-search--inline", function (a) {\n          e.trigger("focus", a);\n        }), this.$selection.on("focusout", ".select2-search--inline", function (a) {\n          e._handleBlur(a);\n        }), this.$selection.on("keydown", ".select2-search--inline", function (a) {\n          a.stopPropagation(), e.trigger("keypress", a), e._keyUpPrevented = a.isDefaultPrevented();var b = a.which;if (b === c.BACKSPACE && "" === e.$search.val()) {\n            var d = e.$searchContainer.prev(".select2-selection__choice");if (d.length > 0) {\n              var f = d.data("data");e.searchRemoveChoice(f), a.preventDefault();\n            }\n          }\n        });var f = document.documentMode,\n            g = f && 11 >= f;this.$selection.on("input.searchcheck", ".select2-search--inline", function (a) {\n          return g ? void e.$selection.off("input.search input.searchcheck") : void e.$selection.off("keyup.search");\n        }), this.$selection.on("keyup.search input.search", ".select2-search--inline", function (a) {\n          if (g && "input" === a.type) return void e.$selection.off("input.search input.searchcheck");var b = a.which;b != c.SHIFT && b != c.CTRL && b != c.ALT && b != c.TAB && e.handleSearch(a);\n        });\n      }, d.prototype._transferTabIndex = function (a) {\n        this.$search.attr("tabindex", this.$selection.attr("tabindex")), this.$selection.attr("tabindex", "-1");\n      }, d.prototype.createPlaceholder = function (a, b) {\n        this.$search.attr("placeholder", b.text);\n      }, d.prototype.update = function (a, b) {\n        var c = this.$search[0] == document.activeElement;this.$search.attr("placeholder", ""), a.call(this, b), this.$selection.find(".select2-selection__rendered").append(this.$searchContainer), this.resizeSearch(), c && this.$search.focus();\n      }, d.prototype.handleSearch = function () {\n        if ((this.resizeSearch(), !this._keyUpPrevented)) {\n          var a = this.$search.val();this.trigger("query", { term: a });\n        }this._keyUpPrevented = !1;\n      }, d.prototype.searchRemoveChoice = function (a, b) {\n        this.trigger("unselect", { data: b }), this.trigger("open", {}), this.$search.val(b.text + " ");\n      }, d.prototype.resizeSearch = function () {\n        this.$search.css("width", "25px");var a = "";if ("" !== this.$search.attr("placeholder")) a = this.$selection.find(".select2-selection__rendered").innerWidth();else {\n          var b = this.$search.val().length + 1;a = .75 * b + "em";\n        }this.$search.css("width", a);\n      }, d;\n    }), b.define("select2/selection/eventRelay", ["jquery"], function (a) {\n      function b() {}return b.prototype.bind = function (b, c, d) {\n        var e = this,\n            f = ["open", "opening", "close", "closing", "select", "selecting", "unselect", "unselecting"],\n            g = ["opening", "closing", "selecting", "unselecting"];b.call(this, c, d), c.on("*", function (b, c) {\n          if (-1 !== a.inArray(b, f)) {\n            c = c || {};var d = a.Event("select2:" + b, { params: c });e.$element.trigger(d), -1 !== a.inArray(b, g) && (c.prevented = d.isDefaultPrevented());\n          }\n        });\n      }, b;\n    }), b.define("select2/translation", ["jquery", "require"], function (a, b) {\n      function c(a) {\n        this.dict = a || {};\n      }return c.prototype.all = function () {\n        return this.dict;\n      }, c.prototype.get = function (a) {\n        return this.dict[a];\n      }, c.prototype.extend = function (b) {\n        this.dict = a.extend({}, b.all(), this.dict);\n      }, c._cache = {}, c.loadPath = function (a) {\n        if (!(a in c._cache)) {\n          var d = b(a);c._cache[a] = d;\n        }return new c(c._cache[a]);\n      }, c;\n    }), b.define("select2/diacritics", [], function () {\n      var a = { "Ⓐ": "A", "Ａ": "A", "À": "A", "Á": "A", "Â": "A", "Ầ": "A", "Ấ": "A", "Ẫ": "A", "Ẩ": "A", "Ã": "A", "Ā": "A", "Ă": "A", "Ằ": "A", "Ắ": "A", "Ẵ": "A", "Ẳ": "A", "Ȧ": "A", "Ǡ": "A", "Ä": "A", "Ǟ": "A", "Ả": "A", "Å": "A", "Ǻ": "A", "Ǎ": "A", "Ȁ": "A", "Ȃ": "A", "Ạ": "A", "Ậ": "A", "Ặ": "A", "Ḁ": "A", "Ą": "A", "Ⱥ": "A", "Ɐ": "A", "Ꜳ": "AA", "Æ": "AE", "Ǽ": "AE", "Ǣ": "AE", "Ꜵ": "AO", "Ꜷ": "AU", "Ꜹ": "AV", "Ꜻ": "AV", "Ꜽ": "AY", "Ⓑ": "B", "Ｂ": "B", "Ḃ": "B", "Ḅ": "B", "Ḇ": "B", "Ƀ": "B", "Ƃ": "B", "Ɓ": "B", "Ⓒ": "C", "Ｃ": "C", "Ć": "C", "Ĉ": "C", "Ċ": "C", "Č": "C", "Ç": "C", "Ḉ": "C", "Ƈ": "C", "Ȼ": "C", "Ꜿ": "C", "Ⓓ": "D", "Ｄ": "D", "Ḋ": "D", "Ď": "D", "Ḍ": "D", "Ḑ": "D", "Ḓ": "D", "Ḏ": "D", "Đ": "D", "Ƌ": "D", "Ɗ": "D", "Ɖ": "D", "Ꝺ": "D", "Ǳ": "DZ", "Ǆ": "DZ", "ǲ": "Dz", "ǅ": "Dz", "Ⓔ": "E", "Ｅ": "E", "È": "E", "É": "E", "Ê": "E", "Ề": "E", "Ế": "E", "Ễ": "E", "Ể": "E", "Ẽ": "E", "Ē": "E", "Ḕ": "E", "Ḗ": "E", "Ĕ": "E", "Ė": "E", "Ë": "E", "Ẻ": "E", "Ě": "E", "Ȅ": "E", "Ȇ": "E", "Ẹ": "E", "Ệ": "E", "Ȩ": "E", "Ḝ": "E", "Ę": "E", "Ḙ": "E", "Ḛ": "E", "Ɛ": "E", "Ǝ": "E", "Ⓕ": "F", "Ｆ": "F", "Ḟ": "F", "Ƒ": "F", "Ꝼ": "F", "Ⓖ": "G", "Ｇ": "G", "Ǵ": "G", "Ĝ": "G", "Ḡ": "G", "Ğ": "G", "Ġ": "G", "Ǧ": "G", "Ģ": "G", "Ǥ": "G", "Ɠ": "G", "Ꞡ": "G", "Ᵹ": "G", "Ꝿ": "G", "Ⓗ": "H", "Ｈ": "H", "Ĥ": "H", "Ḣ": "H", "Ḧ": "H", "Ȟ": "H", "Ḥ": "H", "Ḩ": "H", "Ḫ": "H", "Ħ": "H", "Ⱨ": "H", "Ⱶ": "H", "Ɥ": "H", "Ⓘ": "I", "Ｉ": "I", "Ì": "I", "Í": "I", "Î": "I", "Ĩ": "I", "Ī": "I", "Ĭ": "I", "İ": "I", "Ï": "I", "Ḯ": "I", "Ỉ": "I", "Ǐ": "I", "Ȉ": "I", "Ȋ": "I", "Ị": "I", "Į": "I", "Ḭ": "I", "Ɨ": "I", "Ⓙ": "J", "Ｊ": "J", "Ĵ": "J", "Ɉ": "J", "Ⓚ": "K", "Ｋ": "K", "Ḱ": "K", "Ǩ": "K", "Ḳ": "K", "Ķ": "K", "Ḵ": "K", "Ƙ": "K", "Ⱪ": "K", "Ꝁ": "K", "Ꝃ": "K", "Ꝅ": "K", "Ꞣ": "K", "Ⓛ": "L", "Ｌ": "L", "Ŀ": "L", "Ĺ": "L", "Ľ": "L", "Ḷ": "L", "Ḹ": "L", "Ļ": "L", "Ḽ": "L", "Ḻ": "L", "Ł": "L", "Ƚ": "L", "Ɫ": "L", "Ⱡ": "L", "Ꝉ": "L", "Ꝇ": "L", "Ꞁ": "L", "Ǉ": "LJ", "ǈ": "Lj", "Ⓜ": "M", "Ｍ": "M", "Ḿ": "M", "Ṁ": "M", "Ṃ": "M", "Ɱ": "M", "Ɯ": "M", "Ⓝ": "N", "Ｎ": "N", "Ǹ": "N", "Ń": "N", "Ñ": "N", "Ṅ": "N", "Ň": "N", "Ṇ": "N", "Ņ": "N", "Ṋ": "N", "Ṉ": "N", "Ƞ": "N", "Ɲ": "N", "Ꞑ": "N", "Ꞥ": "N", "Ǌ": "NJ", "ǋ": "Nj", "Ⓞ": "O", "Ｏ": "O", "Ò": "O", "Ó": "O", "Ô": "O", "Ồ": "O", "Ố": "O", "Ỗ": "O", "Ổ": "O", "Õ": "O", "Ṍ": "O", "Ȭ": "O", "Ṏ": "O", "Ō": "O", "Ṑ": "O", "Ṓ": "O", "Ŏ": "O", "Ȯ": "O", "Ȱ": "O", "Ö": "O", "Ȫ": "O", "Ỏ": "O", "Ő": "O", "Ǒ": "O", "Ȍ": "O", "Ȏ": "O", "Ơ": "O", "Ờ": "O", "Ớ": "O", "Ỡ": "O", "Ở": "O", "Ợ": "O", "Ọ": "O", "Ộ": "O", "Ǫ": "O", "Ǭ": "O", "Ø": "O", "Ǿ": "O", "Ɔ": "O", "Ɵ": "O", "Ꝋ": "O", "Ꝍ": "O", "Ƣ": "OI", "Ꝏ": "OO", "Ȣ": "OU", "Ⓟ": "P", "Ｐ": "P", "Ṕ": "P", "Ṗ": "P", "Ƥ": "P", "Ᵽ": "P", "Ꝑ": "P", "Ꝓ": "P", "Ꝕ": "P", "Ⓠ": "Q", "Ｑ": "Q", "Ꝗ": "Q", "Ꝙ": "Q", "Ɋ": "Q", "Ⓡ": "R", "Ｒ": "R", "Ŕ": "R", "Ṙ": "R", "Ř": "R", "Ȑ": "R", "Ȓ": "R", "Ṛ": "R", "Ṝ": "R", "Ŗ": "R", "Ṟ": "R", "Ɍ": "R", "Ɽ": "R", "Ꝛ": "R", "Ꞧ": "R", "Ꞃ": "R", "Ⓢ": "S", "Ｓ": "S", "ẞ": "S", "Ś": "S", "Ṥ": "S", "Ŝ": "S", "Ṡ": "S", "Š": "S", "Ṧ": "S", "Ṣ": "S", "Ṩ": "S", "Ș": "S", "Ş": "S", "Ȿ": "S", "Ꞩ": "S", "Ꞅ": "S", "Ⓣ": "T", "Ｔ": "T", "Ṫ": "T", "Ť": "T", "Ṭ": "T", "Ț": "T", "Ţ": "T", "Ṱ": "T", "Ṯ": "T", "Ŧ": "T", "Ƭ": "T", "Ʈ": "T", "Ⱦ": "T", "Ꞇ": "T", "Ꜩ": "TZ", "Ⓤ": "U", "Ｕ": "U", "Ù": "U", "Ú": "U", "Û": "U", "Ũ": "U", "Ṹ": "U", "Ū": "U", "Ṻ": "U", "Ŭ": "U", "Ü": "U", "Ǜ": "U", "Ǘ": "U", "Ǖ": "U", "Ǚ": "U", "Ủ": "U", "Ů": "U", "Ű": "U", "Ǔ": "U", "Ȕ": "U", "Ȗ": "U", "Ư": "U", "Ừ": "U", "Ứ": "U", "Ữ": "U", "Ử": "U", "Ự": "U", "Ụ": "U", "Ṳ": "U", "Ų": "U", "Ṷ": "U", "Ṵ": "U", "Ʉ": "U", "Ⓥ": "V", "Ｖ": "V", "Ṽ": "V", "Ṿ": "V", "Ʋ": "V", "Ꝟ": "V", "Ʌ": "V", "Ꝡ": "VY", "Ⓦ": "W", "Ｗ": "W", "Ẁ": "W", "Ẃ": "W", "Ŵ": "W", "Ẇ": "W", "Ẅ": "W", "Ẉ": "W", "Ⱳ": "W", "Ⓧ": "X", "Ｘ": "X", "Ẋ": "X", "Ẍ": "X", "Ⓨ": "Y", "Ｙ": "Y", "Ỳ": "Y", "Ý": "Y", "Ŷ": "Y", "Ỹ": "Y", "Ȳ": "Y", "Ẏ": "Y", "Ÿ": "Y", "Ỷ": "Y", "Ỵ": "Y", "Ƴ": "Y", "Ɏ": "Y", "Ỿ": "Y", "Ⓩ": "Z", "Ｚ": "Z", "Ź": "Z", "Ẑ": "Z", "Ż": "Z", "Ž": "Z", "Ẓ": "Z", "Ẕ": "Z", "Ƶ": "Z", "Ȥ": "Z", "Ɀ": "Z", "Ⱬ": "Z", "Ꝣ": "Z", "ⓐ": "a", "ａ": "a", "ẚ": "a", "à": "a", "á": "a", "â": "a", "ầ": "a", "ấ": "a", "ẫ": "a", "ẩ": "a", "ã": "a", "ā": "a", "ă": "a", "ằ": "a", "ắ": "a", "ẵ": "a", "ẳ": "a", "ȧ": "a", "ǡ": "a", "ä": "a", "ǟ": "a", "ả": "a", "å": "a", "ǻ": "a", "ǎ": "a", "ȁ": "a", "ȃ": "a", "ạ": "a", "ậ": "a", "ặ": "a", "ḁ": "a", "ą": "a", "ⱥ": "a", "ɐ": "a", "ꜳ": "aa", "æ": "ae", "ǽ": "ae", "ǣ": "ae", "ꜵ": "ao", "ꜷ": "au", "ꜹ": "av", "ꜻ": "av", "ꜽ": "ay", "ⓑ": "b", "ｂ": "b", "ḃ": "b", "ḅ": "b", "ḇ": "b", "ƀ": "b", "ƃ": "b", "ɓ": "b", "ⓒ": "c", "ｃ": "c", "ć": "c", "ĉ": "c", "ċ": "c", "č": "c", "ç": "c", "ḉ": "c", "ƈ": "c", "ȼ": "c", "ꜿ": "c", "ↄ": "c", "ⓓ": "d", "ｄ": "d", "ḋ": "d", "ď": "d", "ḍ": "d", "ḑ": "d", "ḓ": "d", "ḏ": "d", "đ": "d", "ƌ": "d", "ɖ": "d", "ɗ": "d", "ꝺ": "d", "ǳ": "dz", "ǆ": "dz", "ⓔ": "e", "ｅ": "e", "è": "e", "é": "e", "ê": "e", "ề": "e", "ế": "e", "ễ": "e", "ể": "e", "ẽ": "e", "ē": "e", "ḕ": "e", "ḗ": "e", "ĕ": "e", "ė": "e", "ë": "e", "ẻ": "e", "ě": "e", "ȅ": "e", "ȇ": "e", "ẹ": "e", "ệ": "e", "ȩ": "e", "ḝ": "e", "ę": "e", "ḙ": "e", "ḛ": "e", "ɇ": "e", "ɛ": "e", "ǝ": "e", "ⓕ": "f", "ｆ": "f", "ḟ": "f", "ƒ": "f", "ꝼ": "f", "ⓖ": "g", "ｇ": "g", "ǵ": "g", "ĝ": "g", "ḡ": "g", "ğ": "g", "ġ": "g", "ǧ": "g", "ģ": "g", "ǥ": "g", "ɠ": "g", "ꞡ": "g", "ᵹ": "g", "ꝿ": "g", "ⓗ": "h", "ｈ": "h", "ĥ": "h", "ḣ": "h", "ḧ": "h", "ȟ": "h", "ḥ": "h", "ḩ": "h", "ḫ": "h", "ẖ": "h", "ħ": "h", "ⱨ": "h", "ⱶ": "h", "ɥ": "h", "ƕ": "hv", "ⓘ": "i", "ｉ": "i", "ì": "i", "í": "i", "î": "i", "ĩ": "i", "ī": "i", "ĭ": "i", "ï": "i", "ḯ": "i", "ỉ": "i", "ǐ": "i", "ȉ": "i", "ȋ": "i", "ị": "i", "į": "i", "ḭ": "i", "ɨ": "i", "ı": "i", "ⓙ": "j", "ｊ": "j", "ĵ": "j", "ǰ": "j", "ɉ": "j", "ⓚ": "k", "ｋ": "k", "ḱ": "k", "ǩ": "k", "ḳ": "k", "ķ": "k", "ḵ": "k", "ƙ": "k", "ⱪ": "k", "ꝁ": "k", "ꝃ": "k", "ꝅ": "k", "ꞣ": "k", "ⓛ": "l", "ｌ": "l", "ŀ": "l", "ĺ": "l", "ľ": "l", "ḷ": "l", "ḹ": "l", "ļ": "l", "ḽ": "l", "ḻ": "l", "ſ": "l", "ł": "l", "ƚ": "l", "ɫ": "l", "ⱡ": "l", "ꝉ": "l", "ꞁ": "l", "ꝇ": "l", "ǉ": "lj", "ⓜ": "m", "ｍ": "m", "ḿ": "m", "ṁ": "m", "ṃ": "m", "ɱ": "m", "ɯ": "m", "ⓝ": "n", "ｎ": "n", "ǹ": "n", "ń": "n", "ñ": "n", "ṅ": "n", "ň": "n", "ṇ": "n", "ņ": "n", "ṋ": "n", "ṉ": "n", "ƞ": "n", "ɲ": "n", "ŉ": "n", "ꞑ": "n", "ꞥ": "n", "ǌ": "nj", "ⓞ": "o", "ｏ": "o", "ò": "o", "ó": "o", "ô": "o", "ồ": "o", "ố": "o", "ỗ": "o", "ổ": "o", "õ": "o", "ṍ": "o", "ȭ": "o", "ṏ": "o", "ō": "o", "ṑ": "o", "ṓ": "o", "ŏ": "o", "ȯ": "o", "ȱ": "o", "ö": "o", "ȫ": "o", "ỏ": "o", "ő": "o", "ǒ": "o", "ȍ": "o", "ȏ": "o", "ơ": "o", "ờ": "o", "ớ": "o", "ỡ": "o", "ở": "o", "ợ": "o", "ọ": "o", "ộ": "o", "ǫ": "o", "ǭ": "o", "ø": "o", "ǿ": "o", "ɔ": "o", "ꝋ": "o", "ꝍ": "o", "ɵ": "o", "ƣ": "oi", "ȣ": "ou", "ꝏ": "oo", "ⓟ": "p", "ｐ": "p", "ṕ": "p", "ṗ": "p", "ƥ": "p", "ᵽ": "p", "ꝑ": "p", "ꝓ": "p", "ꝕ": "p", "ⓠ": "q", "ｑ": "q", "ɋ": "q", "ꝗ": "q", "ꝙ": "q", "ⓡ": "r", "ｒ": "r", "ŕ": "r", "ṙ": "r", "ř": "r", "ȑ": "r", "ȓ": "r", "ṛ": "r", "ṝ": "r", "ŗ": "r", "ṟ": "r", "ɍ": "r", "ɽ": "r", "ꝛ": "r", "ꞧ": "r", "ꞃ": "r", "ⓢ": "s", "ｓ": "s", "ß": "s", "ś": "s", "ṥ": "s", "ŝ": "s", "ṡ": "s", "š": "s", "ṧ": "s", "ṣ": "s", "ṩ": "s", "ș": "s", "ş": "s", "ȿ": "s", "ꞩ": "s", "ꞅ": "s", "ẛ": "s", "ⓣ": "t", "ｔ": "t", "ṫ": "t", "ẗ": "t", "ť": "t", "ṭ": "t", "ț": "t", "ţ": "t", "ṱ": "t", "ṯ": "t", "ŧ": "t", "ƭ": "t", "ʈ": "t", "ⱦ": "t", "ꞇ": "t", "ꜩ": "tz", "ⓤ": "u", "ｕ": "u", "ù": "u", "ú": "u", "û": "u", "ũ": "u", "ṹ": "u", "ū": "u", "ṻ": "u", "ŭ": "u", "ü": "u", "ǜ": "u", "ǘ": "u", "ǖ": "u", "ǚ": "u", "ủ": "u", "ů": "u", "ű": "u", "ǔ": "u", "ȕ": "u", "ȗ": "u", "ư": "u", "ừ": "u", "ứ": "u", "ữ": "u", "ử": "u", "ự": "u", "ụ": "u", "ṳ": "u", "ų": "u", "ṷ": "u", "ṵ": "u", "ʉ": "u", "ⓥ": "v", "ｖ": "v", "ṽ": "v", "ṿ": "v", "ʋ": "v", "ꝟ": "v", "ʌ": "v", "ꝡ": "vy", "ⓦ": "w", "ｗ": "w", "ẁ": "w", "ẃ": "w", "ŵ": "w", "ẇ": "w", "ẅ": "w", "ẘ": "w", "ẉ": "w", "ⱳ": "w", "ⓧ": "x", "ｘ": "x", "ẋ": "x", "ẍ": "x", "ⓨ": "y", "ｙ": "y", "ỳ": "y", "ý": "y", "ŷ": "y", "ỹ": "y", "ȳ": "y", "ẏ": "y", "ÿ": "y", "ỷ": "y", "ẙ": "y", "ỵ": "y", "ƴ": "y", "ɏ": "y", "ỿ": "y", "ⓩ": "z", "ｚ": "z", "ź": "z", "ẑ": "z", "ż": "z", "ž": "z", "ẓ": "z", "ẕ": "z", "ƶ": "z", "ȥ": "z", "ɀ": "z", "ⱬ": "z", "ꝣ": "z", "Ά": "Α", "Έ": "Ε", "Ή": "Η", "Ί": "Ι", "Ϊ": "Ι", "Ό": "Ο", "Ύ": "Υ", "Ϋ": "Υ", "Ώ": "Ω", "ά": "α", "έ": "ε", "ή": "η", "ί": "ι", "ϊ": "ι", "ΐ": "ι", "ό": "ο", "ύ": "υ", "ϋ": "υ", "ΰ": "υ", "ω": "ω", "ς": "σ" };return a;\n    }), b.define("select2/data/base", ["../utils"], function (a) {\n      function b(a, c) {\n        b.__super__.constructor.call(this);\n      }return a.Extend(b, a.Observable), b.prototype.current = function (a) {\n        throw new Error("The `current` method must be defined in child classes.");\n      }, b.prototype.query = function (a, b) {\n        throw new Error("The `query` method must be defined in child classes.");\n      }, b.prototype.bind = function (a, b) {}, b.prototype.destroy = function () {}, b.prototype.generateResultId = function (b, c) {\n        var d = b.id + "-result-";return d += a.generateChars(4), d += null != c.id ? "-" + c.id.toString() : "-" + a.generateChars(4);\n      }, b;\n    }), b.define("select2/data/select", ["./base", "../utils", "jquery"], function (a, b, c) {\n      function d(a, b) {\n        this.$element = a, this.options = b, d.__super__.constructor.call(this);\n      }return b.Extend(d, a), d.prototype.current = function (a) {\n        var b = [],\n            d = this;this.$element.find(":selected").each(function () {\n          var a = c(this),\n              e = d.item(a);b.push(e);\n        }), a(b);\n      }, d.prototype.select = function (a) {\n        var b = this;if ((a.selected = !0, c(a.element).is("option"))) return a.element.selected = !0, void this.$element.trigger("change");if (this.$element.prop("multiple")) this.current(function (d) {\n          var e = [];a = [a], a.push.apply(a, d);for (var f = 0; f < a.length; f++) {\n            var g = a[f].id;-1 === c.inArray(g, e) && e.push(g);\n          }b.$element.val(e), b.$element.trigger("change");\n        });else {\n          var d = a.id;this.$element.val(d), this.$element.trigger("change");\n        }\n      }, d.prototype.unselect = function (a) {\n        var b = this;if (this.$element.prop("multiple")) return a.selected = !1, c(a.element).is("option") ? (a.element.selected = !1, void this.$element.trigger("change")) : void this.current(function (d) {\n          for (var e = [], f = 0; f < d.length; f++) {\n            var g = d[f].id;g !== a.id && -1 === c.inArray(g, e) && e.push(g);\n          }b.$element.val(e), b.$element.trigger("change");\n        });\n      }, d.prototype.bind = function (a, b) {\n        var c = this;this.container = a, a.on("select", function (a) {\n          c.select(a.data);\n        }), a.on("unselect", function (a) {\n          c.unselect(a.data);\n        });\n      }, d.prototype.destroy = function () {\n        this.$element.find("*").each(function () {\n          c.removeData(this, "data");\n        });\n      }, d.prototype.query = function (a, b) {\n        var d = [],\n            e = this,\n            f = this.$element.children();f.each(function () {\n          var b = c(this);if (b.is("option") || b.is("optgroup")) {\n            var f = e.item(b),\n                g = e.matches(a, f);null !== g && d.push(g);\n          }\n        }), b({ results: d });\n      }, d.prototype.addOptions = function (a) {\n        b.appendMany(this.$element, a);\n      }, d.prototype.option = function (a) {\n        var b;a.children ? (b = document.createElement("optgroup"), b.label = a.text) : (b = document.createElement("option"), void 0 !== b.textContent ? b.textContent = a.text : b.innerText = a.text), a.id && (b.value = a.id), a.disabled && (b.disabled = !0), a.selected && (b.selected = !0), a.title && (b.title = a.title);var d = c(b),\n            e = this._normalizeItem(a);return e.element = b, c.data(b, "data", e), d;\n      }, d.prototype.item = function (a) {\n        var b = {};if ((b = c.data(a[0], "data"), null != b)) return b;if (a.is("option")) b = { id: a.val(), text: a.text(), disabled: a.prop("disabled"), selected: a.prop("selected"), title: a.prop("title") };else if (a.is("optgroup")) {\n          b = { text: a.prop("label"), children: [], title: a.prop("title") };for (var d = a.children("option"), e = [], f = 0; f < d.length; f++) {\n            var g = c(d[f]),\n                h = this.item(g);e.push(h);\n          }b.children = e;\n        }return b = this._normalizeItem(b), b.element = a[0], c.data(a[0], "data", b), b;\n      }, d.prototype._normalizeItem = function (a) {\n        c.isPlainObject(a) || (a = { id: a, text: a }), a = c.extend({}, { text: "" }, a);var b = { selected: !1, disabled: !1 };return null != a.id && (a.id = a.id.toString()), null != a.text && (a.text = a.text.toString()), null == a._resultId && a.id && null != this.container && (a._resultId = this.generateResultId(this.container, a)), c.extend({}, b, a);\n      }, d.prototype.matches = function (a, b) {\n        var c = this.options.get("matcher");return c(a, b);\n      }, d;\n    }), b.define("select2/data/array", ["./select", "../utils", "jquery"], function (a, b, c) {\n      function d(a, b) {\n        var c = b.get("data") || [];d.__super__.constructor.call(this, a, b), this.addOptions(this.convertToOptions(c));\n      }return b.Extend(d, a), d.prototype.select = function (a) {\n        var b = this.$element.find("option").filter(function (b, c) {\n          return c.value == a.id.toString();\n        });0 === b.length && (b = this.option(a), this.addOptions(b)), d.__super__.select.call(this, a);\n      }, d.prototype.convertToOptions = function (a) {\n        function d(a) {\n          return function () {\n            return c(this).val() == a.id;\n          };\n        }for (var e = this, f = this.$element.find("option"), g = f.map(function () {\n          return e.item(c(this)).id;\n        }).get(), h = [], i = 0; i < a.length; i++) {\n          var j = this._normalizeItem(a[i]);if (c.inArray(j.id, g) >= 0) {\n            var k = f.filter(d(j)),\n                l = this.item(k),\n                m = c.extend(!0, {}, l, j),\n                n = this.option(m);k.replaceWith(n);\n          } else {\n            var o = this.option(j);if (j.children) {\n              var p = this.convertToOptions(j.children);b.appendMany(o, p);\n            }h.push(o);\n          }\n        }return h;\n      }, d;\n    }), b.define("select2/data/ajax", ["./array", "../utils", "jquery"], function (a, b, c) {\n      function d(a, b) {\n        this.ajaxOptions = this._applyDefaults(b.get("ajax")), null != this.ajaxOptions.processResults && (this.processResults = this.ajaxOptions.processResults), d.__super__.constructor.call(this, a, b);\n      }return b.Extend(d, a), d.prototype._applyDefaults = function (a) {\n        var b = { data: function data(a) {\n            return c.extend({}, a, { q: a.term });\n          }, transport: function transport(a, b, d) {\n            var e = c.ajax(a);return e.then(b), e.fail(d), e;\n          } };return c.extend({}, b, a, !0);\n      }, d.prototype.processResults = function (a) {\n        return a;\n      }, d.prototype.query = function (a, b) {\n        function d() {\n          var d = f.transport(f, function (d) {\n            var f = e.processResults(d, a);e.options.get("debug") && window.console && console.error && (f && f.results && c.isArray(f.results) || console.error("Select2: The AJAX results did not return an array in the `results` key of the response.")), b(f);\n          }, function () {});e._request = d;\n        }var e = this;null != this._request && (c.isFunction(this._request.abort) && this._request.abort(), this._request = null);var f = c.extend({ type: "GET" }, this.ajaxOptions);"function" == typeof f.url && (f.url = f.url.call(this.$element, a)), "function" == typeof f.data && (f.data = f.data.call(this.$element, a)), this.ajaxOptions.delay && "" !== a.term ? (this._queryTimeout && window.clearTimeout(this._queryTimeout), this._queryTimeout = window.setTimeout(d, this.ajaxOptions.delay)) : d();\n      }, d;\n    }), b.define("select2/data/tags", ["jquery"], function (a) {\n      function b(b, c, d) {\n        var e = d.get("tags"),\n            f = d.get("createTag");if ((void 0 !== f && (this.createTag = f), b.call(this, c, d), a.isArray(e))) for (var g = 0; g < e.length; g++) {\n          var h = e[g],\n              i = this._normalizeItem(h),\n              j = this.option(i);this.$element.append(j);\n        }\n      }return b.prototype.query = function (a, b, c) {\n        function d(a, f) {\n          for (var g = a.results, h = 0; h < g.length; h++) {\n            var i = g[h],\n                j = null != i.children && !d({ results: i.children }, !0),\n                k = i.text === b.term;if (k || j) return f ? !1 : (a.data = g, void c(a));\n          }if (f) return !0;var l = e.createTag(b);if (null != l) {\n            var m = e.option(l);m.attr("data-select2-tag", !0), e.addOptions([m]), e.insertTag(g, l);\n          }a.results = g, c(a);\n        }var e = this;return this._removeOldTags(), null == b.term || null != b.page ? void a.call(this, b, c) : void a.call(this, b, d);\n      }, b.prototype.createTag = function (b, c) {\n        var d = a.trim(c.term);return "" === d ? null : { id: d, text: d };\n      }, b.prototype.insertTag = function (a, b, c) {\n        b.unshift(c);\n      }, b.prototype._removeOldTags = function (b) {\n        var c = (this._lastTag, this.$element.find("option[data-select2-tag]"));c.each(function () {\n          this.selected || a(this).remove();\n        });\n      }, b;\n    }), b.define("select2/data/tokenizer", ["jquery"], function (a) {\n      function b(a, b, c) {\n        var d = c.get("tokenizer");void 0 !== d && (this.tokenizer = d), a.call(this, b, c);\n      }return b.prototype.bind = function (a, b, c) {\n        a.call(this, b, c), this.$search = b.dropdown.$search || b.selection.$search || c.find(".select2-search__field");\n      }, b.prototype.query = function (a, b, c) {\n        function d(a) {\n          e.trigger("select", { data: a });\n        }var e = this;b.term = b.term || "";var f = this.tokenizer(b, this.options, d);f.term !== b.term && (this.$search.length && (this.$search.val(f.term), this.$search.focus()), b.term = f.term), a.call(this, b, c);\n      }, b.prototype.tokenizer = function (b, c, d, e) {\n        for (var f = d.get("tokenSeparators") || [], g = c.term, h = 0, i = this.createTag || function (a) {\n          return { id: a.term, text: a.term };\n        }; h < g.length;) {\n          var j = g[h];if (-1 !== a.inArray(j, f)) {\n            var k = g.substr(0, h),\n                l = a.extend({}, c, { term: k }),\n                m = i(l);null != m ? (e(m), g = g.substr(h + 1) || "", h = 0) : h++;\n          } else h++;\n        }return { term: g };\n      }, b;\n    }), b.define("select2/data/minimumInputLength", [], function () {\n      function a(a, b, c) {\n        this.minimumInputLength = c.get("minimumInputLength"), a.call(this, b, c);\n      }return a.prototype.query = function (a, b, c) {\n        return b.term = b.term || "", b.term.length < this.minimumInputLength ? void this.trigger("results:message", { message: "inputTooShort", args: { minimum: this.minimumInputLength, input: b.term, params: b } }) : void a.call(this, b, c);\n      }, a;\n    }), b.define("select2/data/maximumInputLength", [], function () {\n      function a(a, b, c) {\n        this.maximumInputLength = c.get("maximumInputLength"), a.call(this, b, c);\n      }return a.prototype.query = function (a, b, c) {\n        return b.term = b.term || "", this.maximumInputLength > 0 && b.term.length > this.maximumInputLength ? void this.trigger("results:message", { message: "inputTooLong", args: { maximum: this.maximumInputLength, input: b.term, params: b } }) : void a.call(this, b, c);\n      }, a;\n    }), b.define("select2/data/maximumSelectionLength", [], function () {\n      function a(a, b, c) {\n        this.maximumSelectionLength = c.get("maximumSelectionLength"), a.call(this, b, c);\n      }return a.prototype.query = function (a, b, c) {\n        var d = this;this.current(function (e) {\n          var f = null != e ? e.length : 0;return d.maximumSelectionLength > 0 && f >= d.maximumSelectionLength ? void d.trigger("results:message", { message: "maximumSelected", args: { maximum: d.maximumSelectionLength } }) : void a.call(d, b, c);\n        });\n      }, a;\n    }), b.define("select2/dropdown", ["jquery", "./utils"], function (a, b) {\n      function c(a, b) {\n        this.$element = a, this.options = b, c.__super__.constructor.call(this);\n      }return b.Extend(c, b.Observable), c.prototype.render = function () {\n        var b = a(\'<span class="select2-dropdown"><span class="select2-results"></span></span>\');return b.attr("dir", this.options.get("dir")), this.$dropdown = b, b;\n      }, c.prototype.bind = function () {}, c.prototype.position = function (a, b) {}, c.prototype.destroy = function () {\n        this.$dropdown.remove();\n      }, c;\n    }), b.define("select2/dropdown/search", ["jquery", "../utils"], function (a, b) {\n      function c() {}return c.prototype.render = function (b) {\n        var c = b.call(this),\n            d = a(\'<span class="select2-search select2-search--dropdown"><input class="select2-search__field" type="search" tabindex="-1" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="textbox" /></span>\');return this.$searchContainer = d, this.$search = d.find("input"), c.prepend(d), c;\n      }, c.prototype.bind = function (b, c, d) {\n        var e = this;b.call(this, c, d), this.$search.on("keydown", function (a) {\n          e.trigger("keypress", a), e._keyUpPrevented = a.isDefaultPrevented();\n        }), this.$search.on("input", function (b) {\n          a(this).off("keyup");\n        }), this.$search.on("keyup input", function (a) {\n          e.handleSearch(a);\n        }), c.on("open", function () {\n          e.$search.attr("tabindex", 0), e.$search.focus(), window.setTimeout(function () {\n            e.$search.focus();\n          }, 0);\n        }), c.on("close", function () {\n          e.$search.attr("tabindex", -1), e.$search.val("");\n        }), c.on("results:all", function (a) {\n          if (null == a.query.term || "" === a.query.term) {\n            var b = e.showSearch(a);b ? e.$searchContainer.removeClass("select2-search--hide") : e.$searchContainer.addClass("select2-search--hide");\n          }\n        });\n      }, c.prototype.handleSearch = function (a) {\n        if (!this._keyUpPrevented) {\n          var b = this.$search.val();this.trigger("query", { term: b });\n        }this._keyUpPrevented = !1;\n      }, c.prototype.showSearch = function (a, b) {\n        return !0;\n      }, c;\n    }), b.define("select2/dropdown/hidePlaceholder", [], function () {\n      function a(a, b, c, d) {\n        this.placeholder = this.normalizePlaceholder(c.get("placeholder")), a.call(this, b, c, d);\n      }return a.prototype.append = function (a, b) {\n        b.results = this.removePlaceholder(b.results), a.call(this, b);\n      }, a.prototype.normalizePlaceholder = function (a, b) {\n        return "string" == typeof b && (b = { id: "", text: b }), b;\n      }, a.prototype.removePlaceholder = function (a, b) {\n        for (var c = b.slice(0), d = b.length - 1; d >= 0; d--) {\n          var e = b[d];this.placeholder.id === e.id && c.splice(d, 1);\n        }return c;\n      }, a;\n    }), b.define("select2/dropdown/infiniteScroll", ["jquery"], function (a) {\n      function b(a, b, c, d) {\n        this.lastParams = {}, a.call(this, b, c, d), this.$loadingMore = this.createLoadingMore(), this.loading = !1;\n      }return b.prototype.append = function (a, b) {\n        this.$loadingMore.remove(), this.loading = !1, a.call(this, b), this.showLoadingMore(b) && this.$results.append(this.$loadingMore);\n      }, b.prototype.bind = function (b, c, d) {\n        var e = this;b.call(this, c, d), c.on("query", function (a) {\n          e.lastParams = a, e.loading = !0;\n        }), c.on("query:append", function (a) {\n          e.lastParams = a, e.loading = !0;\n        }), this.$results.on("scroll", function () {\n          var b = a.contains(document.documentElement, e.$loadingMore[0]);if (!e.loading && b) {\n            var c = e.$results.offset().top + e.$results.outerHeight(!1),\n                d = e.$loadingMore.offset().top + e.$loadingMore.outerHeight(!1);c + 50 >= d && e.loadMore();\n          }\n        });\n      }, b.prototype.loadMore = function () {\n        this.loading = !0;var b = a.extend({}, { page: 1 }, this.lastParams);b.page++, this.trigger("query:append", b);\n      }, b.prototype.showLoadingMore = function (a, b) {\n        return b.pagination && b.pagination.more;\n      }, b.prototype.createLoadingMore = function () {\n        var b = a(\'<li class="select2-results__option select2-results__option--load-more"role="treeitem" aria-disabled="true"></li>\'),\n            c = this.options.get("translations").get("loadingMore");return b.html(c(this.lastParams)), b;\n      }, b;\n    }), b.define("select2/dropdown/attachBody", ["jquery", "../utils"], function (a, b) {\n      function c(a, b, c) {\n        this.$dropdownParent = c.get("dropdownParent") || document.body, a.call(this, b, c);\n      }return c.prototype.bind = function (a, b, c) {\n        var d = this,\n            e = !1;a.call(this, b, c), b.on("open", function () {\n          d._showDropdown(), d._attachPositioningHandler(b), e || (e = !0, b.on("results:all", function () {\n            d._positionDropdown(), d._resizeDropdown();\n          }), b.on("results:append", function () {\n            d._positionDropdown(), d._resizeDropdown();\n          }));\n        }), b.on("close", function () {\n          d._hideDropdown(), d._detachPositioningHandler(b);\n        }), this.$dropdownContainer.on("mousedown", function (a) {\n          a.stopPropagation();\n        });\n      }, c.prototype.destroy = function (a) {\n        a.call(this), this.$dropdownContainer.remove();\n      }, c.prototype.position = function (a, b, c) {\n        b.attr("class", c.attr("class")), b.removeClass("select2"), b.addClass("select2-container--open"), b.css({ position: "absolute", top: -999999 }), this.$container = c;\n      }, c.prototype.render = function (b) {\n        var c = a("<span></span>"),\n            d = b.call(this);return c.append(d), this.$dropdownContainer = c, c;\n      }, c.prototype._hideDropdown = function (a) {\n        this.$dropdownContainer.detach();\n      }, c.prototype._attachPositioningHandler = function (c) {\n        var d = this,\n            e = "scroll.select2." + c.id,\n            f = "resize.select2." + c.id,\n            g = "orientationchange.select2." + c.id,\n            h = this.$container.parents().filter(b.hasScroll);h.each(function () {\n          a(this).data("select2-scroll-position", { x: a(this).scrollLeft(), y: a(this).scrollTop() });\n        }), h.on(e, function (b) {\n          var c = a(this).data("select2-scroll-position");a(this).scrollTop(c.y);\n        }), a(window).on(e + " " + f + " " + g, function (a) {\n          d._positionDropdown(), d._resizeDropdown();\n        });\n      }, c.prototype._detachPositioningHandler = function (c) {\n        var d = "scroll.select2." + c.id,\n            e = "resize.select2." + c.id,\n            f = "orientationchange.select2." + c.id,\n            g = this.$container.parents().filter(b.hasScroll);g.off(d), a(window).off(d + " " + e + " " + f);\n      }, c.prototype._positionDropdown = function () {\n        var b = a(window),\n            c = this.$dropdown.hasClass("select2-dropdown--above"),\n            d = this.$dropdown.hasClass("select2-dropdown--below"),\n            e = null,\n            f = (this.$container.position(), this.$container.offset());f.bottom = f.top + this.$container.outerHeight(!1);var g = { height: this.$container.outerHeight(!1) };g.top = f.top, g.bottom = f.top + g.height;var h = { height: this.$dropdown.outerHeight(!1) },\n            i = { top: b.scrollTop(), bottom: b.scrollTop() + b.height() },\n            j = i.top < f.top - h.height,\n            k = i.bottom > f.bottom + h.height,\n            l = { left: f.left, top: g.bottom };c || d || (e = "below"), k || !j || c ? !j && k && c && (e = "below") : e = "above", ("above" == e || c && "below" !== e) && (l.top = g.top - h.height), null != e && (this.$dropdown.removeClass("select2-dropdown--below select2-dropdown--above").addClass("select2-dropdown--" + e), this.$container.removeClass("select2-container--below select2-container--above").addClass("select2-container--" + e)), this.$dropdownContainer.css(l);\n      }, c.prototype._resizeDropdown = function () {\n        var a = { width: this.$container.outerWidth(!1) + "px" };this.options.get("dropdownAutoWidth") && (a.minWidth = a.width, a.width = "auto"), this.$dropdown.css(a);\n      }, c.prototype._showDropdown = function (a) {\n        this.$dropdownContainer.appendTo(this.$dropdownParent), this._positionDropdown(), this._resizeDropdown();\n      }, c;\n    }), b.define("select2/dropdown/minimumResultsForSearch", [], function () {\n      function a(b) {\n        for (var c = 0, d = 0; d < b.length; d++) {\n          var e = b[d];e.children ? c += a(e.children) : c++;\n        }return c;\n      }function b(a, b, c, d) {\n        this.minimumResultsForSearch = c.get("minimumResultsForSearch"), this.minimumResultsForSearch < 0 && (this.minimumResultsForSearch = 1 / 0), a.call(this, b, c, d);\n      }return b.prototype.showSearch = function (b, c) {\n        return a(c.data.results) < this.minimumResultsForSearch ? !1 : b.call(this, c);\n      }, b;\n    }), b.define("select2/dropdown/selectOnClose", [], function () {\n      function a() {}return a.prototype.bind = function (a, b, c) {\n        var d = this;a.call(this, b, c), b.on("close", function () {\n          d._handleSelectOnClose();\n        });\n      }, a.prototype._handleSelectOnClose = function () {\n        var a = this.getHighlightedResults();a.length < 1 || this.trigger("select", { data: a.data("data") });\n      }, a;\n    }), b.define("select2/dropdown/closeOnSelect", [], function () {\n      function a() {}return a.prototype.bind = function (a, b, c) {\n        var d = this;a.call(this, b, c), b.on("select", function (a) {\n          d._selectTriggered(a);\n        }), b.on("unselect", function (a) {\n          d._selectTriggered(a);\n        });\n      }, a.prototype._selectTriggered = function (a, b) {\n        var c = b.originalEvent;c && c.ctrlKey || this.trigger("close", {});\n      }, a;\n    }), b.define("select2/i18n/en", [], function () {\n      return { errorLoading: function errorLoading() {\n          return "The results could not be loaded.";\n        }, inputTooLong: function inputTooLong(a) {\n          var b = a.input.length - a.maximum,\n              c = "Please delete " + b + " character";return 1 != b && (c += "s"), c;\n        }, inputTooShort: function inputTooShort(a) {\n          var b = a.minimum - a.input.length,\n              c = "Please enter " + b + " or more characters";return c;\n        }, loadingMore: function loadingMore() {\n          return "Loading more results…";\n        }, maximumSelected: function maximumSelected(a) {\n          var b = "You can only select " + a.maximum + " item";return 1 != a.maximum && (b += "s"), b;\n        }, noResults: function noResults() {\n          return "No results found";\n        }, searching: function searching() {\n          return "Searching…";\n        } };\n    }), b.define("select2/defaults", ["jquery", "require", "./results", "./selection/single", "./selection/multiple", "./selection/placeholder", "./selection/allowClear", "./selection/search", "./selection/eventRelay", "./utils", "./translation", "./diacritics", "./data/select", "./data/array", "./data/ajax", "./data/tags", "./data/tokenizer", "./data/minimumInputLength", "./data/maximumInputLength", "./data/maximumSelectionLength", "./dropdown", "./dropdown/search", "./dropdown/hidePlaceholder", "./dropdown/infiniteScroll", "./dropdown/attachBody", "./dropdown/minimumResultsForSearch", "./dropdown/selectOnClose", "./dropdown/closeOnSelect", "./i18n/en"], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C) {\n      function D() {\n        this.reset();\n      }D.prototype.apply = function (l) {\n        if ((l = a.extend({}, this.defaults, l), null == l.dataAdapter)) {\n          if ((null != l.ajax ? l.dataAdapter = o : null != l.data ? l.dataAdapter = n : l.dataAdapter = m, l.minimumInputLength > 0 && (l.dataAdapter = j.Decorate(l.dataAdapter, r)), l.maximumInputLength > 0 && (l.dataAdapter = j.Decorate(l.dataAdapter, s)), l.maximumSelectionLength > 0 && (l.dataAdapter = j.Decorate(l.dataAdapter, t)), l.tags && (l.dataAdapter = j.Decorate(l.dataAdapter, p)), (null != l.tokenSeparators || null != l.tokenizer) && (l.dataAdapter = j.Decorate(l.dataAdapter, q)), null != l.query)) {\n            var C = b(l.amdBase + "compat/query");l.dataAdapter = j.Decorate(l.dataAdapter, C);\n          }if (null != l.initSelection) {\n            var D = b(l.amdBase + "compat/initSelection");l.dataAdapter = j.Decorate(l.dataAdapter, D);\n          }\n        }if ((null == l.resultsAdapter && (l.resultsAdapter = c, null != l.ajax && (l.resultsAdapter = j.Decorate(l.resultsAdapter, x)), null != l.placeholder && (l.resultsAdapter = j.Decorate(l.resultsAdapter, w)), l.selectOnClose && (l.resultsAdapter = j.Decorate(l.resultsAdapter, A))), null == l.dropdownAdapter)) {\n          if (l.multiple) l.dropdownAdapter = u;else {\n            var E = j.Decorate(u, v);l.dropdownAdapter = E;\n          }if ((0 !== l.minimumResultsForSearch && (l.dropdownAdapter = j.Decorate(l.dropdownAdapter, z)), l.closeOnSelect && (l.dropdownAdapter = j.Decorate(l.dropdownAdapter, B)), null != l.dropdownCssClass || null != l.dropdownCss || null != l.adaptDropdownCssClass)) {\n            var F = b(l.amdBase + "compat/dropdownCss");l.dropdownAdapter = j.Decorate(l.dropdownAdapter, F);\n          }l.dropdownAdapter = j.Decorate(l.dropdownAdapter, y);\n        }if (null == l.selectionAdapter) {\n          if ((l.multiple ? l.selectionAdapter = e : l.selectionAdapter = d, null != l.placeholder && (l.selectionAdapter = j.Decorate(l.selectionAdapter, f)), l.allowClear && (l.selectionAdapter = j.Decorate(l.selectionAdapter, g)), l.multiple && (l.selectionAdapter = j.Decorate(l.selectionAdapter, h)), null != l.containerCssClass || null != l.containerCss || null != l.adaptContainerCssClass)) {\n            var G = b(l.amdBase + "compat/containerCss");l.selectionAdapter = j.Decorate(l.selectionAdapter, G);\n          }l.selectionAdapter = j.Decorate(l.selectionAdapter, i);\n        }if ("string" == typeof l.language) if (l.language.indexOf("-") > 0) {\n          var H = l.language.split("-"),\n              I = H[0];l.language = [l.language, I];\n        } else l.language = [l.language];if (a.isArray(l.language)) {\n          var J = new k();l.language.push("en");for (var K = l.language, L = 0; L < K.length; L++) {\n            var M = K[L],\n                N = {};try {\n              N = k.loadPath(M);\n            } catch (O) {\n              try {\n                M = this.defaults.amdLanguageBase + M, N = k.loadPath(M);\n              } catch (P) {\n                l.debug && window.console && console.warn && console.warn(\'Select2: The language file for "\' + M + \'" could not be automatically loaded. A fallback will be used instead.\');continue;\n              }\n            }J.extend(N);\n          }l.translations = J;\n        } else {\n          var Q = k.loadPath(this.defaults.amdLanguageBase + "en"),\n              R = new k(l.language);R.extend(Q), l.translations = R;\n        }return l;\n      }, D.prototype.reset = function () {\n        function b(a) {\n          function b(a) {\n            return l[a] || a;\n          }return a.replace(/[^\\u0000-\\u007E]/g, b);\n        }function c(d, e) {\n          if ("" === a.trim(d.term)) return e;if (e.children && e.children.length > 0) {\n            for (var f = a.extend(!0, {}, e), g = e.children.length - 1; g >= 0; g--) {\n              var h = e.children[g],\n                  i = c(d, h);null == i && f.children.splice(g, 1);\n            }return f.children.length > 0 ? f : c(d, f);\n          }var j = b(e.text).toUpperCase(),\n              k = b(d.term).toUpperCase();return j.indexOf(k) > -1 ? e : null;\n        }this.defaults = { amdBase: "./", amdLanguageBase: "./i18n/", closeOnSelect: !0, debug: !1, dropdownAutoWidth: !1, escapeMarkup: j.escapeMarkup, language: C, matcher: c, minimumInputLength: 0, maximumInputLength: 0, maximumSelectionLength: 0, minimumResultsForSearch: 0, selectOnClose: !1, sorter: function sorter(a) {\n            return a;\n          }, templateResult: function templateResult(a) {\n            return a.text;\n          }, templateSelection: function templateSelection(a) {\n            return a.text;\n          }, theme: "default", width: "resolve" };\n      }, D.prototype.set = function (b, c) {\n        var d = a.camelCase(b),\n            e = {};e[d] = c;var f = j._convertData(e);a.extend(this.defaults, f);\n      };var E = new D();return E;\n    }), b.define("select2/options", ["require", "jquery", "./defaults", "./utils"], function (a, b, c, d) {\n      function e(b, e) {\n        if ((this.options = b, null != e && this.fromElement(e), this.options = c.apply(this.options), e && e.is("input"))) {\n          var f = a(this.get("amdBase") + "compat/inputData");this.options.dataAdapter = d.Decorate(this.options.dataAdapter, f);\n        }\n      }return e.prototype.fromElement = function (a) {\n        var c = ["select2"];null == this.options.multiple && (this.options.multiple = a.prop("multiple")), null == this.options.disabled && (this.options.disabled = a.prop("disabled")), null == this.options.language && (a.prop("lang") ? this.options.language = a.prop("lang").toLowerCase() : a.closest("[lang]").prop("lang") && (this.options.language = a.closest("[lang]").prop("lang"))), null == this.options.dir && (a.prop("dir") ? this.options.dir = a.prop("dir") : a.closest("[dir]").prop("dir") ? this.options.dir = a.closest("[dir]").prop("dir") : this.options.dir = "ltr"), a.prop("disabled", this.options.disabled), a.prop("multiple", this.options.multiple), a.data("select2Tags") && (this.options.debug && window.console && console.warn && console.warn(\'Select2: The `data-select2-tags` attribute has been changed to use the `data-data` and `data-tags="true"` attributes and will be removed in future versions of Select2.\'), a.data("data", a.data("select2Tags")), a.data("tags", !0)), a.data("ajaxUrl") && (this.options.debug && window.console && console.warn && console.warn("Select2: The `data-ajax-url` attribute has been changed to `data-ajax--url` and support for the old attribute will be removed in future versions of Select2."), a.attr("ajax--url", a.data("ajaxUrl")), a.data("ajax--url", a.data("ajaxUrl")));var e = {};e = b.fn.jquery && "1." == b.fn.jquery.substr(0, 2) && a[0].dataset ? b.extend(!0, {}, a[0].dataset, a.data()) : a.data();var f = b.extend(!0, {}, e);f = d._convertData(f);for (var g in f) {\n          b.inArray(g, c) > -1 || (b.isPlainObject(this.options[g]) ? b.extend(this.options[g], f[g]) : this.options[g] = f[g]);\n        }return this;\n      }, e.prototype.get = function (a) {\n        return this.options[a];\n      }, e.prototype.set = function (a, b) {\n        this.options[a] = b;\n      }, e;\n    }), b.define("select2/core", ["jquery", "./options", "./utils", "./keys"], function (a, b, c, d) {\n      var e = function e(a, c) {\n        null != a.data("select2") && a.data("select2").destroy(), this.$element = a, this.id = this._generateId(a), c = c || {}, this.options = new b(c, a), e.__super__.constructor.call(this);var d = a.attr("tabindex") || 0;a.data("old-tabindex", d), a.attr("tabindex", "-1");var f = this.options.get("dataAdapter");this.dataAdapter = new f(a, this.options);var g = this.render();this._placeContainer(g);var h = this.options.get("selectionAdapter");this.selection = new h(a, this.options), this.$selection = this.selection.render(), this.selection.position(this.$selection, g);var i = this.options.get("dropdownAdapter");this.dropdown = new i(a, this.options), this.$dropdown = this.dropdown.render(), this.dropdown.position(this.$dropdown, g);var j = this.options.get("resultsAdapter");this.results = new j(a, this.options, this.dataAdapter), this.$results = this.results.render(), this.results.position(this.$results, this.$dropdown);var k = this;this._bindAdapters(), this._registerDomEvents(), this._registerDataEvents(), this._registerSelectionEvents(), this._registerDropdownEvents(), this._registerResultsEvents(), this._registerEvents(), this.dataAdapter.current(function (a) {\n          k.trigger("selection:update", { data: a });\n        }), a.addClass("select2-hidden-accessible"), a.attr("aria-hidden", "true"), this._syncAttributes(), a.data("select2", this);\n      };return c.Extend(e, c.Observable), e.prototype._generateId = function (a) {\n        var b = "";return b = null != a.attr("id") ? a.attr("id") : null != a.attr("name") ? a.attr("name") + "-" + c.generateChars(2) : c.generateChars(4), b = "select2-" + b;\n      }, e.prototype._placeContainer = function (a) {\n        a.insertAfter(this.$element);var b = this._resolveWidth(this.$element, this.options.get("width"));null != b && a.css("width", b);\n      }, e.prototype._resolveWidth = function (a, b) {\n        var c = /^width:(([-+]?([0-9]*\\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;if ("resolve" == b) {\n          var d = this._resolveWidth(a, "style");return null != d ? d : this._resolveWidth(a, "element");\n        }if ("element" == b) {\n          var e = a.outerWidth(!1);return 0 >= e ? "auto" : e + "px";\n        }if ("style" == b) {\n          var f = a.attr("style");if ("string" != typeof f) return null;for (var g = f.split(";"), h = 0, i = g.length; i > h; h += 1) {\n            var j = g[h].replace(/\\s/g, ""),\n                k = j.match(c);if (null !== k && k.length >= 1) return k[1];\n          }return null;\n        }return b;\n      }, e.prototype._bindAdapters = function () {\n        this.dataAdapter.bind(this, this.$container), this.selection.bind(this, this.$container), this.dropdown.bind(this, this.$container), this.results.bind(this, this.$container);\n      }, e.prototype._registerDomEvents = function () {\n        var b = this;this.$element.on("change.select2", function () {\n          b.dataAdapter.current(function (a) {\n            b.trigger("selection:update", { data: a });\n          });\n        }), this._sync = c.bind(this._syncAttributes, this), this.$element[0].attachEvent && this.$element[0].attachEvent("onpropertychange", this._sync);var d = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;null != d ? (this._observer = new d(function (c) {\n          a.each(c, b._sync);\n        }), this._observer.observe(this.$element[0], { attributes: !0, subtree: !1 })) : this.$element[0].addEventListener && this.$element[0].addEventListener("DOMAttrModified", b._sync, !1);\n      }, e.prototype._registerDataEvents = function () {\n        var a = this;this.dataAdapter.on("*", function (b, c) {\n          a.trigger(b, c);\n        });\n      }, e.prototype._registerSelectionEvents = function () {\n        var b = this,\n            c = ["toggle", "focus"];this.selection.on("toggle", function () {\n          b.toggleDropdown();\n        }), this.selection.on("focus", function (a) {\n          b.focus(a);\n        }), this.selection.on("*", function (d, e) {\n          -1 === a.inArray(d, c) && b.trigger(d, e);\n        });\n      }, e.prototype._registerDropdownEvents = function () {\n        var a = this;this.dropdown.on("*", function (b, c) {\n          a.trigger(b, c);\n        });\n      }, e.prototype._registerResultsEvents = function () {\n        var a = this;this.results.on("*", function (b, c) {\n          a.trigger(b, c);\n        });\n      }, e.prototype._registerEvents = function () {\n        var a = this;this.on("open", function () {\n          a.$container.addClass("select2-container--open");\n        }), this.on("close", function () {\n          a.$container.removeClass("select2-container--open");\n        }), this.on("enable", function () {\n          a.$container.removeClass("select2-container--disabled");\n        }), this.on("disable", function () {\n          a.$container.addClass("select2-container--disabled");\n        }), this.on("blur", function () {\n          a.$container.removeClass("select2-container--focus");\n        }), this.on("query", function (b) {\n          a.isOpen() || a.trigger("open", {}), this.dataAdapter.query(b, function (c) {\n            a.trigger("results:all", { data: c, query: b });\n          });\n        }), this.on("query:append", function (b) {\n          this.dataAdapter.query(b, function (c) {\n            a.trigger("results:append", { data: c, query: b });\n          });\n        }), this.on("keypress", function (b) {\n          var c = b.which;a.isOpen() ? c === d.ESC || c === d.TAB || c === d.UP && b.altKey ? (a.close(), b.preventDefault()) : c === d.ENTER ? (a.trigger("results:select", {}), b.preventDefault()) : c === d.SPACE && b.ctrlKey ? (a.trigger("results:toggle", {}), b.preventDefault()) : c === d.UP ? (a.trigger("results:previous", {}), b.preventDefault()) : c === d.DOWN && (a.trigger("results:next", {}), b.preventDefault()) : (c === d.ENTER || c === d.SPACE || c === d.DOWN && b.altKey) && (a.open(), b.preventDefault());\n        });\n      }, e.prototype._syncAttributes = function () {\n        this.options.set("disabled", this.$element.prop("disabled")), this.options.get("disabled") ? (this.isOpen() && this.close(), this.trigger("disable", {})) : this.trigger("enable", {});\n      }, e.prototype.trigger = function (a, b) {\n        var c = e.__super__.trigger,\n            d = { open: "opening", close: "closing", select: "selecting", unselect: "unselecting" };if ((void 0 === b && (b = {}), a in d)) {\n          var f = d[a],\n              g = { prevented: !1, name: a, args: b };if ((c.call(this, f, g), g.prevented)) return void (b.prevented = !0);\n        }c.call(this, a, b);\n      }, e.prototype.toggleDropdown = function () {\n        this.options.get("disabled") || (this.isOpen() ? this.close() : this.open());\n      }, e.prototype.open = function () {\n        this.isOpen() || this.trigger("query", {});\n      }, e.prototype.close = function () {\n        this.isOpen() && this.trigger("close", {});\n      }, e.prototype.isOpen = function () {\n        return this.$container.hasClass("select2-container--open");\n      }, e.prototype.hasFocus = function () {\n        return this.$container.hasClass("select2-container--focus");\n      }, e.prototype.focus = function (a) {\n        this.hasFocus() || (this.$container.addClass("select2-container--focus"), this.trigger("focus", {}));\n      }, e.prototype.enable = function (a) {\n        this.options.get("debug") && window.console && console.warn && console.warn(\'Select2: The `select2("enable")` method has been deprecated and will be removed in later Select2 versions. Use $element.prop("disabled") instead.\'), (null == a || 0 === a.length) && (a = [!0]);var b = !a[0];this.$element.prop("disabled", b);\n      }, e.prototype.data = function () {\n        this.options.get("debug") && arguments.length > 0 && window.console && console.warn && console.warn(\'Select2: Data can no longer be set using `select2("data")`. You should consider setting the value instead using `$element.val()`.\');var a = [];return this.dataAdapter.current(function (b) {\n          a = b;\n        }), a;\n      }, e.prototype.val = function (b) {\n        if ((this.options.get("debug") && window.console && console.warn && console.warn(\'Select2: The `select2("val")` method has been deprecated and will be removed in later Select2 versions. Use $element.val() instead.\'), null == b || 0 === b.length)) return this.$element.val();var c = b[0];a.isArray(c) && (c = a.map(c, function (a) {\n          return a.toString();\n        })), this.$element.val(c).trigger("change");\n      }, e.prototype.destroy = function () {\n        this.$container.remove(), this.$element[0].detachEvent && this.$element[0].detachEvent("onpropertychange", this._sync), null != this._observer ? (this._observer.disconnect(), this._observer = null) : this.$element[0].removeEventListener && this.$element[0].removeEventListener("DOMAttrModified", this._sync, !1), this._sync = null, this.$element.off(".select2"), this.$element.attr("tabindex", this.$element.data("old-tabindex")), this.$element.removeClass("select2-hidden-accessible"), this.$element.attr("aria-hidden", "false"), this.$element.removeData("select2"), this.dataAdapter.destroy(), this.selection.destroy(), this.dropdown.destroy(), this.results.destroy(), this.dataAdapter = null, this.selection = null, this.dropdown = null, this.results = null;\n      }, e.prototype.render = function () {\n        var b = a(\'<span class="select2 select2-container"><span class="selection"></span><span class="dropdown-wrapper" aria-hidden="true"></span></span>\');return b.attr("dir", this.options.get("dir")), this.$container = b, this.$container.addClass("select2-container--" + this.options.get("theme")), b.data("element", this.$element), b;\n      }, e;\n    }), b.define("select2/compat/utils", ["jquery"], function (a) {\n      function b(b, c, d) {\n        var e,\n            f,\n            g = [];e = a.trim(b.attr("class")), e && (e = "" + e, a(e.split(/\\s+/)).each(function () {\n          0 === this.indexOf("select2-") && g.push(this);\n        })), e = a.trim(c.attr("class")), e && (e = "" + e, a(e.split(/\\s+/)).each(function () {\n          0 !== this.indexOf("select2-") && (f = d(this), null != f && g.push(f));\n        })), b.attr("class", g.join(" "));\n      }return { syncCssClasses: b };\n    }), b.define("select2/compat/containerCss", ["jquery", "./utils"], function (a, b) {\n      function c(a) {\n        return null;\n      }function d() {}return d.prototype.render = function (d) {\n        var e = d.call(this),\n            f = this.options.get("containerCssClass") || "";a.isFunction(f) && (f = f(this.$element));var g = this.options.get("adaptContainerCssClass");if ((g = g || c, -1 !== f.indexOf(":all:"))) {\n          f = f.replace(":all:", "");var h = g;g = function (a) {\n            var b = h(a);return null != b ? b + " " + a : a;\n          };\n        }var i = this.options.get("containerCss") || {};return a.isFunction(i) && (i = i(this.$element)), b.syncCssClasses(e, this.$element, g), e.css(i), e.addClass(f), e;\n      }, d;\n    }), b.define("select2/compat/dropdownCss", ["jquery", "./utils"], function (a, b) {\n      function c(a) {\n        return null;\n      }function d() {}return d.prototype.render = function (d) {\n        var e = d.call(this),\n            f = this.options.get("dropdownCssClass") || "";a.isFunction(f) && (f = f(this.$element));var g = this.options.get("adaptDropdownCssClass");if ((g = g || c, -1 !== f.indexOf(":all:"))) {\n          f = f.replace(":all:", "");var h = g;g = function (a) {\n            var b = h(a);return null != b ? b + " " + a : a;\n          };\n        }var i = this.options.get("dropdownCss") || {};return a.isFunction(i) && (i = i(this.$element)), b.syncCssClasses(e, this.$element, g), e.css(i), e.addClass(f), e;\n      }, d;\n    }), b.define("select2/compat/initSelection", ["jquery"], function (a) {\n      function b(a, b, c) {\n        c.get("debug") && window.console && console.warn && console.warn("Select2: The `initSelection` option has been deprecated in favor of a custom data adapter that overrides the `current` method. This method is now called multiple times instead of a single time when the instance is initialized. Support will be removed for the `initSelection` option in future versions of Select2"), this.initSelection = c.get("initSelection"), this._isInitialized = !1, a.call(this, b, c);\n      }return b.prototype.current = function (b, c) {\n        var d = this;return this._isInitialized ? void b.call(this, c) : void this.initSelection.call(null, this.$element, function (b) {\n          d._isInitialized = !0, a.isArray(b) || (b = [b]), c(b);\n        });\n      }, b;\n    }), b.define("select2/compat/inputData", ["jquery"], function (a) {\n      function b(a, b, c) {\n        this._currentData = [], this._valueSeparator = c.get("valueSeparator") || ",", "hidden" === b.prop("type") && c.get("debug") && console && console.warn && console.warn("Select2: Using a hidden input with Select2 is no longer supported and may stop working in the future. It is recommended to use a `<select>` element instead."), a.call(this, b, c);\n      }return b.prototype.current = function (b, c) {\n        function d(b, c) {\n          var e = [];return b.selected || -1 !== a.inArray(b.id, c) ? (b.selected = !0, e.push(b)) : b.selected = !1, b.children && e.push.apply(e, d(b.children, c)), e;\n        }for (var e = [], f = 0; f < this._currentData.length; f++) {\n          var g = this._currentData[f];e.push.apply(e, d(g, this.$element.val().split(this._valueSeparator)));\n        }c(e);\n      }, b.prototype.select = function (b, c) {\n        if (this.options.get("multiple")) {\n          var d = this.$element.val();d += this._valueSeparator + c.id, this.$element.val(d), this.$element.trigger("change");\n        } else this.current(function (b) {\n          a.map(b, function (a) {\n            a.selected = !1;\n          });\n        }), this.$element.val(c.id), this.$element.trigger("change");\n      }, b.prototype.unselect = function (a, b) {\n        var c = this;b.selected = !1, this.current(function (a) {\n          for (var d = [], e = 0; e < a.length; e++) {\n            var f = a[e];b.id != f.id && d.push(f.id);\n          }c.$element.val(d.join(c._valueSeparator)), c.$element.trigger("change");\n        });\n      }, b.prototype.query = function (a, b, c) {\n        for (var d = [], e = 0; e < this._currentData.length; e++) {\n          var f = this._currentData[e],\n              g = this.matches(b, f);null !== g && d.push(g);\n        }c({ results: d });\n      }, b.prototype.addOptions = function (b, c) {\n        var d = a.map(c, function (b) {\n          return a.data(b[0], "data");\n        });this._currentData.push.apply(this._currentData, d);\n      }, b;\n    }), b.define("select2/compat/matcher", ["jquery"], function (a) {\n      function b(b) {\n        function c(c, d) {\n          var e = a.extend(!0, {}, d);if (null == c.term || "" === a.trim(c.term)) return e;if (d.children) {\n            for (var f = d.children.length - 1; f >= 0; f--) {\n              var g = d.children[f],\n                  h = b(c.term, g.text, g);h || e.children.splice(f, 1);\n            }if (e.children.length > 0) return e;\n          }return b(c.term, d.text, d) ? e : null;\n        }return c;\n      }return b;\n    }), b.define("select2/compat/query", [], function () {\n      function a(a, b, c) {\n        c.get("debug") && window.console && console.warn && console.warn("Select2: The `query` option has been deprecated in favor of a custom data adapter that overrides the `query` method. Support will be removed for the `query` option in future versions of Select2."), a.call(this, b, c);\n      }return a.prototype.query = function (a, b, c) {\n        b.callback = c;var d = this.options.get("query");d.call(null, b);\n      }, a;\n    }), b.define("select2/dropdown/attachContainer", [], function () {\n      function a(a, b, c) {\n        a.call(this, b, c);\n      }return a.prototype.position = function (a, b, c) {\n        var d = c.find(".dropdown-wrapper");d.append(b), b.addClass("select2-dropdown--below"), c.addClass("select2-container--below");\n      }, a;\n    }), b.define("select2/dropdown/stopPropagation", [], function () {\n      function a() {}return a.prototype.bind = function (a, b, c) {\n        a.call(this, b, c);var d = ["blur", "change", "click", "dblclick", "focus", "focusin", "focusout", "input", "keydown", "keyup", "keypress", "mousedown", "mouseenter", "mouseleave", "mousemove", "mouseover", "mouseup", "search", "touchend", "touchstart"];this.$dropdown.on(d.join(" "), function (a) {\n          a.stopPropagation();\n        });\n      }, a;\n    }), b.define("select2/selection/stopPropagation", [], function () {\n      function a() {}return a.prototype.bind = function (a, b, c) {\n        a.call(this, b, c);var d = ["blur", "change", "click", "dblclick", "focus", "focusin", "focusout", "input", "keydown", "keyup", "keypress", "mousedown", "mouseenter", "mouseleave", "mousemove", "mouseover", "mouseup", "search", "touchend", "touchstart"];this.$selection.on(d.join(" "), function (a) {\n          a.stopPropagation();\n        });\n      }, a;\n    }), b.define("jquery.select2", ["jquery", "require", "./select2/core", "./select2/defaults"], function (a, b, c, d) {\n      if ((b("jquery.mousewheel"), null == a.fn.select2)) {\n        var e = ["open", "close", "destroy"];a.fn.select2 = function (b) {\n          if ((b = b || {}, "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)))) return this.each(function () {\n            var d = a.extend({}, b, !0);new c(a(this), d);\n          }), this;if ("string" == typeof b) {\n            var d;return this.each(function () {\n              var c = a(this).data("select2");null == c && window.console && console.error && console.error("The select2(\'" + b + "\') method was called on an element that is not using Select2.");var e = Array.prototype.slice.call(arguments, 1);d = c[b].apply(c, e);\n            }), a.inArray(b, e) > -1 ? this : d;\n          }throw new Error("Invalid arguments for Select2: " + b);\n        };\n      }return null == a.fn.select2.defaults && (a.fn.select2.defaults = d), c;\n    }), (function (c) {\n      "function" == typeof b.define && b.define.amd ? b.define("jquery.mousewheel", ["jquery"], c) : "object" == ( false ? "undefined" : _typeof(exports)) ? module.exports = c : c(a);\n    })(function (a) {\n      function b(b) {\n        var g = b || window.event,\n            h = i.call(arguments, 1),\n            j = 0,\n            l = 0,\n            m = 0,\n            n = 0,\n            o = 0,\n            p = 0;if ((b = a.event.fix(g), b.type = "mousewheel", "detail" in g && (m = -1 * g.detail), "wheelDelta" in g && (m = g.wheelDelta), "wheelDeltaY" in g && (m = g.wheelDeltaY), "wheelDeltaX" in g && (l = -1 * g.wheelDeltaX), "axis" in g && g.axis === g.HORIZONTAL_AXIS && (l = -1 * m, m = 0), j = 0 === m ? l : m, "deltaY" in g && (m = -1 * g.deltaY, j = m), "deltaX" in g && (l = g.deltaX, 0 === m && (j = -1 * l)), 0 !== m || 0 !== l)) {\n          if (1 === g.deltaMode) {\n            var q = a.data(this, "mousewheel-line-height");j *= q, m *= q, l *= q;\n          } else if (2 === g.deltaMode) {\n            var r = a.data(this, "mousewheel-page-height");j *= r, m *= r, l *= r;\n          }if ((n = Math.max(Math.abs(m), Math.abs(l)), (!f || f > n) && (f = n, d(g, n) && (f /= 40)), d(g, n) && (j /= 40, l /= 40, m /= 40), j = Math[j >= 1 ? "floor" : "ceil"](j / f), l = Math[l >= 1 ? "floor" : "ceil"](l / f), m = Math[m >= 1 ? "floor" : "ceil"](m / f), k.settings.normalizeOffset && this.getBoundingClientRect)) {\n            var s = this.getBoundingClientRect();o = b.clientX - s.left, p = b.clientY - s.top;\n          }return b.deltaX = l, b.deltaY = m, b.deltaFactor = f, b.offsetX = o, b.offsetY = p, b.deltaMode = 0, h.unshift(b, j, l, m), e && clearTimeout(e), e = setTimeout(c, 200), (a.event.dispatch || a.event.handle).apply(this, h);\n        }\n      }function c() {\n        f = null;\n      }function d(a, b) {\n        return k.settings.adjustOldDeltas && "mousewheel" === a.type && b % 120 === 0;\n      }var e,\n          f,\n          g = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],\n          h = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],\n          i = Array.prototype.slice;if (a.event.fixHooks) for (var j = g.length; j;) {\n        a.event.fixHooks[g[--j]] = a.event.mouseHooks;\n      }var k = a.event.special.mousewheel = { version: "3.1.12", setup: function setup() {\n          if (this.addEventListener) for (var c = h.length; c;) {\n            this.addEventListener(h[--c], b, !1);\n          } else this.onmousewheel = b;a.data(this, "mousewheel-line-height", k.getLineHeight(this)), a.data(this, "mousewheel-page-height", k.getPageHeight(this));\n        }, teardown: function teardown() {\n          if (this.removeEventListener) for (var c = h.length; c;) {\n            this.removeEventListener(h[--c], b, !1);\n          } else this.onmousewheel = null;a.removeData(this, "mousewheel-line-height"), a.removeData(this, "mousewheel-page-height");\n        }, getLineHeight: function getLineHeight(b) {\n          var c = a(b),\n              d = c["offsetParent" in a.fn ? "offsetParent" : "parent"]();return d.length || (d = a("body")), parseInt(d.css("fontSize"), 10) || parseInt(c.css("fontSize"), 10) || 16;\n        }, getPageHeight: function getPageHeight(b) {\n          return a(b).height();\n        }, settings: { adjustOldDeltas: !0, normalizeOffset: !0 } };a.fn.extend({ mousewheel: function mousewheel(a) {\n          return a ? this.bind("mousewheel", a) : this.trigger("mousewheel");\n        }, unmousewheel: function unmousewheel(a) {\n          return this.unbind("mousewheel", a);\n        } });\n    }), { define: b.define, require: b.require };\n  })(),\n      c = b.require("jquery.select2");return a.fn.select2.amd = b, c;\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/assets/vendor/select2-4.0.1-rc.1/dist/js/select2.full.min.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/assets/vendor/select2-4.0.1-rc.1/dist/js/select2.full.min.js?');
},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function($) {'use strict'\n\n//layout// sidebar\n// media query event handler\n;\nif (matchMedia) {\n  var mq = window.matchMedia(\"(min-width: 768px)\");\n  mq.addListener(WidthChange);\n  WidthChange(mq);\n}\n\n// media query change\nfunction WidthChange(mq) {\n  console.log('widtch change', mq);\n\n  if (mq.matches) {\n    // window width is at least 500px\n    $('[data-toggle=\"tooltip\"]').tooltip();\n  } else {\n    // window width is less than 500px\n  }\n}\n$('#sidebar').on('hide.bs.collapse', function () {\n  $('body').addClass(\"sidebar-closed\");\n});\n\n$('#sidebar').on('shown.bs.collapse', function () {\n  $('body').removeClass(\"sidebar-closed\");\n});\n$('.user-view').on('hide.bs.collapse', function () {\n  $('body').removeClass(\"sidebar-closed\");\n});\n\n$('.user-view').on('show.bs.collapse', function () {\n  $('body').removeClass(\"sidebar-closed\");\n});\n$('#subnav').on('hide.bs.collapse', function () {\n  $('body').addClass(\"subnav-closed\");\n  console.log('shown.bs.collapse');\n});\n$('#subnav').on('show.bs.collapse', function () {\n  $('body').removeClass(\"subnav-closed\");\n});\n\n$('.select2').select2({\n  placeholder: \"Not chosen\",\n  minimumResultsForSearch: Infinity\n});\n\n$('.selectTree').select2();\n\nvar $ajax = $(\".sample-select-ajax\");\n\nfunction formatRepo(repo) {\n  if (repo.loading) return repo.text;\n\n  var markup = \"<div class='row'>\" + \"<div class='col-sm-6'>\" + \"<span class='metadata s-name'>\" + repo.full_name + \"</span>\" + \"<span class='s-versia'> V. \" + repo.forks_count + \"</span>\" + \"<span class='s-size'>\" + repo.stargazers_count + \" KB</span>\";\n\n  if (repo.description) {\n    markup += \"<span class='metadata s-descr'>\" + repo.description + \"</span>\";\n  }\n\n  markup += \"</div>\" + \"<div class='col-sm-6'>\" + \"<span class='metadata s-familyID'>Family ID: <span>\" + repo.watchers_count + \"</span></span>\" + \"<span class='metadata s-subjectID'>Subject ID: <span>\" + repo.forks_count + \"</span></span>\";\n  if (repo.commits_url) {\n    markup += \"<span class='metadata s-analises'><i class='fa fa-check'></i> Analyzed <span> 24.09.2015 34:45</span>\";\n  }\n  markup += \"</div></div>\";\n\n  return markup;\n}\nfunction formatRepoSelection(repo) {\n  return repo.full_name || repo.text;\n}\n\n$ajax.select2({\n  ajax: {\n    url: \"https://api.github.com/search/repositories\",\n    dataType: 'json',\n    delay: 250,\n    data: function data(params) {\n      return {\n        q: params.term, // search term\n        page: params.page\n      };\n    },\n    processResults: function processResults(data, params) {\n      // parse the results into the format expected by Select2\n      // since we are using custom formatting functions we do not need to\n      // alter the remote JSON data, except to indicate that infinite\n      // scrolling can be used\n      params.page = params.page || 1;\n\n      return {\n        results: data.items,\n        pagination: {\n          more: params.page * 30 < data.total_count\n        }\n      };\n    },\n    cache: true\n  },\n  escapeMarkup: function escapeMarkup(markup) {\n    return markup;\n  },\n  minimumInputLength: 1,\n  templateResult: formatRepo,\n  templateSelection: formatRepoSelection\n});\n\n///\n\n$('#btnOpenid').on('click', function (e) {\n  $('.dropdown-profile').removeClass(\"hidden\");\n  $(this).addClass(\"hidden\");\n});\n\n$('[data-toggle=\"tooltip\"]').tooltip();\n\n$('.dropdown-menu-rows').find('form').click(function (e) {\n  e.stopPropagation();\n});\n\n/*\n$('#btnDel').click(function () {\n  alert(\"jr\");\n   //$(\"#filterSelector\").val([\"eye\"]).trigger(\"change\");\n )};\n*/\n\n$('#builder-basic .selectTree').each(function () {\n  var button = $(this);\n  button.select2().on('change', function (e) {\n\n    $(\"#copyfilterField\").collapse(\"show\");\n    $(\"#newfilterField\").collapse(\"show\");\n  });\n});\n\n$('#builder-basic .selectTree').select2().on(\"change\", function (e) {\n  $(\".copyfilter\").collapse();\n  //$(\"#filterSelector\").val(null).trigger(\"change\");\n});\n\n/*\n$( \"#sample-search\" ).keypress(function() {\n $('.sample-res').removeClass('hidden')\n});\n$( \"#sample-search\" ).focusout(function() {\n $('.sample-res').addClass('hidden')\n});\n*/\n/*\n\n*/\n/*\n$('#fav4').on('click', function () {\n  alert(\"kj\");\n   $('#fav-message').removeClass(\"hidden\");\n});\n*/\n\n/*\n\n\n*/\n\n$('#dropdownSamples').on('show.bs.dropdown', function () {\n  $('.sample-res').addClass('hidden');\n});\n\n$('#comment').on('show.bs.modal', function (event) {\n  var button = $(event.relatedTarget); // Button that triggered the modal\n  var recipient = button.data('whatever'); // Extract info from data-* attributes\n  // If necessary, you could initiate an AJAX request here (and then do the updating in a callback).\n  // Update the modal's content. We'll use jQuery here, but you could use a data binding library or other methods instead.\n  var modal = $(this);\n  modal.find('.modal-body textarea').val(recipient);\n});\n$('#btnLogin').on('click', function (e) {\n  $('.guest').addClass(\"hidden\");\n  $('.user').removeClass(\"hidden\");\n});\n$('#btnLogout').on('click', function (e) {\n  $('user').addClass(\"hidden\");\n  $('#guest').removeClass(\"hidden\");\n});\n\n$('#userEditBtn').on('click', function (e) {\n  $('.user-view').toggleClass('hidden');\n});\n$('.usrViewActBtn').on('click', function (e) {\n  $('.user-view').toggleClass('hidden');\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/Old/old.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/components/Old/old.js?")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function($) {\'use strict\';\n\n__webpack_require__(10);\n\n__webpack_require__(15);\n\n__webpack_require__(11);\n\n__webpack_require__(16);\n\nvar json = __webpack_require__(21);\n\n//datatables.net Samples table \nvar $table = $(\'#table\');\n\nvar dtConfig = {\n  responsive: true,\n  "scrollX": true,\n  "ajax": {\n    "url": json,\n    "dataSrc": ""\n  },\n  "columns": [{ "data": "function" }, { "data": "gene" }, { "data": "chromosome" }, { "data": "endCoordinate" }, { "data": "cytogeneticBand" }, { "data": "startCoordinate" }, { "data": "affectedAminoAcid" }, { "data": "proteinChange" }, { "data": "granthamScore" }, { "data": "functionalConsequence" }, { "data": "transcript" }, { "data": "nucleotideChange" }, { "data": "comment" }]\n};\n\n$(function () {\n  $(\'#table\').DataTable(dtConfig);\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/components/SamplesTable/SamplesTable.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/components/SamplesTable/SamplesTable.js?')},function(module,exports,__webpack_require__){eval("'use strict';\n\nfunction _typeof(obj) {\n  return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\n\n/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\n\n/*!\n * Bootstrap v3.2.0 (http://getbootstrap.com)\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n */\n\nif (typeof jQuery === 'undefined') {\n  throw new Error('Bootstrap\\'s JavaScript requires jQuery');\n}\n\n/* ========================================================================\n * Bootstrap: transition.js v3.2.0\n * http://getbootstrap.com/javascript/#transitions\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n+(function ($) {\n  'use strict'\n\n  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)\n  // ============================================================\n\n  ;\n\n  function transitionEnd() {\n    var el = document.createElement('bootstrap');\n\n    var transEndEventNames = {\n      WebkitTransition: 'webkitTransitionEnd',\n      MozTransition: 'transitionend',\n      OTransition: 'oTransitionEnd otransitionend',\n      transition: 'transitionend'\n    };\n\n    for (var name in transEndEventNames) {\n      if (el.style[name] !== undefined) {\n        return { end: transEndEventNames[name] };\n      }\n    }\n\n    return false; // explicit for ie8 (  ._.)\n  }\n\n  // http://blog.alexmaccaw.com/css-transitions\n  $.fn.emulateTransitionEnd = function (duration) {\n    var called = false;\n    var $el = this;\n    $(this).one('bsTransitionEnd', function () {\n      called = true;\n    });\n    var callback = function callback() {\n      if (!called) $($el).trigger($.support.transition.end);\n    };\n    setTimeout(callback, duration);\n    return this;\n  };\n\n  $(function () {\n    $.support.transition = transitionEnd();\n\n    if (!$.support.transition) return;\n\n    $.event.special.bsTransitionEnd = {\n      bindType: $.support.transition.end,\n      delegateType: $.support.transition.end,\n      handle: function handle(e) {\n        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);\n      }\n    };\n  });\n})(jQuery);\n\n/* ========================================================================\n * Bootstrap: alert.js v3.2.0\n * http://getbootstrap.com/javascript/#alerts\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n+(function ($) {\n  'use strict'\n\n  // ALERT CLASS DEFINITION\n  // ======================\n\n  ;\n\n  var dismiss = '[data-dismiss=\"alert\"]';\n  var Alert = function Alert(el) {\n    $(el).on('click', dismiss, this.close);\n  };\n\n  Alert.VERSION = '3.2.0';\n\n  Alert.prototype.close = function (e) {\n    var $this = $(this);\n    var selector = $this.attr('data-target');\n\n    if (!selector) {\n      selector = $this.attr('href');\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, ''); // strip for ie7\n    }\n\n    var $parent = $(selector);\n\n    if (e) e.preventDefault();\n\n    if (!$parent.length) {\n      $parent = $this.hasClass('alert') ? $this : $this.parent();\n    }\n\n    $parent.trigger(e = $.Event('close.bs.alert'));\n\n    if (e.isDefaultPrevented()) return;\n\n    $parent.removeClass('in');\n\n    function removeElement() {\n      // detach from parent, fire event then clean up data\n      $parent.detach().trigger('closed.bs.alert').remove();\n    }\n\n    $.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(150) : removeElement();\n  };\n\n  // ALERT PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this);\n      var data = $this.data('bs.alert');\n\n      if (!data) $this.data('bs.alert', data = new Alert(this));\n      if (typeof option == 'string') data[option].call($this);\n    });\n  }\n\n  var old = $.fn.alert;\n\n  $.fn.alert = Plugin;\n  $.fn.alert.Constructor = Alert;\n\n  // ALERT NO CONFLICT\n  // =================\n\n  $.fn.alert.noConflict = function () {\n    $.fn.alert = old;\n    return this;\n  };\n\n  // ALERT DATA-API\n  // ==============\n\n  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);\n})(jQuery);\n\n/* ========================================================================\n * Bootstrap: button.js v3.2.0\n * http://getbootstrap.com/javascript/#buttons\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n+(function ($) {\n  'use strict'\n\n  // BUTTON PUBLIC CLASS DEFINITION\n  // ==============================\n\n  ;\n\n  var Button = function Button(element, options) {\n    this.$element = $(element);\n    this.options = $.extend({}, Button.DEFAULTS, options);\n    this.isLoading = false;\n  };\n\n  Button.VERSION = '3.2.0';\n\n  Button.DEFAULTS = {\n    loadingText: 'loading...'\n  };\n\n  Button.prototype.setState = function (state) {\n    var d = 'disabled';\n    var $el = this.$element;\n    var val = $el.is('input') ? 'val' : 'html';\n    var data = $el.data();\n\n    state = state + 'Text';\n\n    if (data.resetText == null) $el.data('resetText', $el[val]());\n\n    $el[val](data[state] == null ? this.options[state] : data[state]);\n\n    // push to event loop to allow forms to submit\n    setTimeout($.proxy(function () {\n      if (state == 'loadingText') {\n        this.isLoading = true;\n        $el.addClass(d).attr(d, d);\n      } else if (this.isLoading) {\n        this.isLoading = false;\n        $el.removeClass(d).removeAttr(d);\n      }\n    }, this), 0);\n  };\n\n  Button.prototype.toggle = function () {\n    var changed = true;\n    var $parent = this.$element.closest('[data-toggle=\"buttons\"]');\n\n    if ($parent.length) {\n      var $input = this.$element.find('input');\n      if ($input.prop('type') == 'radio') {\n        if ($input.prop('checked') && this.$element.hasClass('active')) changed = false;else $parent.find('.active').removeClass('active');\n      }\n      if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change');\n    }\n\n    if (changed) this.$element.toggleClass('active');\n  };\n\n  // BUTTON PLUGIN DEFINITION\n  // ========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this);\n      var data = $this.data('bs.button');\n      var options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option;\n\n      if (!data) $this.data('bs.button', data = new Button(this, options));\n\n      if (option == 'toggle') data.toggle();else if (option) data.setState(option);\n    });\n  }\n\n  var old = $.fn.button;\n\n  $.fn.button = Plugin;\n  $.fn.button.Constructor = Button;\n\n  // BUTTON NO CONFLICT\n  // ==================\n\n  $.fn.button.noConflict = function () {\n    $.fn.button = old;\n    return this;\n  };\n\n  // BUTTON DATA-API\n  // ===============\n\n  $(document).on('click.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\n    var $btn = $(e.target);\n    if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn');\n    Plugin.call($btn, 'toggle');\n    e.preventDefault();\n  });\n})(jQuery);\n\n/* ========================================================================\n * Bootstrap: carousel.js v3.2.0\n * http://getbootstrap.com/javascript/#carousel\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n+(function ($) {\n  'use strict'\n\n  // CAROUSEL CLASS DEFINITION\n  // =========================\n\n  ;\n\n  var Carousel = function Carousel(element, options) {\n    this.$element = $(element).on('keydown.bs.carousel', $.proxy(this.keydown, this));\n    this.$indicators = this.$element.find('.carousel-indicators');\n    this.options = options;\n    this.paused = this.sliding = this.interval = this.$active = this.$items = null;\n\n    this.options.pause == 'hover' && this.$element.on('mouseenter.bs.carousel', $.proxy(this.pause, this)).on('mouseleave.bs.carousel', $.proxy(this.cycle, this));\n  };\n\n  Carousel.VERSION = '3.2.0';\n\n  Carousel.DEFAULTS = {\n    interval: 5000,\n    pause: 'hover',\n    wrap: true\n  };\n\n  Carousel.prototype.keydown = function (e) {\n    switch (e.which) {\n      case 37:\n        this.prev();break;\n      case 39:\n        this.next();break;\n      default:\n        return;\n    }\n\n    e.preventDefault();\n  };\n\n  Carousel.prototype.cycle = function (e) {\n    e || (this.paused = false);\n\n    this.interval && clearInterval(this.interval);\n\n    this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));\n\n    return this;\n  };\n\n  Carousel.prototype.getItemIndex = function (item) {\n    this.$items = item.parent().children('.item');\n    return this.$items.index(item || this.$active);\n  };\n\n  Carousel.prototype.to = function (pos) {\n    var that = this;\n    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'));\n\n    if (pos > this.$items.length - 1 || pos < 0) return;\n\n    if (this.sliding) return this.$element.one('slid.bs.carousel', function () {\n      that.to(pos);\n    }); // yes, \"slid\"\n    if (activeIndex == pos) return this.pause().cycle();\n\n    return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]));\n  };\n\n  Carousel.prototype.pause = function (e) {\n    e || (this.paused = true);\n\n    if (this.$element.find('.next, .prev').length && $.support.transition) {\n      this.$element.trigger($.support.transition.end);\n      this.cycle(true);\n    }\n\n    this.interval = clearInterval(this.interval);\n\n    return this;\n  };\n\n  Carousel.prototype.next = function () {\n    if (this.sliding) return;\n    return this.slide('next');\n  };\n\n  Carousel.prototype.prev = function () {\n    if (this.sliding) return;\n    return this.slide('prev');\n  };\n\n  Carousel.prototype.slide = function (type, next) {\n    var $active = this.$element.find('.item.active');\n    var $next = next || $active[type]();\n    var isCycling = this.interval;\n    var direction = type == 'next' ? 'left' : 'right';\n    var fallback = type == 'next' ? 'first' : 'last';\n    var that = this;\n\n    if (!$next.length) {\n      if (!this.options.wrap) return;\n      $next = this.$element.find('.item')[fallback]();\n    }\n\n    if ($next.hasClass('active')) return this.sliding = false;\n\n    var relatedTarget = $next[0];\n    var slideEvent = $.Event('slide.bs.carousel', {\n      relatedTarget: relatedTarget,\n      direction: direction\n    });\n    this.$element.trigger(slideEvent);\n    if (slideEvent.isDefaultPrevented()) return;\n\n    this.sliding = true;\n\n    isCycling && this.pause();\n\n    if (this.$indicators.length) {\n      this.$indicators.find('.active').removeClass('active');\n      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);\n      $nextIndicator && $nextIndicator.addClass('active');\n    }\n\n    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }); // yes, \"slid\"\n    if ($.support.transition && this.$element.hasClass('slide')) {\n      $next.addClass(type);\n      $next[0].offsetWidth; // force reflow\n      $active.addClass(direction);\n      $next.addClass(direction);\n      $active.one('bsTransitionEnd', function () {\n        $next.removeClass([type, direction].join(' ')).addClass('active');\n        $active.removeClass(['active', direction].join(' '));\n        that.sliding = false;\n        setTimeout(function () {\n          that.$element.trigger(slidEvent);\n        }, 0);\n      }).emulateTransitionEnd($active.css('transition-duration').slice(0, -1) * 1000);\n    } else {\n      $active.removeClass('active');\n      $next.addClass('active');\n      this.sliding = false;\n      this.$element.trigger(slidEvent);\n    }\n\n    isCycling && this.cycle();\n\n    return this;\n  };\n\n  // CAROUSEL PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this);\n      var data = $this.data('bs.carousel');\n      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option);\n      var action = typeof option == 'string' ? option : options.slide;\n\n      if (!data) $this.data('bs.carousel', data = new Carousel(this, options));\n      if (typeof option == 'number') data.to(option);else if (action) data[action]();else if (options.interval) data.pause().cycle();\n    });\n  }\n\n  var old = $.fn.carousel;\n\n  $.fn.carousel = Plugin;\n  $.fn.carousel.Constructor = Carousel;\n\n  // CAROUSEL NO CONFLICT\n  // ====================\n\n  $.fn.carousel.noConflict = function () {\n    $.fn.carousel = old;\n    return this;\n  };\n\n  // CAROUSEL DATA-API\n  // =================\n\n  $(document).on('click.bs.carousel.data-api', '[data-slide], [data-slide-to]', function (e) {\n    var href;\n    var $this = $(this);\n    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '')); // strip for ie7\n    if (!$target.hasClass('carousel')) return;\n    var options = $.extend({}, $target.data(), $this.data());\n    var slideIndex = $this.attr('data-slide-to');\n    if (slideIndex) options.interval = false;\n\n    Plugin.call($target, options);\n\n    if (slideIndex) {\n      $target.data('bs.carousel').to(slideIndex);\n    }\n\n    e.preventDefault();\n  });\n\n  $(window).on('load', function () {\n    $('[data-ride=\"carousel\"]').each(function () {\n      var $carousel = $(this);\n      Plugin.call($carousel, $carousel.data());\n    });\n  });\n})(jQuery);\n\n/* ========================================================================\n * Bootstrap: collapse.js v3.2.0\n * http://getbootstrap.com/javascript/#collapse\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n+(function ($) {\n  'use strict'\n\n  // COLLAPSE PUBLIC CLASS DEFINITION\n  // ================================\n\n  ;\n\n  var Collapse = function Collapse(element, options) {\n    this.$element = $(element);\n    this.options = $.extend({}, Collapse.DEFAULTS, options);\n    this.transitioning = null;\n\n    if (this.options.parent) this.$parent = $(this.options.parent);\n    if (this.options.toggle) this.toggle();\n  };\n\n  Collapse.VERSION = '3.2.0';\n\n  Collapse.DEFAULTS = {\n    toggle: true\n  };\n\n  Collapse.prototype.dimension = function () {\n    var hasWidth = this.$element.hasClass('width');\n    return hasWidth ? 'width' : 'height';\n  };\n\n  Collapse.prototype.show = function () {\n    if (this.transitioning || this.$element.hasClass('in')) return;\n\n    var startEvent = $.Event('show.bs.collapse');\n    this.$element.trigger(startEvent);\n    if (startEvent.isDefaultPrevented()) return;\n\n    var actives = this.$parent && this.$parent.find('> .panel > .in');\n\n    if (actives && actives.length) {\n      var hasData = actives.data('bs.collapse');\n      if (hasData && hasData.transitioning) return;\n      Plugin.call(actives, 'hide');\n      hasData || actives.data('bs.collapse', null);\n    }\n\n    var dimension = this.dimension();\n\n    this.$element.removeClass('collapse').addClass('collapsing')[dimension](0);\n\n    this.transitioning = 1;\n\n    var complete = function complete() {\n      this.$element.removeClass('collapsing').addClass('collapse in')[dimension]('');\n      this.transitioning = 0;\n      this.$element.trigger('shown.bs.collapse');\n    };\n\n    if (!$.support.transition) return complete.call(this);\n\n    var scrollSize = $.camelCase(['scroll', dimension].join('-'));\n\n    this.$element.one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(350)[dimension](this.$element[0][scrollSize]);\n  };\n\n  Collapse.prototype.hide = function () {\n    if (this.transitioning || !this.$element.hasClass('in')) return;\n\n    var startEvent = $.Event('hide.bs.collapse');\n    this.$element.trigger(startEvent);\n    if (startEvent.isDefaultPrevented()) return;\n\n    var dimension = this.dimension();\n\n    this.$element[dimension](this.$element[dimension]())[0].offsetHeight;\n\n    this.$element.addClass('collapsing').removeClass('collapse').removeClass('in');\n\n    this.transitioning = 1;\n\n    var complete = function complete() {\n      this.transitioning = 0;\n      this.$element.trigger('hidden.bs.collapse').removeClass('collapsing').addClass('collapse');\n    };\n\n    if (!$.support.transition) return complete.call(this);\n\n    this.$element[dimension](0).one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(350);\n  };\n\n  Collapse.prototype.toggle = function () {\n    this[this.$element.hasClass('in') ? 'hide' : 'show']();\n  };\n\n  // COLLAPSE PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this);\n      var data = $this.data('bs.collapse');\n      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option);\n\n      if (!data && options.toggle && option == 'show') option = !option;\n      if (!data) $this.data('bs.collapse', data = new Collapse(this, options));\n      if (typeof option == 'string') data[option]();\n    });\n  }\n\n  var old = $.fn.collapse;\n\n  $.fn.collapse = Plugin;\n  $.fn.collapse.Constructor = Collapse;\n\n  // COLLAPSE NO CONFLICT\n  // ====================\n\n  $.fn.collapse.noConflict = function () {\n    $.fn.collapse = old;\n    return this;\n  };\n\n  // COLLAPSE DATA-API\n  // =================\n\n  $(document).on('click.bs.collapse.data-api', '[data-toggle=\"collapse\"]', function (e) {\n    var href;\n    var $this = $(this);\n    var target = $this.attr('data-target') || e.preventDefault() || (href = $this.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, ''); // strip for ie7\n    var $target = $(target);\n    var data = $target.data('bs.collapse');\n    var option = data ? 'toggle' : $this.data();\n    var parent = $this.attr('data-parent');\n    var $parent = parent && $(parent);\n\n    if (!data || !data.transitioning) {\n      if ($parent) $parent.find('[data-toggle=\"collapse\"][data-parent=\"' + parent + '\"]').not($this).addClass('collapsed');\n      $this[$target.hasClass('in') ? 'addClass' : 'removeClass']('collapsed');\n    }\n\n    Plugin.call($target, option);\n  });\n})(jQuery);\n\n/* ========================================================================\n * Bootstrap: dropdown.js v3.2.0\n * http://getbootstrap.com/javascript/#dropdowns\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n+(function ($) {\n  'use strict'\n\n  // DROPDOWN CLASS DEFINITION\n  // =========================\n\n  ;\n\n  var backdrop = '.dropdown-backdrop';\n  var toggle = '[data-toggle=\"dropdown\"]';\n  var Dropdown = function Dropdown(element) {\n    $(element).on('click.bs.dropdown', this.toggle);\n  };\n\n  Dropdown.VERSION = '3.2.0';\n\n  Dropdown.prototype.toggle = function (e) {\n    var $this = $(this);\n\n    if ($this.is('.disabled, :disabled')) return;\n\n    var $parent = getParent($this);\n    var isActive = $parent.hasClass('open');\n\n    clearMenus();\n\n    if (!isActive) {\n      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {\n        // if mobile we use a backdrop because click events don't delegate\n        $('<div class=\"dropdown-backdrop\"/>').insertAfter($(this)).on('click', clearMenus);\n      }\n\n      var relatedTarget = { relatedTarget: this };\n      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget));\n\n      if (e.isDefaultPrevented()) return;\n\n      $this.trigger('focus');\n\n      $parent.toggleClass('open').trigger('shown.bs.dropdown', relatedTarget);\n    }\n\n    return false;\n  };\n\n  Dropdown.prototype.keydown = function (e) {\n    if (!/(38|40|27)/.test(e.keyCode)) return;\n\n    var $this = $(this);\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    if ($this.is('.disabled, :disabled')) return;\n\n    var $parent = getParent($this);\n    var isActive = $parent.hasClass('open');\n\n    if (!isActive || isActive && e.keyCode == 27) {\n      if (e.which == 27) $parent.find(toggle).trigger('focus');\n      return $this.trigger('click');\n    }\n\n    var desc = ' li:not(.divider):visible a';\n    var $items = $parent.find('[role=\"menu\"]' + desc + ', [role=\"listbox\"]' + desc);\n\n    if (!$items.length) return;\n\n    var index = $items.index($items.filter(':focus'));\n\n    if (e.keyCode == 38 && index > 0) index--; // up\n    if (e.keyCode == 40 && index < $items.length - 1) index++; // down\n    if (! ~index) index = 0;\n\n    $items.eq(index).trigger('focus');\n  };\n\n  function clearMenus(e) {\n    if (e && e.which === 3) return;\n    $(backdrop).remove();\n    $(toggle).each(function () {\n      var $parent = getParent($(this));\n      var relatedTarget = { relatedTarget: this };\n      if (!$parent.hasClass('open')) return;\n      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget));\n      if (e.isDefaultPrevented()) return;\n      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget);\n    });\n  }\n\n  function getParent($this) {\n    var selector = $this.attr('data-target');\n\n    if (!selector) {\n      selector = $this.attr('href');\n      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, ''); // strip for ie7\n    }\n\n    var $parent = selector && $(selector);\n\n    return $parent && $parent.length ? $parent : $this.parent();\n  }\n\n  // DROPDOWN PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this);\n      var data = $this.data('bs.dropdown');\n\n      if (!data) $this.data('bs.dropdown', data = new Dropdown(this));\n      if (typeof option == 'string') data[option].call($this);\n    });\n  }\n\n  var old = $.fn.dropdown;\n\n  $.fn.dropdown = Plugin;\n  $.fn.dropdown.Constructor = Dropdown;\n\n  // DROPDOWN NO CONFLICT\n  // ====================\n\n  $.fn.dropdown.noConflict = function () {\n    $.fn.dropdown = old;\n    return this;\n  };\n\n  // APPLY TO STANDARD DROPDOWN ELEMENTS\n  // ===================================\n\n  $(document).on('click.bs.dropdown.data-api', clearMenus).on('click.bs.dropdown.data-api', '.dropdown form', function (e) {\n    e.stopPropagation();\n  }).on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.bs.dropdown.data-api', toggle + ', [role=\"menu\"], [role=\"listbox\"]', Dropdown.prototype.keydown);\n})(jQuery);\n\n/* ========================================================================\n * Bootstrap: modal.js v3.2.0\n * http://getbootstrap.com/javascript/#modals\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n+(function ($) {\n  'use strict'\n\n  // MODAL CLASS DEFINITION\n  // ======================\n\n  ;\n\n  var Modal = function Modal(element, options) {\n    this.options = options;\n    this.$body = $(document.body);\n    this.$element = $(element);\n    this.$backdrop = this.isShown = null;\n    this.scrollbarWidth = 0;\n\n    if (this.options.remote) {\n      this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {\n        this.$element.trigger('loaded.bs.modal');\n      }, this));\n    }\n  };\n\n  Modal.VERSION = '3.2.0';\n\n  Modal.DEFAULTS = {\n    backdrop: true,\n    keyboard: true,\n    show: true\n  };\n\n  Modal.prototype.toggle = function (_relatedTarget) {\n    return this.isShown ? this.hide() : this.show(_relatedTarget);\n  };\n\n  Modal.prototype.show = function (_relatedTarget) {\n    var that = this;\n    var e = $.Event('show.bs.modal', { relatedTarget: _relatedTarget });\n\n    this.$element.trigger(e);\n\n    if (this.isShown || e.isDefaultPrevented()) return;\n\n    this.isShown = true;\n\n    this.checkScrollbar();\n    this.$body.addClass('modal-open');\n\n    this.setScrollbar();\n    this.escape();\n\n    this.$element.on('click.dismiss.bs.modal', '[data-dismiss=\"modal\"]', $.proxy(this.hide, this));\n\n    this.backdrop(function () {\n      var transition = $.support.transition && that.$element.hasClass('fade');\n\n      if (!that.$element.parent().length) {\n        that.$element.appendTo(that.$body); // don't move modals dom position\n      }\n\n      that.$element.show().scrollTop(0);\n\n      if (transition) {\n        that.$element[0].offsetWidth; // force reflow\n      }\n\n      that.$element.addClass('in').attr('aria-hidden', false);\n\n      that.enforceFocus();\n\n      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget });\n\n      transition ? that.$element.find('.modal-dialog') // wait for modal to slide in\n      .one('bsTransitionEnd', function () {\n        that.$element.trigger('focus').trigger(e);\n      }).emulateTransitionEnd(300) : that.$element.trigger('focus').trigger(e);\n    });\n  };\n\n  Modal.prototype.hide = function (e) {\n    if (e) e.preventDefault();\n\n    e = $.Event('hide.bs.modal');\n\n    this.$element.trigger(e);\n\n    if (!this.isShown || e.isDefaultPrevented()) return;\n\n    this.isShown = false;\n\n    this.$body.removeClass('modal-open');\n\n    this.resetScrollbar();\n    this.escape();\n\n    $(document).off('focusin.bs.modal');\n\n    this.$element.removeClass('in').attr('aria-hidden', true).off('click.dismiss.bs.modal');\n\n    $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(300) : this.hideModal();\n  };\n\n  Modal.prototype.enforceFocus = function () {\n    $(document).off('focusin.bs.modal') // guard against infinite focus loop\n    .on('focusin.bs.modal', $.proxy(function (e) {\n      if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {\n        this.$element.trigger('focus');\n      }\n    }, this));\n  };\n\n  Modal.prototype.escape = function () {\n    if (this.isShown && this.options.keyboard) {\n      this.$element.on('keyup.dismiss.bs.modal', $.proxy(function (e) {\n        e.which == 27 && this.hide();\n      }, this));\n    } else if (!this.isShown) {\n      this.$element.off('keyup.dismiss.bs.modal');\n    }\n  };\n\n  Modal.prototype.hideModal = function () {\n    var that = this;\n    this.$element.hide();\n    this.backdrop(function () {\n      that.$element.trigger('hidden.bs.modal');\n    });\n  };\n\n  Modal.prototype.removeBackdrop = function () {\n    this.$backdrop && this.$backdrop.remove();\n    this.$backdrop = null;\n  };\n\n  Modal.prototype.backdrop = function (callback) {\n    var that = this;\n    var animate = this.$element.hasClass('fade') ? 'fade' : '';\n\n    if (this.isShown && this.options.backdrop) {\n      var doAnimate = $.support.transition && animate;\n\n      this.$backdrop = $('<div class=\"modal-backdrop ' + animate + '\" />').appendTo(this.$body);\n\n      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {\n        if (e.target !== e.currentTarget) return;\n        this.options.backdrop == 'static' ? this.$element[0].focus.call(this.$element[0]) : this.hide.call(this);\n      }, this));\n\n      if (doAnimate) this.$backdrop[0].offsetWidth; // force reflow\n\n      this.$backdrop.addClass('in');\n\n      if (!callback) return;\n\n      doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(150) : callback();\n    } else if (!this.isShown && this.$backdrop) {\n      this.$backdrop.removeClass('in');\n\n      var callbackRemove = function callbackRemove() {\n        that.removeBackdrop();\n        callback && callback();\n      };\n      $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(150) : callbackRemove();\n    } else if (callback) {\n      callback();\n    }\n  };\n\n  Modal.prototype.checkScrollbar = function () {\n    if (document.body.clientWidth >= window.innerWidth) return;\n    this.scrollbarWidth = this.scrollbarWidth || this.measureScrollbar();\n  };\n\n  Modal.prototype.setScrollbar = function () {\n    var bodyPad = parseInt(this.$body.css('padding-right') || 0, 10);\n    if (this.scrollbarWidth) this.$body.css('padding-right', bodyPad + this.scrollbarWidth);\n  };\n\n  Modal.prototype.resetScrollbar = function () {\n    this.$body.css('padding-right', '');\n  };\n\n  Modal.prototype.measureScrollbar = function () {\n    // thx walsh\n    var scrollDiv = document.createElement('div');\n    scrollDiv.className = 'modal-scrollbar-measure';\n    this.$body.append(scrollDiv);\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    this.$body[0].removeChild(scrollDiv);\n    return scrollbarWidth;\n  };\n\n  // MODAL PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option, _relatedTarget) {\n    return this.each(function () {\n      var $this = $(this);\n      var data = $this.data('bs.modal');\n      var options = $.extend({}, Modal.DEFAULTS, $this.data(), (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option);\n\n      if (!data) $this.data('bs.modal', data = new Modal(this, options));\n      if (typeof option == 'string') data[option](_relatedTarget);else if (options.show) data.show(_relatedTarget);\n    });\n  }\n\n  var old = $.fn.modal;\n\n  $.fn.modal = Plugin;\n  $.fn.modal.Constructor = Modal;\n\n  // MODAL NO CONFLICT\n  // =================\n\n  $.fn.modal.noConflict = function () {\n    $.fn.modal = old;\n    return this;\n  };\n\n  // MODAL DATA-API\n  // ==============\n\n  $(document).on('click.bs.modal.data-api', '[data-toggle=\"modal\"]', function (e) {\n    var $this = $(this);\n    var href = $this.attr('href');\n    var $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\\s]+$)/, '')); // strip for ie7\n    var option = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());\n\n    if ($this.is('a')) e.preventDefault();\n\n    $target.one('show.bs.modal', function (showEvent) {\n      if (showEvent.isDefaultPrevented()) return; // only register focus restorer if modal will actually get shown\n      $target.one('hidden.bs.modal', function () {\n        $this.is(':visible') && $this.trigger('focus');\n      });\n    });\n    Plugin.call($target, option, this);\n  });\n})(jQuery);\n\n/* ========================================================================\n * Bootstrap: tooltip.js v3.2.0\n * http://getbootstrap.com/javascript/#tooltip\n * Inspired by the original jQuery.tipsy by Jason Frame\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n+(function ($) {\n  'use strict'\n\n  // TOOLTIP PUBLIC CLASS DEFINITION\n  // ===============================\n\n  ;\n\n  var Tooltip = function Tooltip(element, options) {\n    this.type = this.options = this.enabled = this.timeout = this.hoverState = this.$element = null;\n\n    this.init('tooltip', element, options);\n  };\n\n  Tooltip.VERSION = '3.2.0';\n\n  Tooltip.DEFAULTS = {\n    animation: true,\n    placement: 'top',\n    selector: false,\n    template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    container: false,\n    viewport: {\n      selector: 'body',\n      padding: 0\n    }\n  };\n\n  Tooltip.prototype.init = function (type, element, options) {\n    this.enabled = true;\n    this.type = type;\n    this.$element = $(element);\n    this.options = this.getOptions(options);\n    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport);\n\n    var triggers = this.options.trigger.split(' ');\n\n    for (var i = triggers.length; i--;) {\n      var trigger = triggers[i];\n\n      if (trigger == 'click') {\n        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));\n      } else if (trigger != 'manual') {\n        var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';\n        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';\n\n        this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));\n        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));\n      }\n    }\n\n    this.options.selector ? this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' }) : this.fixTitle();\n  };\n\n  Tooltip.prototype.getDefaults = function () {\n    return Tooltip.DEFAULTS;\n  };\n\n  Tooltip.prototype.getOptions = function (options) {\n    options = $.extend({}, this.getDefaults(), this.$element.data(), options);\n\n    if (options.delay && typeof options.delay == 'number') {\n      options.delay = {\n        show: options.delay,\n        hide: options.delay\n      };\n    }\n\n    return options;\n  };\n\n  Tooltip.prototype.getDelegateOptions = function () {\n    var options = {};\n    var defaults = this.getDefaults();\n\n    this._options && $.each(this._options, function (key, value) {\n      if (defaults[key] != value) options[key] = value;\n    });\n\n    return options;\n  };\n\n  Tooltip.prototype.enter = function (obj) {\n    var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions());\n      $(obj.currentTarget).data('bs.' + this.type, self);\n    }\n\n    clearTimeout(self.timeout);\n\n    self.hoverState = 'in';\n\n    if (!self.options.delay || !self.options.delay.show) return self.show();\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == 'in') self.show();\n    }, self.options.delay.show);\n  };\n\n  Tooltip.prototype.leave = function (obj) {\n    var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions());\n      $(obj.currentTarget).data('bs.' + this.type, self);\n    }\n\n    clearTimeout(self.timeout);\n\n    self.hoverState = 'out';\n\n    if (!self.options.delay || !self.options.delay.hide) return self.hide();\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == 'out') self.hide();\n    }, self.options.delay.hide);\n  };\n\n  Tooltip.prototype.show = function () {\n    var e = $.Event('show.bs.' + this.type);\n\n    if (this.hasContent() && this.enabled) {\n      this.$element.trigger(e);\n\n      var inDom = $.contains(document.documentElement, this.$element[0]);\n      if (e.isDefaultPrevented() || !inDom) return;\n      var that = this;\n\n      var $tip = this.tip();\n\n      var tipId = this.getUID(this.type);\n\n      this.setContent();\n      $tip.attr('id', tipId);\n      this.$element.attr('aria-describedby', tipId);\n\n      if (this.options.animation) $tip.addClass('fade');\n\n      var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;\n\n      var autoToken = /\\s?auto?\\s?/i;\n      var autoPlace = autoToken.test(placement);\n      if (autoPlace) placement = placement.replace(autoToken, '') || 'top';\n\n      $tip.detach().css({ top: 0, left: 0, display: 'block' }).addClass(placement).data('bs.' + this.type, this);\n\n      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);\n\n      var pos = this.getPosition();\n      var actualWidth = $tip[0].offsetWidth;\n      var actualHeight = $tip[0].offsetHeight;\n\n      if (autoPlace) {\n        var orgPlacement = placement;\n        var $parent = this.$element.parent();\n        var parentDim = this.getPosition($parent);\n\n        placement = placement == 'bottom' && pos.top + pos.height + actualHeight - parentDim.scroll > parentDim.height ? 'top' : placement == 'top' && pos.top - parentDim.scroll - actualHeight < 0 ? 'bottom' : placement == 'right' && pos.right + actualWidth > parentDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < parentDim.left ? 'right' : placement;\n\n        $tip.removeClass(orgPlacement).addClass(placement);\n      }\n\n      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);\n\n      this.applyPlacement(calculatedOffset, placement);\n\n      var complete = function complete() {\n        that.$element.trigger('shown.bs.' + that.type);\n        that.hoverState = null;\n      };\n\n      $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(150) : complete();\n    }\n  };\n\n  Tooltip.prototype.applyPlacement = function (offset, placement) {\n    var $tip = this.tip();\n    var width = $tip[0].offsetWidth;\n    var height = $tip[0].offsetHeight;\n\n    // manually read margins because getBoundingClientRect includes difference\n    var marginTop = parseInt($tip.css('margin-top'), 10);\n    var marginLeft = parseInt($tip.css('margin-left'), 10);\n\n    // we must check for NaN for ie 8/9\n    if (isNaN(marginTop)) marginTop = 0;\n    if (isNaN(marginLeft)) marginLeft = 0;\n\n    offset.top = offset.top + marginTop;\n    offset.left = offset.left + marginLeft;\n\n    // $.fn.offset doesn't round pixel values\n    // so we use setOffset directly with our own function B-0\n    $.offset.setOffset($tip[0], $.extend({\n      using: function using(props) {\n        $tip.css({\n          top: Math.round(props.top),\n          left: Math.round(props.left)\n        });\n      }\n    }, offset), 0);\n\n    $tip.addClass('in');\n\n    // check to see if placing tip in new offset caused the tip to resize itself\n    var actualWidth = $tip[0].offsetWidth;\n    var actualHeight = $tip[0].offsetHeight;\n\n    if (placement == 'top' && actualHeight != height) {\n      offset.top = offset.top + height - actualHeight;\n    }\n\n    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n    if (delta.left) offset.left += delta.left;else offset.top += delta.top;\n\n    var arrowDelta = delta.left ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n    var arrowPosition = delta.left ? 'left' : 'top';\n    var arrowOffsetPosition = delta.left ? 'offsetWidth' : 'offsetHeight';\n\n    $tip.offset(offset);\n    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], arrowPosition);\n  };\n\n  Tooltip.prototype.replaceArrow = function (delta, dimension, position) {\n    this.arrow().css(position, delta ? 50 * (1 - delta / dimension) + '%' : '');\n  };\n\n  Tooltip.prototype.setContent = function () {\n    var $tip = this.tip();\n    var title = this.getTitle();\n\n    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);\n    $tip.removeClass('fade in top bottom left right');\n  };\n\n  Tooltip.prototype.hide = function () {\n    var that = this;\n    var $tip = this.tip();\n    var e = $.Event('hide.bs.' + this.type);\n\n    this.$element.removeAttr('aria-describedby');\n\n    function complete() {\n      if (that.hoverState != 'in') $tip.detach();\n      that.$element.trigger('hidden.bs.' + that.type);\n    }\n\n    this.$element.trigger(e);\n\n    if (e.isDefaultPrevented()) return;\n\n    $tip.removeClass('in');\n\n    $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(150) : complete();\n\n    this.hoverState = null;\n\n    return this;\n  };\n\n  Tooltip.prototype.fixTitle = function () {\n    var $e = this.$element;\n    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {\n      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');\n    }\n  };\n\n  Tooltip.prototype.hasContent = function () {\n    return this.getTitle();\n  };\n\n  Tooltip.prototype.getPosition = function ($element) {\n    $element = $element || this.$element;\n    var el = $element[0];\n    var isBody = el.tagName == 'BODY';\n    return $.extend({}, typeof el.getBoundingClientRect == 'function' ? el.getBoundingClientRect() : null, {\n      scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop(),\n      width: isBody ? $(window).width() : $element.outerWidth(),\n      height: isBody ? $(window).height() : $element.outerHeight()\n    }, isBody ? { top: 0, left: 0 } : $element.offset());\n  };\n\n  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {\n    return placement == 'bottom' ? { top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2 } : placement == 'top' ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } : placement == 'left' ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :\n    /* placement == 'right' */{ top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width };\n  };\n\n  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {\n    var delta = { top: 0, left: 0 };\n    if (!this.$viewport) return delta;\n\n    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;\n    var viewportDimensions = this.getPosition(this.$viewport);\n\n    if (/right|left/.test(placement)) {\n      var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;\n      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n      if (topEdgeOffset < viewportDimensions.top) {\n        // top overflow\n        delta.top = viewportDimensions.top - topEdgeOffset;\n      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {\n        // bottom overflow\n        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n      }\n    } else {\n      var leftEdgeOffset = pos.left - viewportPadding;\n      var rightEdgeOffset = pos.left + viewportPadding + actualWidth;\n      if (leftEdgeOffset < viewportDimensions.left) {\n        // left overflow\n        delta.left = viewportDimensions.left - leftEdgeOffset;\n      } else if (rightEdgeOffset > viewportDimensions.width) {\n        // right overflow\n        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n      }\n    }\n\n    return delta;\n  };\n\n  Tooltip.prototype.getTitle = function () {\n    var title;\n    var $e = this.$element;\n    var o = this.options;\n\n    title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);\n\n    return title;\n  };\n\n  Tooltip.prototype.getUID = function (prefix) {\n    do {\n      prefix += ~ ~(Math.random() * 1000000);\n    } while (document.getElementById(prefix));\n    return prefix;\n  };\n\n  Tooltip.prototype.tip = function () {\n    return this.$tip = this.$tip || $(this.options.template);\n  };\n\n  Tooltip.prototype.arrow = function () {\n    return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow');\n  };\n\n  Tooltip.prototype.validate = function () {\n    if (!this.$element[0].parentNode) {\n      this.hide();\n      this.$element = null;\n      this.options = null;\n    }\n  };\n\n  Tooltip.prototype.enable = function () {\n    this.enabled = true;\n  };\n\n  Tooltip.prototype.disable = function () {\n    this.enabled = false;\n  };\n\n  Tooltip.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled;\n  };\n\n  Tooltip.prototype.toggle = function (e) {\n    var self = this;\n    if (e) {\n      self = $(e.currentTarget).data('bs.' + this.type);\n      if (!self) {\n        self = new this.constructor(e.currentTarget, this.getDelegateOptions());\n        $(e.currentTarget).data('bs.' + this.type, self);\n      }\n    }\n\n    self.tip().hasClass('in') ? self.leave(self) : self.enter(self);\n  };\n\n  Tooltip.prototype.destroy = function () {\n    clearTimeout(this.timeout);\n    this.hide().$element.off('.' + this.type).removeData('bs.' + this.type);\n  };\n\n  // TOOLTIP PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this);\n      var data = $this.data('bs.tooltip');\n      var options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option;\n\n      if (!data && option == 'destroy') return;\n      if (!data) $this.data('bs.tooltip', data = new Tooltip(this, options));\n      if (typeof option == 'string') data[option]();\n    });\n  }\n\n  var old = $.fn.tooltip;\n\n  $.fn.tooltip = Plugin;\n  $.fn.tooltip.Constructor = Tooltip;\n\n  // TOOLTIP NO CONFLICT\n  // ===================\n\n  $.fn.tooltip.noConflict = function () {\n    $.fn.tooltip = old;\n    return this;\n  };\n})(jQuery);\n\n/* ========================================================================\n * Bootstrap: popover.js v3.2.0\n * http://getbootstrap.com/javascript/#popovers\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n+(function ($) {\n  'use strict'\n\n  // POPOVER PUBLIC CLASS DEFINITION\n  // ===============================\n\n  ;\n\n  var Popover = function Popover(element, options) {\n    this.init('popover', element, options);\n  };\n\n  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js');\n\n  Popover.VERSION = '3.2.0';\n\n  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {\n    placement: 'right',\n    trigger: 'click',\n    content: '',\n    template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\"></div></div>'\n  });\n\n  // NOTE: POPOVER EXTENDS tooltip.js\n  // ================================\n\n  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);\n\n  Popover.prototype.constructor = Popover;\n\n  Popover.prototype.getDefaults = function () {\n    return Popover.DEFAULTS;\n  };\n\n  Popover.prototype.setContent = function () {\n    var $tip = this.tip();\n    var title = this.getTitle();\n    var content = this.getContent();\n\n    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);\n    $tip.find('.popover-content').empty()[// we use append for html objects to maintain js events\n    this.options.html ? typeof content == 'string' ? 'html' : 'append' : 'text'](content);\n\n    $tip.removeClass('fade top bottom left right in');\n\n    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do\n    // this manually by checking the contents.\n    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide();\n  };\n\n  Popover.prototype.hasContent = function () {\n    return this.getTitle() || this.getContent();\n  };\n\n  Popover.prototype.getContent = function () {\n    var $e = this.$element;\n    var o = this.options;\n\n    return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);\n  };\n\n  Popover.prototype.arrow = function () {\n    return this.$arrow = this.$arrow || this.tip().find('.arrow');\n  };\n\n  Popover.prototype.tip = function () {\n    if (!this.$tip) this.$tip = $(this.options.template);\n    return this.$tip;\n  };\n\n  // POPOVER PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this);\n      var data = $this.data('bs.popover');\n      var options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option;\n\n      if (!data && option == 'destroy') return;\n      if (!data) $this.data('bs.popover', data = new Popover(this, options));\n      if (typeof option == 'string') data[option]();\n    });\n  }\n\n  var old = $.fn.popover;\n\n  $.fn.popover = Plugin;\n  $.fn.popover.Constructor = Popover;\n\n  // POPOVER NO CONFLICT\n  // ===================\n\n  $.fn.popover.noConflict = function () {\n    $.fn.popover = old;\n    return this;\n  };\n})(jQuery);\n\n/* ========================================================================\n * Bootstrap: scrollspy.js v3.2.0\n * http://getbootstrap.com/javascript/#scrollspy\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n+(function ($) {\n  'use strict'\n\n  // SCROLLSPY CLASS DEFINITION\n  // ==========================\n\n  ;\n\n  function ScrollSpy(element, options) {\n    var process = $.proxy(this.process, this);\n\n    this.$body = $('body');\n    this.$scrollElement = $(element).is('body') ? $(window) : $(element);\n    this.options = $.extend({}, ScrollSpy.DEFAULTS, options);\n    this.selector = (this.options.target || '') + ' .nav li > a';\n    this.offsets = [];\n    this.targets = [];\n    this.activeTarget = null;\n    this.scrollHeight = 0;\n\n    this.$scrollElement.on('scroll.bs.scrollspy', process);\n    this.refresh();\n    this.process();\n  }\n\n  ScrollSpy.VERSION = '3.2.0';\n\n  ScrollSpy.DEFAULTS = {\n    offset: 10\n  };\n\n  ScrollSpy.prototype.getScrollHeight = function () {\n    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);\n  };\n\n  ScrollSpy.prototype.refresh = function () {\n    var offsetMethod = 'offset';\n    var offsetBase = 0;\n\n    if (!$.isWindow(this.$scrollElement[0])) {\n      offsetMethod = 'position';\n      offsetBase = this.$scrollElement.scrollTop();\n    }\n\n    this.offsets = [];\n    this.targets = [];\n    this.scrollHeight = this.getScrollHeight();\n\n    var self = this;\n\n    this.$body.find(this.selector).map(function () {\n      var $el = $(this);\n      var href = $el.data('target') || $el.attr('href');\n      var $href = /^#./.test(href) && $(href);\n\n      return $href && $href.length && $href.is(':visible') && [[$href[offsetMethod]().top + offsetBase, href]] || null;\n    }).sort(function (a, b) {\n      return a[0] - b[0];\n    }).each(function () {\n      self.offsets.push(this[0]);\n      self.targets.push(this[1]);\n    });\n  };\n\n  ScrollSpy.prototype.process = function () {\n    var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;\n    var scrollHeight = this.getScrollHeight();\n    var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();\n    var offsets = this.offsets;\n    var targets = this.targets;\n    var activeTarget = this.activeTarget;\n    var i;\n\n    if (this.scrollHeight != scrollHeight) {\n      this.refresh();\n    }\n\n    if (scrollTop >= maxScroll) {\n      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);\n    }\n\n    if (activeTarget && scrollTop <= offsets[0]) {\n      return activeTarget != (i = targets[0]) && this.activate(i);\n    }\n\n    for (i = offsets.length; i--;) {\n      activeTarget != targets[i] && scrollTop >= offsets[i] && (!offsets[i + 1] || scrollTop <= offsets[i + 1]) && this.activate(targets[i]);\n    }\n  };\n\n  ScrollSpy.prototype.activate = function (target) {\n    this.activeTarget = target;\n\n    $(this.selector).parentsUntil(this.options.target, '.active').removeClass('active');\n\n    var selector = this.selector + '[data-target=\"' + target + '\"],' + this.selector + '[href=\"' + target + '\"]';\n\n    var active = $(selector).parents('li').addClass('active');\n\n    if (active.parent('.dropdown-menu').length) {\n      active = active.closest('li.dropdown').addClass('active');\n    }\n\n    active.trigger('activate.bs.scrollspy');\n  };\n\n  // SCROLLSPY PLUGIN DEFINITION\n  // ===========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this);\n      var data = $this.data('bs.scrollspy');\n      var options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option;\n\n      if (!data) $this.data('bs.scrollspy', data = new ScrollSpy(this, options));\n      if (typeof option == 'string') data[option]();\n    });\n  }\n\n  var old = $.fn.scrollspy;\n\n  $.fn.scrollspy = Plugin;\n  $.fn.scrollspy.Constructor = ScrollSpy;\n\n  // SCROLLSPY NO CONFLICT\n  // =====================\n\n  $.fn.scrollspy.noConflict = function () {\n    $.fn.scrollspy = old;\n    return this;\n  };\n\n  // SCROLLSPY DATA-API\n  // ==================\n\n  $(window).on('load.bs.scrollspy.data-api', function () {\n    $('[data-spy=\"scroll\"]').each(function () {\n      var $spy = $(this);\n      Plugin.call($spy, $spy.data());\n    });\n  });\n})(jQuery);\n\n/* ========================================================================\n * Bootstrap: tab.js v3.2.0\n * http://getbootstrap.com/javascript/#tabs\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n+(function ($) {\n  'use strict'\n\n  // TAB CLASS DEFINITION\n  // ====================\n\n  ;\n\n  var Tab = function Tab(element) {\n    this.element = $(element);\n  };\n\n  Tab.VERSION = '3.2.0';\n\n  Tab.prototype.show = function () {\n    var $this = this.element;\n    var $ul = $this.closest('ul:not(.dropdown-menu)');\n    var selector = $this.data('target');\n\n    if (!selector) {\n      selector = $this.attr('href');\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, ''); // strip for ie7\n    }\n\n    if ($this.parent('li').hasClass('active')) return;\n\n    var previous = $ul.find('.active:last a')[0];\n    var e = $.Event('show.bs.tab', {\n      relatedTarget: previous\n    });\n\n    $this.trigger(e);\n\n    if (e.isDefaultPrevented()) return;\n\n    var $target = $(selector);\n\n    this.activate($this.closest('li'), $ul);\n    this.activate($target, $target.parent(), function () {\n      $this.trigger({\n        type: 'shown.bs.tab',\n        relatedTarget: previous\n      });\n    });\n  };\n\n  Tab.prototype.activate = function (element, container, callback) {\n    var $active = container.find('> .active');\n    var transition = callback && $.support.transition && $active.hasClass('fade');\n\n    function next() {\n      $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active');\n\n      element.addClass('active');\n\n      if (transition) {\n        element[0].offsetWidth; // reflow for transition\n        element.addClass('in');\n      } else {\n        element.removeClass('fade');\n      }\n\n      if (element.parent('.dropdown-menu')) {\n        element.closest('li.dropdown').addClass('active');\n      }\n\n      callback && callback();\n    }\n\n    transition ? $active.one('bsTransitionEnd', next).emulateTransitionEnd(150) : next();\n\n    $active.removeClass('in');\n  };\n\n  // TAB PLUGIN DEFINITION\n  // =====================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this);\n      var data = $this.data('bs.tab');\n\n      if (!data) $this.data('bs.tab', data = new Tab(this));\n      if (typeof option == 'string') data[option]();\n    });\n  }\n\n  var old = $.fn.tab;\n\n  $.fn.tab = Plugin;\n  $.fn.tab.Constructor = Tab;\n\n  // TAB NO CONFLICT\n  // ===============\n\n  $.fn.tab.noConflict = function () {\n    $.fn.tab = old;\n    return this;\n  };\n\n  // TAB DATA-API\n  // ============\n\n  $(document).on('click.bs.tab.data-api', '[data-toggle=\"tab\"], [data-toggle=\"pill\"]', function (e) {\n    e.preventDefault();\n    Plugin.call($(this), 'show');\n  });\n})(jQuery);\n\n/* ========================================================================\n * Bootstrap: affix.js v3.2.0\n * http://getbootstrap.com/javascript/#affix\n * ========================================================================\n * Copyright 2011-2014 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n+(function ($) {\n  'use strict'\n\n  // AFFIX CLASS DEFINITION\n  // ======================\n\n  ;\n\n  var Affix = function Affix(element, options) {\n    this.options = $.extend({}, Affix.DEFAULTS, options);\n\n    this.$target = $(this.options.target).on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this));\n\n    this.$element = $(element);\n    this.affixed = this.unpin = this.pinnedOffset = null;\n\n    this.checkPosition();\n  };\n\n  Affix.VERSION = '3.2.0';\n\n  Affix.RESET = 'affix affix-top affix-bottom';\n\n  Affix.DEFAULTS = {\n    offset: 0,\n    target: window\n  };\n\n  Affix.prototype.getPinnedOffset = function () {\n    if (this.pinnedOffset) return this.pinnedOffset;\n    this.$element.removeClass(Affix.RESET).addClass('affix');\n    var scrollTop = this.$target.scrollTop();\n    var position = this.$element.offset();\n    return this.pinnedOffset = position.top - scrollTop;\n  };\n\n  Affix.prototype.checkPositionWithEventLoop = function () {\n    setTimeout($.proxy(this.checkPosition, this), 1);\n  };\n\n  Affix.prototype.checkPosition = function () {\n    if (!this.$element.is(':visible')) return;\n\n    var scrollHeight = $(document).height();\n    var scrollTop = this.$target.scrollTop();\n    var position = this.$element.offset();\n    var offset = this.options.offset;\n    var offsetTop = offset.top;\n    var offsetBottom = offset.bottom;\n\n    if ((typeof offset === 'undefined' ? 'undefined' : _typeof(offset)) != 'object') offsetBottom = offsetTop = offset;\n    if (typeof offsetTop == 'function') offsetTop = offset.top(this.$element);\n    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element);\n\n    var affix = this.unpin != null && scrollTop + this.unpin <= position.top ? false : offsetBottom != null && position.top + this.$element.height() >= scrollHeight - offsetBottom ? 'bottom' : offsetTop != null && scrollTop <= offsetTop ? 'top' : false;\n\n    if (this.affixed === affix) return;\n    if (this.unpin != null) this.$element.css('top', '');\n\n    var affixType = 'affix' + (affix ? '-' + affix : '');\n    var e = $.Event(affixType + '.bs.affix');\n\n    this.$element.trigger(e);\n\n    if (e.isDefaultPrevented()) return;\n\n    this.affixed = affix;\n    this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null;\n\n    this.$element.removeClass(Affix.RESET).addClass(affixType).trigger($.Event(affixType.replace('affix', 'affixed')));\n\n    if (affix == 'bottom') {\n      this.$element.offset({\n        top: scrollHeight - this.$element.height() - offsetBottom\n      });\n    }\n  };\n\n  // AFFIX PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this);\n      var data = $this.data('bs.affix');\n      var options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option;\n\n      if (!data) $this.data('bs.affix', data = new Affix(this, options));\n      if (typeof option == 'string') data[option]();\n    });\n  }\n\n  var old = $.fn.affix;\n\n  $.fn.affix = Plugin;\n  $.fn.affix.Constructor = Affix;\n\n  // AFFIX NO CONFLICT\n  // =================\n\n  $.fn.affix.noConflict = function () {\n    $.fn.affix = old;\n    return this;\n  };\n\n  // AFFIX DATA-API\n  // ==============\n\n  $(window).on('load', function () {\n    $('[data-spy=\"affix\"]').each(function () {\n      var $spy = $(this);\n      var data = $spy.data();\n\n      data.offset = data.offset || {};\n\n      if (data.offsetBottom) data.offset.bottom = data.offsetBottom;\n      if (data.offsetTop) data.offset.top = data.offsetTop;\n\n      Plugin.call($spy, data);\n    });\n  });\n})(jQuery);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/assets/css/bootstrap/js/bootstrap.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/assets/css/bootstrap/js/bootstrap.js?");
},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables Bootstrap 3 integration\n * ©2011-2015 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * DataTables integration for Bootstrap 3. This requires Bootstrap 3 and\n * DataTables 1.10 or newer.\n *\n * This file sets the defaults and adds options to DataTables to style its\n * controls using Bootstrap. See http://datatables.net/manual/styling/bootstrap\n * for further information.\n */\n(function( factory ){\n	if ( true ) {\n		// AMD\n		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function ( $ ) {\n			return factory( $, window, document );\n		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n	}\n	else if ( typeof exports === 'object' ) {\n		// CommonJS\n		module.exports = function (root, $) {\n			if ( ! root ) {\n				root = window;\n			}\n\n			if ( ! $ || ! $.fn.dataTable ) {\n				// Require DataTables, which attaches to jQuery, including\n				// jQuery if needed and have a $ property so we can access the\n				// jQuery object that is used\n				$ = require('datatables.net')(root, $).$;\n			}\n\n			return factory( $, root, root.document );\n		};\n	}\n	else {\n		// Browser\n		factory( jQuery, window, document );\n	}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n/* Set the defaults for DataTables initialisation */\n$.extend( true, DataTable.defaults, {\n	dom:\n		\"<'row'<'col-sm-6'l><'col-sm-6'f>>\" +\n		\"<'row'<'col-sm-12'tr>>\" +\n		\"<'row'<'col-sm-5'i><'col-sm-7'p>>\",\n	renderer: 'bootstrap'\n} );\n\n\n/* Default class modification */\n$.extend( DataTable.ext.classes, {\n	sWrapper:      \"dataTables_wrapper form-inline dt-bootstrap\",\n	sFilterInput:  \"form-control input-sm\",\n	sLengthSelect: \"form-control input-sm\",\n	sProcessing:   \"dataTables_processing panel panel-default\"\n} );\n\n\n/* Bootstrap paging button renderer */\nDataTable.ext.renderer.pageButton.bootstrap = function ( settings, host, idx, buttons, page, pages ) {\n	var api     = new DataTable.Api( settings );\n	var classes = settings.oClasses;\n	var lang    = settings.oLanguage.oPaginate;\n	var aria = settings.oLanguage.oAria.paginate || {};\n	var btnDisplay, btnClass, counter=0;\n\n	var attach = function( container, buttons ) {\n		var i, ien, node, button;\n		var clickHandler = function ( e ) {\n			e.preventDefault();\n			if ( !$(e.currentTarget).hasClass('disabled') && api.page() != e.data.action ) {\n				api.page( e.data.action ).draw( 'page' );\n			}\n		};\n\n		for ( i=0, ien=buttons.length ; i<ien ; i++ ) {\n			button = buttons[i];\n\n			if ( $.isArray( button ) ) {\n				attach( container, button );\n			}\n			else {\n				btnDisplay = '';\n				btnClass = '';\n\n				switch ( button ) {\n					case 'ellipsis':\n						btnDisplay = '&#x2026;';\n						btnClass = 'disabled';\n						break;\n\n					case 'first':\n						btnDisplay = lang.sFirst;\n						btnClass = button + (page > 0 ?\n							'' : ' disabled');\n						break;\n\n					case 'previous':\n						btnDisplay = lang.sPrevious;\n						btnClass = button + (page > 0 ?\n							'' : ' disabled');\n						break;\n\n					case 'next':\n						btnDisplay = lang.sNext;\n						btnClass = button + (page < pages-1 ?\n							'' : ' disabled');\n						break;\n\n					case 'last':\n						btnDisplay = lang.sLast;\n						btnClass = button + (page < pages-1 ?\n							'' : ' disabled');\n						break;\n\n					default:\n						btnDisplay = button + 1;\n						btnClass = page === button ?\n							'active' : '';\n						break;\n				}\n\n				if ( btnDisplay ) {\n					node = $('<li>', {\n							'class': classes.sPageButton+' '+btnClass,\n							'id': idx === 0 && typeof button === 'string' ?\n								settings.sTableId +'_'+ button :\n								null\n						} )\n						.append( $('<a>', {\n								'href': '#',\n								'aria-controls': settings.sTableId,\n								'aria-label': aria[ button ],\n								'data-dt-idx': counter,\n								'tabindex': settings.iTabIndex\n							} )\n							.html( btnDisplay )\n						)\n						.appendTo( container );\n\n					settings.oApi._fnBindAction(\n						node, {action: button}, clickHandler\n					);\n\n					counter++;\n				}\n			}\n		}\n	};\n\n	// IE9 throws an 'unknown error' if document.activeElement is used\n	// inside an iframe or frame. \n	var activeEl;\n\n	try {\n		// Because this approach is destroying and recreating the paging\n		// elements, focus is lost on the select button which is bad for\n		// accessibility. So we want to restore focus once the draw has\n		// completed\n		activeEl = $(host).find(document.activeElement).data('dt-idx');\n	}\n	catch (e) {}\n\n	attach(\n		$(host).empty().html('<ul class=\"pagination\"/>').children('ul'),\n		buttons\n	);\n\n	if ( activeEl ) {\n		$(host).find( '[data-dt-idx='+activeEl+']' ).focus();\n	}\n};\n\n\n/*\n * TableTools Bootstrap compatibility\n * Required TableTools 2.1+\n */\nif ( DataTable.TableTools ) {\n	// Set the classes that TableTools uses to something suitable for Bootstrap\n	$.extend( true, DataTable.TableTools.classes, {\n		\"container\": \"DTTT btn-group\",\n		\"buttons\": {\n			\"normal\": \"btn btn-default\",\n			\"disabled\": \"disabled\"\n		},\n		\"collection\": {\n			\"container\": \"DTTT_dropdown dropdown-menu\",\n			\"buttons\": {\n				\"normal\": \"\",\n				\"disabled\": \"disabled\"\n			}\n		},\n		\"print\": {\n			\"info\": \"DTTT_print_info\"\n		},\n		\"select\": {\n			\"row\": \"active\"\n		}\n	} );\n\n	// Have the collection use a bootstrap compatible drop down\n	$.extend( true, DataTable.TableTools.DEFAULTS.oTags, {\n		\"collection\": {\n			\"container\": \"ul\",\n			\"button\": \"li\",\n			\"liner\": \"a\"\n		}\n	} );\n}\n\n\nreturn DataTable;\n}));\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datatables.net-bs/js/dataTables.bootstrap.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/datatables.net-bs/js/dataTables.bootstrap.js?")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Responsive 2.0.0\n * 2014-2015 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     Responsive\n * @description Responsive tables plug-in for DataTables\n * @version     2.0.0\n * @file        dataTables.responsive.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2014-2015 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n(function( factory ){\n	if ( true ) {\n		// AMD\n		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function ( $ ) {\n			return factory( $, window, document );\n		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n	}\n	else if ( typeof exports === 'object' ) {\n		// CommonJS\n		module.exports = function (root, $) {\n			if ( ! root ) {\n				root = window;\n			}\n\n			if ( ! $ || ! $.fn.dataTable ) {\n				$ = require('datatables.net')(root, $).$;\n			}\n\n			return factory( $, root, root.document );\n		};\n	}\n	else {\n		// Browser\n		factory( jQuery, window, document );\n	}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n/**\n * Responsive is a plug-in for the DataTables library that makes use of\n * DataTables' ability to change the visibility of columns, changing the\n * visibility of columns so the displayed columns fit into the table container.\n * The end result is that complex tables will be dynamically adjusted to fit\n * into the viewport, be it on a desktop, tablet or mobile browser.\n *\n * Responsive for DataTables has two modes of operation, which can used\n * individually or combined:\n *\n * * Class name based control - columns assigned class names that match the\n *   breakpoint logic can be shown / hidden as required for each breakpoint.\n * * Automatic control - columns are automatically hidden when there is no\n *   room left to display them. Columns removed from the right.\n *\n * In additional to column visibility control, Responsive also has built into\n * options to use DataTables' child row display to show / hide the information\n * from the table that has been hidden. There are also two modes of operation\n * for this child row display:\n *\n * * Inline - when the control element that the user can use to show / hide\n *   child rows is displayed inside the first column of the table.\n * * Column - where a whole column is dedicated to be the show / hide control.\n *\n * Initialisation of Responsive is performed by:\n *\n * * Adding the class `responsive` or `dt-responsive` to the table. In this case\n *   Responsive will automatically be initialised with the default configuration\n *   options when the DataTable is created.\n * * Using the `responsive` option in the DataTables configuration options. This\n *   can also be used to specify the configuration options, or simply set to\n *   `true` to use the defaults.\n *\n *  @class\n *  @param {object} settings DataTables settings object for the host table\n *  @param {object} [opts] Configuration options\n *  @requires jQuery 1.7+\n *  @requires DataTables 1.10.3+\n *\n *  @example\n *      $('#example').DataTable( {\n *        responsive: true\n *      } );\n *    } );\n */\nvar Responsive = function ( settings, opts ) {\n	// Sanity check that we are using DataTables 1.10 or newer\n	if ( ! DataTable.versionCheck || ! DataTable.versionCheck( '1.10.3' ) ) {\n		throw 'DataTables Responsive requires DataTables 1.10.3 or newer';\n	}\n\n	this.s = {\n		dt: new DataTable.Api( settings ),\n		columns: [],\n		current: []\n	};\n\n	// Check if responsive has already been initialised on this table\n	if ( this.s.dt.settings()[0].responsive ) {\n		return;\n	}\n\n	// details is an object, but for simplicity the user can give it as a string\n	if ( opts && typeof opts.details === 'string' ) {\n		opts.details = { type: opts.details };\n	}\n\n	this.c = $.extend( true, {}, Responsive.defaults, DataTable.defaults.responsive, opts );\n	settings.responsive = this;\n	this._constructor();\n};\n\n$.extend( Responsive.prototype, {\n	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n	 * Constructor\n	 */\n\n	/**\n	 * Initialise the Responsive instance\n	 *\n	 * @private\n	 */\n	_constructor: function ()\n	{\n		var that = this;\n		var dt = this.s.dt;\n		var dtPrivateSettings = dt.settings()[0];\n\n		dt.settings()[0]._responsive = this;\n\n		// Use DataTables' throttle function to avoid processor thrashing on\n		// resize\n		$(window).on( 'resize.dtr orientationchange.dtr', DataTable.util.throttle( function () {\n			that._resize();\n		} ) );\n\n		// DataTables doesn't currently trigger an event when a row is added, so\n		// we need to hook into its private API to enforce the hidden rows when\n		// new data is added\n		dtPrivateSettings.oApi._fnCallbackReg( dtPrivateSettings, 'aoRowCreatedCallback', function (tr, data, idx) {\n			if ( $.inArray( false, that.s.current ) !== -1 ) {\n				$('td, th', tr).each( function ( i ) {\n					var idx = dt.column.index( 'toData', i );\n\n					if ( that.s.current[idx] === false ) {\n						$(this).css('display', 'none');\n					}\n				} );\n			}\n		} );\n\n		// Destroy event handler\n		dt.on( 'destroy.dtr', function () {\n			dt.off( '.dtr' );\n			$( dt.table().body() ).off( '.dtr' );\n			$(window).off( 'resize.dtr orientationchange.dtr' );\n\n			// Restore the columns that we've hidden\n			$.each( that.s.current, function ( i, val ) {\n				if ( val === false ) {\n					that._setColumnVis( i, true );\n				}\n			} );\n		} );\n\n		// Reorder the breakpoints array here in case they have been added out\n		// of order\n		this.c.breakpoints.sort( function (a, b) {\n			return a.width < b.width ? 1 :\n				a.width > b.width ? -1 : 0;\n		} );\n\n		this._classLogic();\n		this._resizeAuto();\n\n		// Details handler\n		var details = this.c.details;\n		if ( details.type !== false ) {\n			that._detailsInit();\n\n			// DataTables will trigger this event on every column it shows and\n			// hides individually\n			dt.on( 'column-visibility.dtr', function (e, ctx, col, vis) {\n				that._classLogic();\n				that._resizeAuto();\n				that._resize();\n			} );\n\n			// Redraw the details box on each draw which will happen if the data\n			// has changed. This is used until DataTables implements a native\n			// `updated` event for rows\n			dt.on( 'draw.dtr', function () {\n				that._redrawChildren();\n			} );\n\n			$(dt.table().node()).addClass( 'dtr-'+details.type );\n		}\n\n		dt.on( 'column-reorder.dtr', function (e, settings, details) {\n			// This requires ColReorder 1.2.1 or newer\n			if ( details.drop ) {\n				that._classLogic();\n				that._resizeAuto();\n				that._resize();\n			}\n		} );\n\n		// First pass - draw the table for the current viewport size\n		this._resize();\n	},\n\n\n	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n	 * Private methods\n	 */\n\n	/**\n	 * Calculate the visibility for the columns in a table for a given\n	 * breakpoint. The result is pre-determined based on the class logic if\n	 * class names are used to control all columns, but the width of the table\n	 * is also used if there are columns which are to be automatically shown\n	 * and hidden.\n	 *\n	 * @param  {string} breakpoint Breakpoint name to use for the calculation\n	 * @return {array} Array of boolean values initiating the visibility of each\n	 *   column.\n	 *  @private\n	 */\n	_columnsVisiblity: function ( breakpoint )\n	{\n		var dt = this.s.dt;\n		var columns = this.s.columns;\n		var i, ien;\n\n		// Create an array that defines the column ordering based first on the\n		// column's priority, and secondly the column index. This allows the\n		// columns to be removed from the right if the priority matches\n		var order = columns\n			.map( function ( col, idx ) {\n				return {\n					columnIdx: idx,\n					priority: col.priority\n				};\n			} )\n			.sort( function ( a, b ) {\n				if ( a.priority !== b.priority ) {\n					return a.priority - b.priority;\n				}\n				return a.columnIdx - b.columnIdx;\n			} );\n\n\n		// Class logic - determine which columns are in this breakpoint based\n		// on the classes. If no class control (i.e. `auto`) then `-` is used\n		// to indicate this to the rest of the function\n		var display = $.map( columns, function ( col ) {\n			return col.auto && col.minWidth === null ?\n				false :\n				col.auto === true ?\n					'-' :\n					$.inArray( breakpoint, col.includeIn ) !== -1;\n		} );\n\n		// Auto column control - first pass: how much width is taken by the\n		// ones that must be included from the non-auto columns\n		var requiredWidth = 0;\n		for ( i=0, ien=display.length ; i<ien ; i++ ) {\n			if ( display[i] === true ) {\n				requiredWidth += columns[i].minWidth;\n			}\n		}\n\n		// Second pass, use up any remaining width for other columns. For\n		// scrolling tables we need to subtract the width of the scrollbar. It\n		// may not be requires which makes this sub-optimal, but it would\n		// require another full redraw to make complete use of those extra few\n		// pixels\n		var scrolling = dt.settings()[0].oScroll;\n		var bar = scrolling.sY || scrolling.sX ? scrolling.iBarWidth : 0;\n		var widthAvailable = dt.table().container().offsetWidth - bar;\n		var usedWidth = widthAvailable - requiredWidth;\n\n		// Control column needs to always be included. This makes it sub-\n		// optimal in terms of using the available with, but to stop layout\n		// thrashing or overflow. Also we need to account for the control column\n		// width first so we know how much width is available for the other\n		// columns, since the control column might not be the first one shown\n		for ( i=0, ien=display.length ; i<ien ; i++ ) {\n			if ( columns[i].control ) {\n				usedWidth -= columns[i].minWidth;\n			}\n		}\n\n		// Allow columns to be shown (counting by priority and then right to\n		// left) until we run out of room\n		var empty = false;\n		for ( i=0, ien=order.length ; i<ien ; i++ ) {\n			var colIdx = order[i].columnIdx;\n\n			if ( display[colIdx] === '-' && ! columns[colIdx].control && columns[colIdx].minWidth ) {\n				// Once we've found a column that won't fit we don't let any\n				// others display either, or columns might disappear in the\n				// middle of the table\n				if ( empty || usedWidth - columns[colIdx].minWidth < 0 ) {\n					empty = true;\n					display[colIdx] = false;\n				}\n				else {\n					display[colIdx] = true;\n				}\n\n				usedWidth -= columns[colIdx].minWidth;\n			}\n		}\n\n		// Determine if the 'control' column should be shown (if there is one).\n		// This is the case when there is a hidden column (that is not the\n		// control column). The two loops look inefficient here, but they are\n		// trivial and will fly through. We need to know the outcome from the\n		// first , before the action in the second can be taken\n		var showControl = false;\n\n		for ( i=0, ien=columns.length ; i<ien ; i++ ) {\n			if ( ! columns[i].control && ! columns[i].never && ! display[i] ) {\n				showControl = true;\n				break;\n			}\n		}\n\n		for ( i=0, ien=columns.length ; i<ien ; i++ ) {\n			if ( columns[i].control ) {\n				display[i] = showControl;\n			}\n		}\n\n		// Finally we need to make sure that there is at least one column that\n		// is visible\n		if ( $.inArray( true, display ) === -1 ) {\n			display[0] = true;\n		}\n\n		return display;\n	},\n\n\n	/**\n	 * Create the internal `columns` array with information about the columns\n	 * for the table. This includes determining which breakpoints the column\n	 * will appear in, based upon class names in the column, which makes up the\n	 * vast majority of this method.\n	 *\n	 * @private\n	 */\n	_classLogic: function ()\n	{\n		var that = this;\n		var calc = {};\n		var breakpoints = this.c.breakpoints;\n		var dt = this.s.dt;\n		var columns = dt.columns().eq(0).map( function (i) {\n			var column = this.column(i);\n			var className = column.header().className;\n			var priority = dt.settings()[0].aoColumns[i].responsivePriority;\n\n			if ( priority === undefined ) {\n				priority = $(column.header).data('priority') !== undefined ?\n					$(column.header).data('priority') * 1 :\n					10000;\n			}\n\n			return {\n				className: className,\n				includeIn: [],\n				auto:      false,\n				control:   false,\n				never:     className.match(/\\bnever\\b/) ? true : false,\n				priority:  priority\n			};\n		} );\n\n		// Simply add a breakpoint to `includeIn` array, ensuring that there are\n		// no duplicates\n		var add = function ( colIdx, name ) {\n			var includeIn = columns[ colIdx ].includeIn;\n\n			if ( $.inArray( name, includeIn ) === -1 ) {\n				includeIn.push( name );\n			}\n		};\n\n		var column = function ( colIdx, name, operator, matched ) {\n			var size, i, ien;\n\n			if ( ! operator ) {\n				columns[ colIdx ].includeIn.push( name );\n			}\n			else if ( operator === 'max-' ) {\n				// Add this breakpoint and all smaller\n				size = that._find( name ).width;\n\n				for ( i=0, ien=breakpoints.length ; i<ien ; i++ ) {\n					if ( breakpoints[i].width <= size ) {\n						add( colIdx, breakpoints[i].name );\n					}\n				}\n			}\n			else if ( operator === 'min-' ) {\n				// Add this breakpoint and all larger\n				size = that._find( name ).width;\n\n				for ( i=0, ien=breakpoints.length ; i<ien ; i++ ) {\n					if ( breakpoints[i].width >= size ) {\n						add( colIdx, breakpoints[i].name );\n					}\n				}\n			}\n			else if ( operator === 'not-' ) {\n				// Add all but this breakpoint\n				for ( i=0, ien=breakpoints.length ; i<ien ; i++ ) {\n					if ( breakpoints[i].name.indexOf( matched ) === -1 ) {\n						add( colIdx, breakpoints[i].name );\n					}\n				}\n			}\n		};\n\n		// Loop over each column and determine if it has a responsive control\n		// class\n		columns.each( function ( col, i ) {\n			var classNames = col.className.split(' ');\n			var hasClass = false;\n\n			// Split the class name up so multiple rules can be applied if needed\n			for ( var k=0, ken=classNames.length ; k<ken ; k++ ) {\n				var className = $.trim( classNames[k] );\n\n				if ( className === 'all' ) {\n					// Include in all\n					hasClass = true;\n					col.includeIn = $.map( breakpoints, function (a) {\n						return a.name;\n					} );\n					return;\n				}\n				else if ( className === 'none' || col.never ) {\n					// Include in none (default) and no auto\n					hasClass = true;\n					return;\n				}\n				else if ( className === 'control' ) {\n					// Special column that is only visible, when one of the other\n					// columns is hidden. This is used for the details control\n					hasClass = true;\n					col.control = true;\n					return;\n				}\n\n				$.each( breakpoints, function ( j, breakpoint ) {\n					// Does this column have a class that matches this breakpoint?\n					var brokenPoint = breakpoint.name.split('-');\n					var re = new RegExp( '(min\\\\-|max\\\\-|not\\\\-)?('+brokenPoint[0]+')(\\\\-[_a-zA-Z0-9])?' );\n					var match = className.match( re );\n\n					if ( match ) {\n						hasClass = true;\n\n						if ( match[2] === brokenPoint[0] && match[3] === '-'+brokenPoint[1] ) {\n							// Class name matches breakpoint name fully\n							column( i, breakpoint.name, match[1], match[2]+match[3] );\n						}\n						else if ( match[2] === brokenPoint[0] && ! match[3] ) {\n							// Class name matched primary breakpoint name with no qualifier\n							column( i, breakpoint.name, match[1], match[2] );\n						}\n					}\n				} );\n			}\n\n			// If there was no control class, then automatic sizing is used\n			if ( ! hasClass ) {\n				col.auto = true;\n			}\n		} );\n\n		this.s.columns = columns;\n	},\n\n\n	/**\n	 * Show the details for the child row\n	 *\n	 * @param  {DataTables.Api} row    API instance for the row\n	 * @param  {boolean}        update Update flag\n	 * @private\n	 */\n	_detailsDisplay: function ( row, update )\n	{\n		var that = this;\n		var dt = this.s.dt;\n\n		var res = this.c.details.display( row, update, function () {\n			return that.c.details.renderer(\n				dt, row[0], that._detailsObj(row[0])\n			);\n		} );\n\n		if ( res === true || res === false ) {\n			$(dt.table().node()).triggerHandler( 'responsive-display.dt', [dt, row, res, update] );\n		}\n	},\n\n\n	/**\n	 * Initialisation for the details handler\n	 *\n	 * @private\n	 */\n	_detailsInit: function ()\n	{\n		var that    = this;\n		var dt      = this.s.dt;\n		var details = this.c.details;\n\n		// The inline type always uses the first child as the target\n		if ( details.type === 'inline' ) {\n			details.target = 'td:first-child';\n		}\n\n		// Keyboard accessibility\n		dt.on( 'draw.dtr', function () {\n			that._tabIndexes();\n		} );\n		that._tabIndexes(); // Initial draw has already happened\n\n		$( dt.table().body() ).on( 'keyup.dtr', 'td', function (e) {\n			if ( e.keyCode === 13 && $(this).data('dtr-keyboard') ) {\n				$(this).click();\n			}\n		} );\n\n		// type.target can be a string jQuery selector or a column index\n		var target   = details.target;\n		var selector = typeof target === 'string' ? target : 'td';\n\n		// Click handler to show / hide the details rows when they are available\n		$( dt.table().body() )\n			.on( 'mousedown.dtr', selector, function (e) {\n				// For mouse users, prevent the focus ring from showing\n				e.preventDefault();\n			} )\n			.on( 'click.dtr', selector, function () {\n				// If the table is not collapsed (i.e. there is no hidden columns)\n				// then take no action\n				if ( ! $(dt.table().node()).hasClass('collapsed' ) ) {\n					return;\n				}\n\n				// Check that the row is actually a DataTable's controlled node\n				if ( ! dt.row( $(this).closest('tr') ).length ) {\n					return;\n				}\n\n				// For column index, we determine if we should act or not in the\n				// handler - otherwise it is already okay\n				if ( typeof target === 'number' ) {\n					var targetIdx = target < 0 ?\n						dt.columns().eq(0).length + target :\n						target;\n\n					if ( dt.cell( this ).index().column !== targetIdx ) {\n						return;\n					}\n				}\n\n				// $().closest() includes itself in its check\n				var row = dt.row( $(this).closest('tr') );\n\n				// The renderer is given as a function so the caller can execute it\n				// only when they need (i.e. if hiding there is no point is running\n				// the renderer)\n				that._detailsDisplay( row, false );\n			} );\n	},\n\n\n	/**\n	 * Get the details to pass to a renderer for a row\n	 * @param  {int} rowIdx Row index\n	 * @private\n	 */\n	_detailsObj: function ( rowIdx )\n	{\n		var that = this;\n		var dt = this.s.dt;\n\n		return $.map( this.s.columns, function( col, i ) {\n			if ( col.never ) {\n				return;\n			}\n\n			return {\n				title:   dt.settings()[0].aoColumns[ i ].sTitle,\n				data:    dt.cell( rowIdx, i ).render( that.c.orthogonal ),\n				hidden:  dt.column( i ).visible() && !that.s.current[ i ]\n			};\n		} );\n	},\n\n\n	/**\n	 * Find a breakpoint object from a name\n	 *\n	 * @param  {string} name Breakpoint name to find\n	 * @return {object}      Breakpoint description object\n	 * @private\n	 */\n	_find: function ( name )\n	{\n		var breakpoints = this.c.breakpoints;\n\n		for ( var i=0, ien=breakpoints.length ; i<ien ; i++ ) {\n			if ( breakpoints[i].name === name ) {\n				return breakpoints[i];\n			}\n		}\n	},\n\n\n	/**\n	 * Re-create the contents of the child rows as the display has changed in\n	 * some way.\n	 *\n	 * @private\n	 */\n	_redrawChildren: function ()\n	{\n		var that = this;\n		var dt = this.s.dt;\n\n		dt.rows( {page: 'current'} ).iterator( 'row', function ( settings, idx ) {\n			var row = dt.row( idx );\n\n			that._detailsDisplay( dt.row( idx ), true );\n		} );\n	},\n\n\n	/**\n	 * Alter the table display for a resized viewport. This involves first\n	 * determining what breakpoint the window currently is in, getting the\n	 * column visibilities to apply and then setting them.\n	 *\n	 * @private\n	 */\n	_resize: function ()\n	{\n		var that = this;\n		var dt = this.s.dt;\n		var width = $(window).width();\n		var breakpoints = this.c.breakpoints;\n		var breakpoint = breakpoints[0].name;\n		var columns = this.s.columns;\n		var i, ien;\n		var oldVis = this.s.current.slice();\n\n		// Determine what breakpoint we are currently at\n		for ( i=breakpoints.length-1 ; i>=0 ; i-- ) {\n			if ( width <= breakpoints[i].width ) {\n				breakpoint = breakpoints[i].name;\n				break;\n			}\n		}\n		\n		// Show the columns for that break point\n		var columnsVis = this._columnsVisiblity( breakpoint );\n		this.s.current = columnsVis;\n\n		// Set the class before the column visibility is changed so event\n		// listeners know what the state is. Need to determine if there are\n		// any columns that are not visible but can be shown\n		var collapsedClass = false;\n		for ( i=0, ien=columns.length ; i<ien ; i++ ) {\n			if ( columnsVis[i] === false && ! columns[i].never ) {\n				collapsedClass = true;\n				break;\n			}\n		}\n\n		$( dt.table().node() ).toggleClass( 'collapsed', collapsedClass );\n\n		var changed = false;\n\n		dt.columns().eq(0).each( function ( colIdx, i ) {\n			if ( columnsVis[i] !== oldVis[i] ) {\n				changed = true;\n				that._setColumnVis( colIdx, columnsVis[i] );\n			}\n		} );\n\n		if ( changed ) {\n			this._redrawChildren();\n		}\n	},\n\n\n	/**\n	 * Determine the width of each column in the table so the auto column hiding\n	 * has that information to work with. This method is never going to be 100%\n	 * perfect since column widths can change slightly per page, but without\n	 * seriously compromising performance this is quite effective.\n	 *\n	 * @private\n	 */\n	_resizeAuto: function ()\n	{\n		var dt = this.s.dt;\n		var columns = this.s.columns;\n\n		// Are we allowed to do auto sizing?\n		if ( ! this.c.auto ) {\n			return;\n		}\n\n		// Are there any columns that actually need auto-sizing, or do they all\n		// have classes defined\n		if ( $.inArray( true, $.map( columns, function (c) { return c.auto; } ) ) === -1 ) {\n			return;\n		}\n\n		// Clone the table with the current data in it\n		var tableWidth   = dt.table().node().offsetWidth;\n		var columnWidths = dt.columns;\n		var clonedTable  = dt.table().node().cloneNode( false );\n		var clonedHeader = $( dt.table().header().cloneNode( false ) ).appendTo( clonedTable );\n		var clonedBody   = $( dt.table().body().cloneNode( false ) ).appendTo( clonedTable );\n\n		// Header\n		var headerCells = dt.columns()\n			.header()\n			.filter( function (idx) {\n				return dt.column(idx).visible();\n			} )\n			.to$()\n			.clone( false )\n			.css( 'display', 'table-cell' );\n\n		// Body rows - we don't need to take account of DataTables' column\n		// visibility since we implement our own here (hence the `display` set)\n		$(clonedBody)\n			.append( $(dt.rows( { page: 'current' } ).nodes()).clone( false ) )\n			.find( 'th, td' ).css( 'display', '' );\n\n		// Footer\n		var footer = dt.table().footer();\n		if ( footer ) {\n			var clonedFooter = $( footer.cloneNode( false ) ).appendTo( clonedTable );\n			var footerCells = dt.columns()\n				.header()\n				.filter( function (idx) {\n					return dt.column(idx).visible();\n				} )\n				.to$()\n				.clone( false )\n				.css( 'display', 'table-cell' );\n\n			$('<tr/>')\n				.append( footerCells )\n				.appendTo( clonedFooter );\n		}\n\n		$('<tr/>')\n			.append( headerCells )\n			.appendTo( clonedHeader );\n\n		// In the inline case extra padding is applied to the first column to\n		// give space for the show / hide icon. We need to use this in the\n		// calculation\n		if ( this.c.details.type === 'inline' ) {\n			$(clonedTable).addClass( 'dtr-inline collapsed' );\n		}\n\n		var inserted = $('<div/>')\n			.css( {\n				width: 1,\n				height: 1,\n				overflow: 'hidden'\n			} )\n			.append( clonedTable );\n\n		inserted.insertBefore( dt.table().node() );\n\n		// The cloned header now contains the smallest that each column can be\n		headerCells.each( function (i) {\n			var idx = dt.column.index( 'fromVisible', i );\n			columns[ idx ].minWidth =  this.offsetWidth || 0;\n		} );\n\n		inserted.remove();\n	},\n\n	/**\n	 * Set a column's visibility.\n	 *\n	 * We don't use DataTables' column visibility controls in order to ensure\n	 * that column visibility can Responsive can no-exist. Since only IE8+ is\n	 * supported (and all evergreen browsers of course) the control of the\n	 * display attribute works well.\n	 *\n	 * @param {integer} col      Column index\n	 * @param {boolean} showHide Show or hide (true or false)\n	 * @private\n	 */\n	_setColumnVis: function ( col, showHide )\n	{\n		var dt = this.s.dt;\n		var display = showHide ? '' : 'none'; // empty string will remove the attr\n\n		$( dt.column( col ).header() ).css( 'display', display );\n		$( dt.column( col ).footer() ).css( 'display', display );\n		dt.column( col ).nodes().to$().css( 'display', display );\n	},\n\n\n	/**\n	 * Update the cell tab indexes for keyboard accessibility. This is called on\n	 * every table draw - that is potentially inefficient, but also the least\n	 * complex option given that column visibility can change on the fly. Its a\n	 * shame user-focus was removed from CSS 3 UI, as it would have solved this\n	 * issue with a single CSS statement.\n	 *\n	 * @private\n	 */\n	_tabIndexes: function ()\n	{\n		var dt = this.s.dt;\n		var cells = dt.cells( { page: 'current' } ).nodes().to$();\n		var ctx = dt.settings()[0];\n		var target = this.c.details.target;\n\n		cells.filter( '[data-dtr-keyboard]' ).removeData( '[data-dtr-keyboard]' );\n\n		var selector = typeof target === 'number' ?\n			':eq('+target+')' :\n			target;\n\n		$( selector, dt.rows( { page: 'current' } ).nodes() )\n			.attr( 'tabIndex', ctx.iTabIndex )\n			.data( 'dtr-keyboard', 1 );\n	}\n} );\n\n\n/**\n * List of default breakpoints. Each item in the array is an object with two\n * properties:\n *\n * * `name` - the breakpoint name.\n * * `width` - the breakpoint width\n *\n * @name Responsive.breakpoints\n * @static\n */\nResponsive.breakpoints = [\n	{ name: 'desktop',  width: Infinity },\n	{ name: 'tablet-l', width: 1024 },\n	{ name: 'tablet-p', width: 768 },\n	{ name: 'mobile-l', width: 480 },\n	{ name: 'mobile-p', width: 320 }\n];\n\n\n/**\n * Display methods - functions which define how the hidden data should be shown\n * in the table.\n *\n * @namespace\n * @name Responsive.defaults\n * @static\n */\nResponsive.display = {\n	childRow: function ( row, update, render ) {\n		if ( update ) {\n			if ( $(row.node()).hasClass('parent') ) {\n				row.child( render(), 'child' ).show();\n\n				return true;\n			}\n		}\n		else {\n			if ( ! row.child.isShown()  ) {\n				row.child( render(), 'child' ).show();\n				$( row.node() ).addClass( 'parent' );\n\n				return true;\n			}\n			else {\n				row.child( false );\n				$( row.node() ).removeClass( 'parent' );\n\n				return false;\n			}\n		}\n	},\n\n	childRowImmediate: function ( row, update, render ) {\n		if ( (! update && row.child.isShown()) || ! row.responsive.hasHidden() ) {\n			// User interaction and the row is show, or nothing to show\n			row.child( false );\n			$( row.node() ).removeClass( 'parent' );\n\n			return false;\n		}\n		else {\n			// Display\n			row.child( render(), 'child' ).show();\n			$( row.node() ).addClass( 'parent' );\n\n			return true;\n		}\n	},\n\n	// This is a wrapper so the modal options for Bootstrap and jQuery UI can\n	// have options passed into them. This specific one doesn't need to be a\n	// function but it is for consistency in the `modal` name\n	modal: function ( options ) {\n		return function ( row, update, render ) {\n			if ( ! update ) {\n				// Show a modal\n				var close = function () {\n					modal.remove(); // will tidy events for us\n					$(document).off( 'keypress.dtr' );\n				};\n\n				var modal = $('<div class=\"dtr-modal\"/>')\n					.append( $('<div class=\"dtr-modal-display\"/>')\n						.append( $('<div class=\"dtr-modal-content\"/>')\n							.append( render() )\n						)\n						.append( $('<div class=\"dtr-modal-close\">&times;</div>' )\n							.click( function () {\n								close();\n							} )\n						)\n					)\n					.append( $('<div class=\"dtr-modal-background\"/>')\n						.click( function () {\n							close();\n						} )\n					)\n					.appendTo( 'body' );\n\n				if ( options && options.header ) {\n					modal.find( 'div.dtr-modal-content' ).prepend(\n						'<h2>'+options.header( row )+'</h2>'\n					);\n				}\n\n				$(document).on( 'keyup.dtr', function (e) {\n					if ( e.keyCode === 27 ) {\n						e.stopPropagation();\n\n						close();\n					}\n				} );\n			}\n			else {\n				$('div.dtr-modal-content')\n					.empty()\n					.append( render() );\n			}\n		};\n	}\n};\n\n\n/**\n * Responsive default settings for initialisation\n *\n * @namespace\n * @name Responsive.defaults\n * @static\n */\nResponsive.defaults = {\n	/**\n	 * List of breakpoints for the instance. Note that this means that each\n	 * instance can have its own breakpoints. Additionally, the breakpoints\n	 * cannot be changed once an instance has been creased.\n	 *\n	 * @type {Array}\n	 * @default Takes the value of `Responsive.breakpoints`\n	 */\n	breakpoints: Responsive.breakpoints,\n\n	/**\n	 * Enable / disable auto hiding calculations. It can help to increase\n	 * performance slightly if you disable this option, but all columns would\n	 * need to have breakpoint classes assigned to them\n	 *\n	 * @type {Boolean}\n	 * @default  `true`\n	 */\n	auto: true,\n\n	/**\n	 * Details control. If given as a string value, the `type` property of the\n	 * default object is set to that value, and the defaults used for the rest\n	 * of the object - this is for ease of implementation.\n	 *\n	 * The object consists of the following properties:\n	 *\n	 * * `display` - A function that is used to show and hide the hidden details\n	 * * `renderer` - function that is called for display of the child row data.\n	 *   The default function will show the data from the hidden columns\n	 * * `target` - Used as the selector for what objects to attach the child\n	 *   open / close to\n	 * * `type` - `false` to disable the details display, `inline` or `column`\n	 *   for the two control types\n	 *\n	 * @type {Object|string}\n	 */\n	details: {\n		display: Responsive.display.childRow,\n\n		renderer: function ( api, rowIdx, columns ) {\n			var data = $.map( columns, function ( col, i ) {\n				return col.hidden ?\n					'<li data-dtr-index=\"'+i+'\">'+\n						'<span class=\"dtr-title\">'+\n							col.title+\n						'</span> '+\n						'<span class=\"dtr-data\">'+\n							col.data+\n						'</span>'+\n					'</li>' :\n					'';\n			} ).join('');\n\n			return data ?\n				$('<ul data-dtr-index=\"'+rowIdx+'\"/>').append( data ) :\n				false;\n		},\n\n		target: 0,\n\n		type: 'inline'\n	},\n\n	/**\n	 * Orthogonal data request option. This is used to define the data type\n	 * requested when Responsive gets the data to show in the child row.\n	 *\n	 * @type {String}\n	 */\n	orthogonal: 'display'\n};\n\n\n/*\n * API\n */\nvar Api = $.fn.dataTable.Api;\n\n// Doesn't do anything - work around for a bug in DT... Not documented\nApi.register( 'responsive()', function () {\n	return this;\n} );\n\nApi.register( 'responsive.index()', function ( li ) {\n	li = $(li);\n\n	return {\n		column: li.data('dtr-index'),\n		row:    li.parent().data('dtr-index')\n	};\n} );\n\nApi.register( 'responsive.rebuild()', function () {\n	return this.iterator( 'table', function ( ctx ) {\n		if ( ctx._responsive ) {\n			ctx._responsive._classLogic();\n		}\n	} );\n} );\n\nApi.register( 'responsive.recalc()', function () {\n	return this.iterator( 'table', function ( ctx ) {\n		if ( ctx._responsive ) {\n			ctx._responsive._resizeAuto();\n			ctx._responsive._resize();\n		}\n	} );\n} );\n\nApi.register( 'responsive.hasHidden()', function () {\n	var ctx = this.context[0];\n\n	return ctx._responsive ?\n		$.inArray( false, ctx._responsive.s.current ) !== -1 :\n		false;\n} );\n\n\n/**\n * Version information\n *\n * @name Responsive.version\n * @static\n */\nResponsive.version = '2.0.0';\n\n\n$.fn.dataTable.Responsive = Responsive;\n$.fn.DataTable.Responsive = Responsive;\n\n// Attach a listener to the document which listens for DataTables initialisation\n// events so we can automatically initialise\n$(document).on( 'init.dt.dtr', function (e, settings, json) {\n	if ( e.namespace !== 'dt' ) {\n		return;\n	}\n\n	if ( $(settings.nTable).hasClass( 'responsive' ) ||\n		 $(settings.nTable).hasClass( 'dt-responsive' ) ||\n		 settings.oInit.responsive ||\n		 DataTable.defaults.responsive\n	) {\n		var init = settings.oInit.responsive;\n\n		if ( init !== false ) {\n			new Responsive( settings, $.isPlainObject( init ) ? init : {}  );\n		}\n	}\n} );\n\n\nreturn Responsive;\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datatables.net-responsive/js/dataTables.responsive.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/datatables.net-responsive/js/dataTables.responsive.js?");
},function(module,exports){eval("// removed by extract-text-webpack-plugin\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/assets/css/font-awesome-4.4.0/css/font-awesome.min.css\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/assets/css/font-awesome-4.4.0/css/font-awesome.min.css?")},function(module,exports){eval("// removed by extract-text-webpack-plugin\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/assets/vendor/jQuery-QueryBuilder-master/dist/css/query-builder.default.min.css\n ** module id = 13\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/assets/vendor/jQuery-QueryBuilder-master/dist/css/query-builder.default.min.css?")},function(module,exports){eval("// removed by extract-text-webpack-plugin\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/assets/vendor/select2-4.0.1-rc.1/dist/css/select2.min.css\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/assets/vendor/select2-4.0.1-rc.1/dist/css/select2.min.css?")},function(module,exports){eval("// removed by extract-text-webpack-plugin\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datatables.net-bs/css/dataTables.bootstrap.css\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/datatables.net-bs/css/dataTables.bootstrap.css?")},function(module,exports){eval("// removed by extract-text-webpack-plugin\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datatables.net-responsive-bs/css/responsive.bootstrap.css\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/datatables.net-responsive-bs/css/responsive.bootstrap.css?")},function(module,exports){eval("// removed by extract-text-webpack-plugin\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/assets/css/index.less\n ** module id = 17\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/assets/css/index.less?")},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "ch.svg";\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/assets/images/flags/ch.svg\n ** module id = 18\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/assets/images/flags/ch.svg?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "us.svg";\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/assets/images/flags/us.svg\n ** module id = 19\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/assets/images/flags/us.svg?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "index.html";\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.html\n ** module id = 20\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./index.html?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "data-variants.json";\n\n/*****************\n ** WEBPACK FOOTER\n ** ./json/data-variants.json\n ** module id = 21\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./json/data-variants.json?')},function(module,exports,__webpack_require__){eval('/*\r\n	MIT License http://www.opensource.org/licenses/mit-license.php\r\n	Author Tobias Koppers @sokra\r\n*/\r\n/*globals window __webpack_hash__ */\r\nif(true) {\r\n	var lastData;\r\n	var upToDate = function upToDate() {\r\n		return lastData.indexOf(__webpack_require__.h()) >= 0;\r\n	};\r\n	var check = function check() {\r\n		module.hot.check(true, function(err, updatedModules) {\r\n			if(err) {\r\n				if(module.hot.status() in {\r\n						abort: 1,\r\n						fail: 1\r\n					}) {\r\n					console.warn("[HMR] Cannot apply update. Need to do a full reload!");\r\n					console.warn("[HMR] " + err.stack || err.message);\r\n					window.location.reload();\r\n				} else {\r\n					console.warn("[HMR] Update failed: " + err.stack || err.message);\r\n				}\r\n				return;\r\n			}\r\n\r\n			if(!updatedModules) {\r\n				console.warn("[HMR] Cannot find update. Need to do a full reload!");\r\n				console.warn("[HMR] (Probably because of restarting the webpack-dev-server)");\r\n				window.location.reload();\r\n				return;\r\n			}\r\n\r\n			if(!upToDate()) {\r\n				check();\r\n			}\r\n\r\n			__webpack_require__(23)(updatedModules, updatedModules);\r\n\r\n			if(upToDate()) {\r\n				console.log("[HMR] App is up to date.");\r\n			}\r\n\r\n		});\r\n	};\r\n	var addEventListener = window.addEventListener ? function(eventName, listener) {\r\n		window.addEventListener(eventName, listener, false);\r\n	} : function(eventName, listener) {\r\n		window.attachEvent("on" + eventName, listener);\r\n	};\r\n	addEventListener("message", function(event) {\r\n		if(typeof event.data === "string" && event.data.indexOf("webpackHotUpdate") === 0) {\r\n			lastData = event.data;\r\n			if(!upToDate() && module.hot.status() === "idle") {\r\n				console.log("[HMR] Checking for updates on the server...");\r\n				check();\r\n			}\r\n		}\r\n	});\r\n	console.log("[HMR] Waiting for update signal from WDS...");\r\n} else {\r\n	throw new Error("[HMR] Hot Module Replacement is disabled.");\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/hot/dev-server.js\n ** module id = 22\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/hot/dev-server.js?')},function(module,exports){eval('/*\r\n	MIT License http://www.opensource.org/licenses/mit-license.php\r\n	Author Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(updatedModules, renewedModules) {\r\n	var unacceptedModules = updatedModules.filter(function(moduleId) {\r\n		return renewedModules && renewedModules.indexOf(moduleId) < 0;\r\n	});\r\n\r\n	if(unacceptedModules.length > 0) {\r\n		console.warn("[HMR] The following modules couldn\'t be hot updated: (They would need a full reload!)");\r\n		unacceptedModules.forEach(function(moduleId) {\r\n			console.warn("[HMR]  - " + moduleId);\r\n		});\r\n	}\r\n\r\n	if(!renewedModules || renewedModules.length === 0) {\r\n		console.log("[HMR] Nothing hot updated.");\r\n	} else {\r\n		console.log("[HMR] Updated modules:");\r\n		renewedModules.forEach(function(moduleId) {\r\n			console.log("[HMR]  - " + moduleId);\r\n		});\r\n	}\r\n};\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/hot/log-apply-result.js\n ** module id = 23\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/hot/log-apply-result.js?')}]);